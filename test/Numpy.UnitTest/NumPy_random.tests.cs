// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Numpy.Models;

using Microsoft.VisualStudio.TestTools.UnitTesting;
using Assert = NUnit.Framework.Assert;

namespace Numpy.UnitTest
{
    [TestClass]
    public class NumPy_randomTest : BaseTestCase
    {

        [TestMethod]
        public void randTest()
        {
            // >>> np.random.rand(3,2)
            // array([[ 0.14022471,  0.96360618],  #random
            //        [ 0.37601032,  0.25528411],  #random
            //        [ 0.49313049,  0.94909878]]) #random
            // 

#if TODO
            var given=  np.random.rand(3,2);
            var expected=
                "array([[ 0.14022471,  0.96360618],  #random\n" +
                "       [ 0.37601032,  0.25528411],  #random\n" +
                "       [ 0.49313049,  0.94909878]]) #random";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void randnTest()
        {
            // >>> np.random.randn()
            // 2.1923875335537315 #random
            // 

#if TODO
            var given=  np.random.randn();
            var expected=
                "2.1923875335537315 #random";
            Assert.AreEqual(expected, given.repr);
#endif
            // Two-by-four array of samples from N(3, 6.25):

            // >>> 2.5 * np.random.randn(2, 4) + 3
            // array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],  #random
            //        [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]]) #random
            // 

#if TODO
             given=  2.5 * np.random.randn(2, 4) + 3;
             expected=
                "array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],  #random\n" +
                "       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]]) #random";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void randintTest()
        {
            // >>> np.random.randint(2, size=10)
            // array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0])
            // >>> np.random.randint(1, size=10)
            // array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
            // 

            var given = np.random.randint(2, size: new int[] { 10 });
            Assert.LessOrEqual( (int)np.sum(given), 10);
            given = np.random.randint(1, size: new int[] { 10 });
            var expected =
               "array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])";
            Assert.AreEqual(expected, given.repr);
            // Generate a 2 x 4 array of ints between 0 and 4, inclusive:

            // >>> np.random.randint(5, size=(2, 4))
            // array([[4, 0, 2, 1],
            //        [3, 2, 2, 0]])
            // 

             given=  np.random.randint(5, size:new int[]{2, 4});
            Assert.AreEqual(4, (int)given.max());
            Assert.AreEqual(0, (int)given.min());
        }


        [TestMethod]
        public void random_integersTest()
        {
            // >>> np.random.random_integers(5)
            // 4
            // >>> type(np.random.random_integers(5))
            // <type 'int'>
            // >>> np.random.random_integers(5, size=(3,2))
            // array([[5, 4],
            //        [3, 3],
            //        [4, 5]])
            // 

#if TODO
            var given=  np.random.random_integers(5);
            var expected=
                "4";
            Assert.AreEqual(expected, given.repr);
             given=  type(np.random.random_integers(5));
             expected=
                "<type 'int'>";
            Assert.AreEqual(expected, given.repr);
             given=  np.random.random_integers(5, size=(3,2));
             expected=
                "array([[5, 4],\n" +
                "       [3, 3],\n" +
                "       [4, 5]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Choose five random numbers from the set of five evenly-spaced
            // numbers between 0 and 2.5, inclusive (i.e., from the set
            // ):

            // >>> 2.5 * (np.random.random_integers(5, size=(5,)) - 1) / 4.
            // array([ 0.625,  1.25 ,  0.625,  0.625,  2.5  ])
            // 

#if TODO
             given=  2.5 * (np.random.random_integers(5, size=(5,)) - 1) / 4.;
             expected=
                "array([ 0.625,  1.25 ,  0.625,  0.625,  2.5  ])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Roll two six sided dice 1000 times and sum the results:

            // >>> d1 = np.random.random_integers(1, 6, 1000)
            // >>> d2 = np.random.random_integers(1, 6, 1000)
            // >>> dsums = d1 + d2
            // 

#if TODO
             given=  d1 = np.random.random_integers(1, 6, 1000);
             given=  d2 = np.random.random_integers(1, 6, 1000);
             given=  dsums = d1 + d2;
#endif
            // Display results as a histogram:

            // >>> import matplotlib.pyplot as plt
            // >>> count, bins, ignored = plt.hist(dsums, 11, density=True)
            // >>> plt.show()
            // 

#if TODO
             given=  import matplotlib.pyplot as plt;
             given=  count, bins, ignored = plt.hist(dsums, 11, density=True);
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void random_sampleTest()
        {
            // >>> np.random.random_sample()
            // 0.47108547995356098
            // >>> type(np.random.random_sample())
            // <type 'float'>
            // >>> np.random.random_sample((5,))
            // array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428])
            // 

#if TODO
            var given=  np.random.random_sample();
            var expected=
                "0.47108547995356098";
            Assert.AreEqual(expected, given.repr);
             given=  type(np.random.random_sample());
             expected=
                "<type 'float'>";
            Assert.AreEqual(expected, given.repr);
             given=  np.random.random_sample((5,));
             expected=
                "array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Three-by-two array of random numbers from [-5, 0):

            // >>> 5 * np.random.random_sample((3, 2)) - 5
            // array([[-3.99149989, -0.52338984],
            //        [-2.99091858, -0.79479508],
            //        [-1.23204345, -1.75224494]])
            // 

#if TODO
             given=  5 * np.random.random_sample((3, 2)) - 5;
             expected=
                "array([[-3.99149989, -0.52338984],\n" +
                "       [-2.99091858, -0.79479508],\n" +
                "       [-1.23204345, -1.75224494]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void randomTest()
        {
            // >>> np.random.random_sample()
            // 0.47108547995356098
            // >>> type(np.random.random_sample())
            // <type 'float'>
            // >>> np.random.random_sample((5,))
            // array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428])
            // 

#if TODO
            var given=  np.random.random_sample();
            var expected=
                "0.47108547995356098";
            Assert.AreEqual(expected, given.repr);
             given=  type(np.random.random_sample());
             expected=
                "<type 'float'>";
            Assert.AreEqual(expected, given.repr);
             given=  np.random.random_sample((5,));
             expected=
                "array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Three-by-two array of random numbers from [-5, 0):

            // >>> 5 * np.random.random_sample((3, 2)) - 5
            // array([[-3.99149989, -0.52338984],
            //        [-2.99091858, -0.79479508],
            //        [-1.23204345, -1.75224494]])
            // 

#if TODO
             given=  5 * np.random.random_sample((3, 2)) - 5;
             expected=
                "array([[-3.99149989, -0.52338984],\n" +
                "       [-2.99091858, -0.79479508],\n" +
                "       [-1.23204345, -1.75224494]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void ranfTest()
        {
            // >>> np.random.random_sample()
            // 0.47108547995356098
            // >>> type(np.random.random_sample())
            // <type 'float'>
            // >>> np.random.random_sample((5,))
            // array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428])
            // 

#if TODO
            var given=  np.random.random_sample();
            var expected=
                "0.47108547995356098";
            Assert.AreEqual(expected, given.repr);
             given=  type(np.random.random_sample());
             expected=
                "<type 'float'>";
            Assert.AreEqual(expected, given.repr);
             given=  np.random.random_sample((5,));
             expected=
                "array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Three-by-two array of random numbers from [-5, 0):

            // >>> 5 * np.random.random_sample((3, 2)) - 5
            // array([[-3.99149989, -0.52338984],
            //        [-2.99091858, -0.79479508],
            //        [-1.23204345, -1.75224494]])
            // 

#if TODO
             given=  5 * np.random.random_sample((3, 2)) - 5;
             expected=
                "array([[-3.99149989, -0.52338984],\n" +
                "       [-2.99091858, -0.79479508],\n" +
                "       [-1.23204345, -1.75224494]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void sampleTest()
        {
            // >>> np.random.random_sample()
            // 0.47108547995356098
            // >>> type(np.random.random_sample())
            // <type 'float'>
            // >>> np.random.random_sample((5,))
            // array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428])
            // 

#if TODO
            var given=  np.random.random_sample();
            var expected=
                "0.47108547995356098";
            Assert.AreEqual(expected, given.repr);
             given=  type(np.random.random_sample());
             expected=
                "<type 'float'>";
            Assert.AreEqual(expected, given.repr);
             given=  np.random.random_sample((5,));
             expected=
                "array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Three-by-two array of random numbers from [-5, 0):

            // >>> 5 * np.random.random_sample((3, 2)) - 5
            // array([[-3.99149989, -0.52338984],
            //        [-2.99091858, -0.79479508],
            //        [-1.23204345, -1.75224494]])
            // 

#if TODO
             given=  5 * np.random.random_sample((3, 2)) - 5;
             expected=
                "array([[-3.99149989, -0.52338984],\n" +
                "       [-2.99091858, -0.79479508],\n" +
                "       [-1.23204345, -1.75224494]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void choiceTest()
        {
            // Generate a uniform random sample from np.arange(5) of size 3:

            // >>> np.random.choice(5, 3)
            // array([0, 3, 4])
            // >>> #This is equivalent to np.random.randint(0,5,3)
            // 

#if TODO
            var given=  np.random.choice(5, 3);
            var expected=
                "array([0, 3, 4])";
            Assert.AreEqual(expected, given.repr);
             given=  #This is equivalent to np.random.randint(0,5,3);
#endif
            // Generate a non-uniform random sample from np.arange(5) of size 3:

            // >>> np.random.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0])
            // array([3, 3, 0])
            // 

#if TODO
             given=  np.random.choice(5, 3, p={0.1, 0, 0.3, 0.6, 0});
             expected=
                "array([3, 3, 0])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Generate a uniform random sample from np.arange(5) of size 3 without
            // replacement:

            // >>> np.random.choice(5, 3, replace=False)
            // array([3,1,0])
            // >>> #This is equivalent to np.random.permutation(np.arange(5))[:3]
            // 

#if TODO
             given=  np.random.choice(5, 3, replace=False);
             expected=
                "array([3,1,0])";
            Assert.AreEqual(expected, given.repr);
             given=  #This is equivalent to np.random.permutation(np.arange(5)){:3};
#endif
            // Generate a non-uniform random sample from np.arange(5) of size
            // 3 without replacement:

            // >>> np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])
            // array([2, 3, 0])
            // 

#if TODO
             given=  np.random.choice(5, 3, replace=False, p={0.1, 0, 0.3, 0.6, 0});
             expected=
                "array([2, 3, 0])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Any of the above can be repeated with an arbitrary array-like
            // instead of just integers. For instance:

            // >>> aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']
            // >>> np.random.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])
            // array(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'],
            //       dtype='|S11')
            // 

#if TODO
             given=  aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher'];
             given=  np.random.choice(aa_milne_arr, 5, p={0.5, 0.1, 0.1, 0.3});
             expected=
                "array(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'],\n" +
                "      dtype='|S11')";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void bytesTest()
        {
            // >>> np.random.bytes(10)
            // ' eh\x85\x022SZ\xbf\xa4' #random
            // 

#if TODO
            var given=  np.random.bytes(10);
            var expected=
                "' eh\x85\x022SZ\xbf\xa4' #random";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void shuffleTest()
        {
            // >>> arr = np.arange(10)
            // >>> np.random.shuffle(arr)
            // >>> arr
            // [1 7 5 2 9 4 3 6 0 8]
            // 

#if TODO
            var given=  arr = np.arange(10);
             given=  np.random.shuffle(arr);
             given=  arr;
            var expected=
                "[1 7 5 2 9 4 3 6 0 8]";
            Assert.AreEqual(expected, given.repr);
#endif
            // Multi-dimensional arrays are only shuffled along the first axis:

            // >>> arr = np.arange(9).reshape((3, 3))
            // >>> np.random.shuffle(arr)
            // >>> arr
            // array([[3, 4, 5],
            //        [6, 7, 8],
            //        [0, 1, 2]])
            // 

#if TODO
             given=  arr = np.arange(9).reshape((3, 3));
             given=  np.random.shuffle(arr);
             given=  arr;
             expected=
                "array([[3, 4, 5],\n" +
                "       [6, 7, 8],\n" +
                "       [0, 1, 2]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void permutationTest()
        {
            // >>> np.random.permutation(10)
            // array([1, 7, 4, 3, 0, 9, 2, 5, 8, 6])
            // 

#if TODO
            var given=  np.random.permutation(10);
            var expected=
                "array([1, 7, 4, 3, 0, 9, 2, 5, 8, 6])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> np.random.permutation([1, 4, 9, 12, 15])
            // array([15,  1,  9,  4, 12])
            // 

#if TODO
             given=  np.random.permutation({1, 4, 9, 12, 15});
             expected=
                "array([15,  1,  9,  4, 12])";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> arr = np.arange(9).reshape((3, 3))
            // >>> np.random.permutation(arr)
            // array([[6, 7, 8],
            //        [0, 1, 2],
            //        [3, 4, 5]])
            // 

#if TODO
             given=  arr = np.arange(9).reshape((3, 3));
             given=  np.random.permutation(arr);
             expected=
                "array([[6, 7, 8],\n" +
                "       [0, 1, 2],\n" +
                "       [3, 4, 5]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void binomialTest()
        {
            // Draw samples from the distribution:

            // >>> n, p = 10, .5  # number of trials, probability of each trial
            // >>> s = np.random.binomial(n, p, 1000)
            // # result of flipping a coin 10 times, tested 1000 times.
            // 

#if TODO
            var given=  n, p = 10, .5  # number of trials, probability of each trial;
             given=  s = np.random.binomial(n, p, 1000);
            // result of flipping a coin 10 times, tested 1000 times.
#endif
            // A real world example. A company drills 9 wild-cat oil exploration
            // wells, each with an estimated probability of success of 0.1. All nine
            // wells fail. What is the probability of that happening?

            // Let’s do 20,000 trials of the model, and count the number that
            // generate zero positive results.

            // >>> sum(np.random.binomial(9, 0.1, 20000) == 0)/20000.
            // # answer = 0.38885, or 38%.
            // 

#if TODO
             given=  sum(np.random.binomial(9, 0.1, 20000) == 0)/20000.;
            // answer = 0.38885, or 38%.
#endif
        }


        [TestMethod]
        public void chisquareTest()
        {
            // >>> np.random.chisquare(2,4)
            // array([ 1.89920014,  9.00867716,  3.13710533,  5.62318272])
            // 

#if TODO
            var given=  np.random.chisquare(2,4);
            var expected=
                "array([ 1.89920014,  9.00867716,  3.13710533,  5.62318272])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void dirichletTest()
        {
            // Taking an example cited in Wikipedia, this distribution can be used if
            // one wanted to cut strings (each of initial length 1.0) into K pieces
            // with different lengths, where each piece had, on average, a designated
            // average length, but allowing some variation in the relative sizes of
            // the pieces.

            // >>> s = np.random.dirichlet((10, 5, 3), 20).transpose()
            // 

#if TODO
            var given=  s = np.random.dirichlet((10, 5, 3), 20).transpose();
#endif
            // >>> import matplotlib.pyplot as plt
            // >>> plt.barh(range(20), s[0])
            // >>> plt.barh(range(20), s[1], left=s[0], color='g')
            // >>> plt.barh(range(20), s[2], left=s[0]+s[1], color='r')
            // >>> plt.title("Lengths of Strings")
            // 

#if TODO
             given=  import matplotlib.pyplot as plt;
             given=  plt.barh(range(20), s[0]);
             given=  plt.barh(range(20), s[1], left=s[0], color='g');
             given=  plt.barh(range(20), s[2], left=s[0]+s[1], color='r');
             given=  plt.title("Lengths of Strings");
#endif
        }


        [TestMethod]
        public void fTest()
        {
            // An example from Glantz[1], pp 47-40:

            // Two groups, children of diabetics (25 people) and children from people
            // without diabetes (25 controls). Fasting blood glucose was measured,
            // case group had a mean value of 86.1, controls had a mean value of
            // 82.2. Standard deviations were 2.09 and 2.49 respectively. Are these
            // data consistent with the null hypothesis that the parents diabetic
            // status does not affect their children’s blood glucose levels?
            // Calculating the F statistic from the data gives a value of 36.01.

            // Draw samples from the distribution:

            // >>> dfnum = 1. # between group degrees of freedom
            // >>> dfden = 48. # within groups degrees of freedom
            // >>> s = np.random.f(dfnum, dfden, 1000)
            // 

#if TODO
            var given=  dfnum = 1. # between group degrees of freedom;
             given=  dfden = 48. # within groups degrees of freedom;
             given=  s = np.random.f(dfnum, dfden, 1000);
#endif
            // The lower bound for the top 1% of the samples is :

            // >>> sort(s)[-10]
            // 7.61988120985
            // 

#if TODO
             given=  sort(s)[-10];
            var expected=
                "7.61988120985";
            Assert.AreEqual(expected, given.repr);
#endif
            // So there is about a 1% chance that the F statistic will exceed 7.62,
            // the measured value is 36, so the null hypothesis is rejected at the 1%
            // level.

        }


        [TestMethod]
        public void gammaTest()
        {
            // Draw samples from the distribution:

            // >>> shape, scale = 2., 2.  # mean=4, std=2*sqrt(2)
            // >>> s = np.random.gamma(shape, scale, 1000)
            // 

#if TODO
            var given=  shape, scale = 2., 2.  # mean=4, std=2*sqrt(2);
             given=  s = np.random.gamma(shape, scale, 1000);
#endif
            // Display the histogram of the samples, along with
            // the probability density function:

            // >>> import matplotlib.pyplot as plt
            // >>> import scipy.special as sps
            // >>> count, bins, ignored = plt.hist(s, 50, density=True)
            // >>> y = bins**(shape-1)*(np.exp(-bins/scale) /
            // ...                      (sps.gamma(shape)*scale**shape))
            // >>> plt.plot(bins, y, linewidth=2, color='r')
            // >>> plt.show()
            // 

#if TODO
             given=  import matplotlib.pyplot as plt;
             given=  import scipy.special as sps;
             given=  count, bins, ignored = plt.hist(s, 50, density=True);
             given=  y = bins**(shape-1)*(np.exp(-bins/scale) /;
            var expected=
                "...                      (sps.gamma(shape)*scale**shape))";
            Assert.AreEqual(expected, given.repr);
             given=  plt.plot(bins, y, linewidth=2, color='r');
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void geometricTest()
        {
            // Draw ten thousand values from the geometric distribution,
            // with the probability of an individual success equal to 0.35:

            // >>> z = np.random.geometric(p=0.35, size=10000)
            // 

#if TODO
            var given=  z = np.random.geometric(p=0.35, size=10000);
#endif
            // How many trials succeeded after a single run?

            // >>> (z == 1).sum() / 10000.
            // 0.34889999999999999 #random
            // 

#if TODO
             given=  (z == 1).sum() / 10000.;
            var expected=
                "0.34889999999999999 #random";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void gumbelTest()
        {
            // Draw samples from the distribution:

            // >>> mu, beta = 0, 0.1 # location and scale
            // >>> s = np.random.gumbel(mu, beta, 1000)
            // 

#if TODO
            var given=  mu, beta = 0, 0.1 # location and scale;
             given=  s = np.random.gumbel(mu, beta, 1000);
#endif
            // Display the histogram of the samples, along with
            // the probability density function:

            // >>> import matplotlib.pyplot as plt
            // >>> count, bins, ignored = plt.hist(s, 30, density=True)
            // >>> plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)
            // ...          * np.exp( -np.exp( -(bins - mu) /beta) ),
            // ...          linewidth=2, color='r')
            // >>> plt.show()
            // 

#if TODO
             given=  import matplotlib.pyplot as plt;
             given=  count, bins, ignored = plt.hist(s, 30, density=True);
             given=  plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta);
            var expected=
                "...          * np.exp( -np.exp( -(bins - mu) /beta) ),\n" +
                "...          linewidth=2, color='r')";
            Assert.AreEqual(expected, given.repr);
             given=  plt.show();
#endif
            // Show how an extreme value distribution can arise from a Gaussian process
            // and compare to a Gaussian:

            // >>> means = []
            // >>> maxima = []
            // >>> for i in range(0,1000) :
            // ...    a = np.random.normal(mu, beta, 1000)
            // ...    means.append(a.mean())
            // ...    maxima.append(a.max())
            // >>> count, bins, ignored = plt.hist(maxima, 30, density=True)
            // >>> beta = np.std(maxima) * np.sqrt(6) / np.pi
            // >>> mu = np.mean(maxima) - 0.57721*beta
            // >>> plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)
            // ...          * np.exp(-np.exp(-(bins - mu)/beta)),
            // ...          linewidth=2, color='r')
            // >>> plt.plot(bins, 1/(beta * np.sqrt(2 * np.pi))
            // ...          * np.exp(-(bins - mu)**2 / (2 * beta**2)),
            // ...          linewidth=2, color='g')
            // >>> plt.show()
            // 

#if TODO
             given=  means = [];
             given=  maxima = [];
             given=  for i in range(0,1000) :;
             expected=
                "...    a = np.random.normal(mu, beta, 1000)\n" +
                "...    means.append(a.mean())\n" +
                "...    maxima.append(a.max())";
            Assert.AreEqual(expected, given.repr);
             given=  count, bins, ignored = plt.hist(maxima, 30, density=True);
             given=  beta = np.std(maxima) * np.sqrt(6) / np.pi;
             given=  mu = np.mean(maxima) - 0.57721*beta;
             given=  plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta);
             expected=
                "...          * np.exp(-np.exp(-(bins - mu)/beta)),\n" +
                "...          linewidth=2, color='r')";
            Assert.AreEqual(expected, given.repr);
             given=  plt.plot(bins, 1/(beta * np.sqrt(2 * np.pi));
             expected=
                "...          * np.exp(-(bins - mu)**2 / (2 * beta**2)),\n" +
                "...          linewidth=2, color='g')";
            Assert.AreEqual(expected, given.repr);
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void hypergeometricTest()
        {
            // Draw samples from the distribution:

            // >>> ngood, nbad, nsamp = 100, 2, 10
            // # number of good, number of bad, and number of samples
            // >>> s = np.random.hypergeometric(ngood, nbad, nsamp, 1000)
            // >>> from matplotlib.pyplot import hist
            // >>> hist(s)
            // #   note that it is very unlikely to grab both bad items
            // 

#if TODO
            var given=  ngood, nbad, nsamp = 100, 2, 10;
            // number of good, number of bad, and number of samples
             given=  s = np.random.hypergeometric(ngood, nbad, nsamp, 1000);
             given=  from matplotlib.pyplot import hist;
             given=  hist(s);
            //   note that it is very unlikely to grab both bad items
#endif
            // Suppose you have an urn with 15 white and 15 black marbles.
            // If you pull 15 marbles at random, how likely is it that
            // 12 or more of them are one color?

            // >>> s = np.random.hypergeometric(15, 15, 15, 100000)
            // >>> sum(s>=12)/100000. + sum(s<=3)/100000.
            // #   answer = 0.003 ... pretty unlikely!
            // 

#if TODO
             given=  s = np.random.hypergeometric(15, 15, 15, 100000);
             given=  sum(s>=12)/100000. + sum(s<=3)/100000.;
            //   answer = 0.003 ... pretty unlikely!
#endif
        }


        [TestMethod]
        public void laplaceTest()
        {
            // Draw samples from the distribution

            // >>> loc, scale = 0., 1.
            // >>> s = np.random.laplace(loc, scale, 1000)
            // 

#if TODO
            var given=  loc, scale = 0., 1.;
             given=  s = np.random.laplace(loc, scale, 1000);
#endif
            // Display the histogram of the samples, along with
            // the probability density function:

            // >>> import matplotlib.pyplot as plt
            // >>> count, bins, ignored = plt.hist(s, 30, density=True)
            // >>> x = np.arange(-8., 8., .01)
            // >>> pdf = np.exp(-abs(x-loc)/scale)/(2.*scale)
            // >>> plt.plot(x, pdf)
            // 

#if TODO
             given=  import matplotlib.pyplot as plt;
             given=  count, bins, ignored = plt.hist(s, 30, density=True);
             given=  x = np.arange(-8., 8., .01);
             given=  pdf = np.exp(-abs(x-loc)/scale)/(2.*scale);
             given=  plt.plot(x, pdf);
#endif
            // Plot Gaussian for comparison:

            // >>> g = (1/(scale * np.sqrt(2 * np.pi)) *
            // ...      np.exp(-(x - loc)**2 / (2 * scale**2)))
            // >>> plt.plot(x,g)
            // 

#if TODO
             given=  g = (1/(scale * np.sqrt(2 * np.pi)) *;
            var expected=
                "...      np.exp(-(x - loc)**2 / (2 * scale**2)))";
            Assert.AreEqual(expected, given.repr);
             given=  plt.plot(x,g);
#endif
        }


        [TestMethod]
        public void logisticTest()
        {
            // Draw samples from the distribution:

            // >>> loc, scale = 10, 1
            // >>> s = np.random.logistic(loc, scale, 10000)
            // >>> import matplotlib.pyplot as plt
            // >>> count, bins, ignored = plt.hist(s, bins=50)
            // 

#if TODO
            var given=  loc, scale = 10, 1;
             given=  s = np.random.logistic(loc, scale, 10000);
             given=  import matplotlib.pyplot as plt;
             given=  count, bins, ignored = plt.hist(s, bins=50);
#endif
            // #   plot against distribution

            // >>> def logist(x, loc, scale):
            // ...     return exp((loc-x)/scale)/(scale*(1+exp((loc-x)/scale))**2)
            // >>> plt.plot(bins, logist(bins, loc, scale)*count.max()/\
            // ... logist(bins, loc, scale).max())
            // >>> plt.show()
            // 

#if TODO
             given=  def logist(x, loc, scale):;
            var expected=
                "...     return exp((loc-x)/scale)/(scale*(1+exp((loc-x)/scale))**2)";
            Assert.AreEqual(expected, given.repr);
             given=  plt.plot(bins, logist(bins, loc, scale)*count.max()/\;
             expected=
                "... logist(bins, loc, scale).max())";
            Assert.AreEqual(expected, given.repr);
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void lognormalTest()
        {
            // Draw samples from the distribution:

            // >>> mu, sigma = 3., 1. # mean and standard deviation
            // >>> s = np.random.lognormal(mu, sigma, 1000)
            // 

#if TODO
            var given=  mu, sigma = 3., 1. # mean and standard deviation;
             given=  s = np.random.lognormal(mu, sigma, 1000);
#endif
            // Display the histogram of the samples, along with
            // the probability density function:

            // >>> import matplotlib.pyplot as plt
            // >>> count, bins, ignored = plt.hist(s, 100, density=True, align='mid')
            // 

#if TODO
             given=  import matplotlib.pyplot as plt;
             given=  count, bins, ignored = plt.hist(s, 100, density=True, align='mid');
#endif
            // >>> x = np.linspace(min(bins), max(bins), 10000)
            // >>> pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))
            // ...        / (x * sigma * np.sqrt(2 * np.pi)))
            // 

#if TODO
             given=  x = np.linspace(min(bins), max(bins), 10000);
             given=  pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2));
            var expected=
                "...        / (x * sigma * np.sqrt(2 * np.pi)))";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> plt.plot(x, pdf, linewidth=2, color='r')
            // >>> plt.axis('tight')
            // >>> plt.show()
            // 

#if TODO
             given=  plt.plot(x, pdf, linewidth=2, color='r');
             given=  plt.axis('tight');
             given=  plt.show();
#endif
            // Demonstrate that taking the products of random samples from a uniform
            // distribution can be fit well by a log-normal probability density
            // function.

            // >>> # Generate a thousand samples: each is the product of 100 random
            // >>> # values, drawn from a normal distribution.
            // >>> b = []
            // >>> for i in range(1000):
            // ...    a = 10. + np.random.random(100)
            // ...    b.append(np.product(a))
            // 

#if TODO
             given=  # Generate a thousand samples: each is the product of 100 random;
             given=  # values, drawn from a normal distribution.;
             given=  b = [];
             given=  for i in range(1000):;
             expected=
                "...    a = 10. + np.random.random(100)\n" +
                "...    b.append(np.product(a))";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> b = np.array(b) / np.min(b) # scale values to be positive
            // >>> count, bins, ignored = plt.hist(b, 100, density=True, align='mid')
            // >>> sigma = np.std(np.log(b))
            // >>> mu = np.mean(np.log(b))
            // 

#if TODO
             given=  b = np.array(b) / np.min(b) # scale values to be positive;
             given=  count, bins, ignored = plt.hist(b, 100, density=True, align='mid');
             given=  sigma = np.std(np.log(b));
             given=  mu = np.mean(np.log(b));
#endif
            // >>> x = np.linspace(min(bins), max(bins), 10000)
            // >>> pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))
            // ...        / (x * sigma * np.sqrt(2 * np.pi)))
            // 

#if TODO
             given=  x = np.linspace(min(bins), max(bins), 10000);
             given=  pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2));
             expected=
                "...        / (x * sigma * np.sqrt(2 * np.pi)))";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> plt.plot(x, pdf, color='r', linewidth=2)
            // >>> plt.show()
            // 

#if TODO
             given=  plt.plot(x, pdf, color='r', linewidth=2);
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void logseriesTest()
        {
            // Draw samples from the distribution:

            // >>> a = .6
            // >>> s = np.random.logseries(a, 10000)
            // >>> import matplotlib.pyplot as plt
            // >>> count, bins, ignored = plt.hist(s)
            // 

#if TODO
            var given=  a = .6;
             given=  s = np.random.logseries(a, 10000);
             given=  import matplotlib.pyplot as plt;
             given=  count, bins, ignored = plt.hist(s);
#endif
            // #   plot against distribution

            // >>> def logseries(k, p):
            // ...     return -p**k/(k*log(1-p))
            // >>> plt.plot(bins, logseries(bins, a)*count.max()/
            //              logseries(bins, a).max(), 'r')
            // >>> plt.show()
            // 

#if TODO
             given=  def logseries(k, p):;
            var expected=
                "...     return -p**k/(k*log(1-p))";
            Assert.AreEqual(expected, given.repr);
             given=  plt.plot(bins, logseries(bins, a)*count.max()/;
             expected=
                "             logseries(bins, a).max(), 'r')";
            Assert.AreEqual(expected, given.repr);
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void multinomialTest()
        {
            // Throw a dice 20 times:

            // >>> np.random.multinomial(20, [1/6.]*6, size=1)
            // array([[4, 1, 7, 5, 2, 1]])
            // 

#if TODO
            var given=  np.random.multinomial(20, {1/6.}*6, size=1);
            var expected=
                "array([[4, 1, 7, 5, 2, 1]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // It landed 4 times on 1, once on 2, etc.

            // Now, throw the dice 20 times, and 20 times again:

            // >>> np.random.multinomial(20, [1/6.]*6, size=2)
            // array([[3, 4, 3, 3, 4, 3],
            //        [2, 4, 3, 4, 0, 7]])
            // 

#if TODO
             given=  np.random.multinomial(20, {1/6.}*6, size=2);
             expected=
                "array([[3, 4, 3, 3, 4, 3],\n" +
                "       [2, 4, 3, 4, 0, 7]])";
            Assert.AreEqual(expected, given.repr);
#endif
            // For the first run, we threw 3 times 1, 4 times 2, etc.  For the second,
            // we threw 2 times 1, 4 times 2, etc.

            // A loaded die is more likely to land on number 6:

            // >>> np.random.multinomial(100, [1/7.]*5 + [2/7.])
            // array([11, 16, 14, 17, 16, 26])
            // 

#if TODO
             given=  np.random.multinomial(100, {1/7.}*5 + {2/7.});
             expected=
                "array([11, 16, 14, 17, 16, 26])";
            Assert.AreEqual(expected, given.repr);
#endif
            // The probability inputs should be normalized. As an implementation
            // detail, the value of the last entry is ignored and assumed to take
            // up any leftover probability mass, but this should not be relied on.
            // A biased coin which has twice as much weight on one side as on the
            // other should be sampled like so:

            // >>> np.random.multinomial(100, [1.0 / 3, 2.0 / 3])  # RIGHT
            // array([38, 62])
            // 

#if TODO
             given=  np.random.multinomial(100, {1.0 / 3, 2.0 / 3})  # RIGHT;
             expected=
                "array([38, 62])";
            Assert.AreEqual(expected, given.repr);
#endif
            // not like:

            // >>> np.random.multinomial(100, [1.0, 2.0])  # WRONG
            // array([100,   0])
            // 

#if TODO
             given=  np.random.multinomial(100, {1.0, 2.0})  # WRONG;
             expected=
                "array([100,   0])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void multivariate_normalTest()
        {
            // >>> mean = (1, 2)
            // >>> cov = [[1, 0], [0, 1]]
            // >>> x = np.random.multivariate_normal(mean, cov, (3, 3))
            // >>> x.shape
            // (3, 3, 2)
            // 

#if TODO
            var given=  mean = (1, 2);
             given=  cov = [[1, 0], [0, 1]];
             given=  x = np.random.multivariate_normal(mean, cov, (3, 3));
             given=  x.shape;
            var expected=
                "(3, 3, 2)";
            Assert.AreEqual(expected, given.repr);
#endif
            // The following is probably true, given that 0.6 is roughly twice the
            // standard deviation:

            // >>> list((x[0,0,:] - mean) < 0.6)
            // [True, True]
            // 

#if TODO
             given=  list((x[0,0,:] - mean) < 0.6);
             expected=
                "[True, True]";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void negative_binomialTest()
        {
            // Draw samples from the distribution:

            // A real world example. A company drills wild-cat oil
            // exploration wells, each with an estimated probability of
            // success of 0.1.  What is the probability of having one success
            // for each successive well, that is what is the probability of a
            // single success after drilling 5 wells, after 6 wells, etc.?

            // >>> s = np.random.negative_binomial(1, 0.1, 100000)
            // >>> for i in range(1, 11):
            // ...    probability = sum(s<i) / 100000.
            // ...    print i, "wells drilled, probability of one success =", probability
            // 

#if TODO
            var given=  s = np.random.negative_binomial(1, 0.1, 100000);
             given=  for i in range(1, 11):;
            var expected=
                "...    probability = sum(s<i) / 100000.\n" +
                "...    print i, "wells drilled, probability of one success =", probability";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void noncentral_chisquareTest()
        {
            // Draw values from the distribution and plot the histogram

            // >>> import matplotlib.pyplot as plt
            // >>> values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),
            // ...                   bins=200, density=True)
            // >>> plt.show()
            // 

#if TODO
            var given=  import matplotlib.pyplot as plt;
             given=  values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),;
            var expected=
                "...                   bins=200, density=True)";
            Assert.AreEqual(expected, given.repr);
             given=  plt.show();
#endif
            // Draw values from a noncentral chisquare with very small noncentrality,
            // and compare to a chisquare.

            // >>> plt.figure()
            // >>> values = plt.hist(np.random.noncentral_chisquare(3, .0000001, 100000),
            // ...                   bins=np.arange(0., 25, .1), density=True)
            // >>> values2 = plt.hist(np.random.chisquare(3, 100000),
            // ...                    bins=np.arange(0., 25, .1), density=True)
            // >>> plt.plot(values[1][0:-1], values[0]-values2[0], 'ob')
            // >>> plt.show()
            // 

#if TODO
             given=  plt.figure();
             given=  values = plt.hist(np.random.noncentral_chisquare(3, .0000001, 100000),;
             expected=
                "...                   bins=np.arange(0., 25, .1), density=True)";
            Assert.AreEqual(expected, given.repr);
             given=  values2 = plt.hist(np.random.chisquare(3, 100000),;
             expected=
                "...                    bins=np.arange(0., 25, .1), density=True)";
            Assert.AreEqual(expected, given.repr);
             given=  plt.plot(values[1][0:-1], values[0]-values2[0], 'ob');
             given=  plt.show();
#endif
            // Demonstrate how large values of non-centrality lead to a more symmetric
            // distribution.

            // >>> plt.figure()
            // >>> values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),
            // ...                   bins=200, density=True)
            // >>> plt.show()
            // 

#if TODO
             given=  plt.figure();
             given=  values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),;
             expected=
                "...                   bins=200, density=True)";
            Assert.AreEqual(expected, given.repr);
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void noncentral_fTest()
        {
            // In a study, testing for a specific alternative to the null hypothesis
            // requires use of the Noncentral F distribution. We need to calculate the
            // area in the tail of the distribution that exceeds the value of the F
            // distribution for the null hypothesis.  We’ll plot the two probability
            // distributions for comparison.

            // >>> dfnum = 3 # between group deg of freedom
            // >>> dfden = 20 # within groups degrees of freedom
            // >>> nonc = 3.0
            // >>> nc_vals = np.random.noncentral_f(dfnum, dfden, nonc, 1000000)
            // >>> NF = np.histogram(nc_vals, bins=50, density=True)
            // >>> c_vals = np.random.f(dfnum, dfden, 1000000)
            // >>> F = np.histogram(c_vals, bins=50, density=True)
            // >>> import matplotlib.pyplot as plt
            // >>> plt.plot(F[1][1:], F[0])
            // >>> plt.plot(NF[1][1:], NF[0])
            // >>> plt.show()
            // 

#if TODO
            var given=  dfnum = 3 # between group deg of freedom;
             given=  dfden = 20 # within groups degrees of freedom;
             given=  nonc = 3.0;
             given=  nc_vals = np.random.noncentral_f(dfnum, dfden, nonc, 1000000);
             given=  NF = np.histogram(nc_vals, bins=50, density=True);
             given=  c_vals = np.random.f(dfnum, dfden, 1000000);
             given=  F = np.histogram(c_vals, bins=50, density=True);
             given=  import matplotlib.pyplot as plt;
             given=  plt.plot(F[1][1:], F[0]);
             given=  plt.plot(NF[1][1:], NF[0]);
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void normalTest()
        {
            // Draw samples from the distribution:

            // >>> mu, sigma = 0, 0.1 # mean and standard deviation
            // >>> s = np.random.normal(mu, sigma, 1000)
            // 

#if TODO
            var given=  mu, sigma = 0, 0.1 # mean and standard deviation;
             given=  s = np.random.normal(mu, sigma, 1000);
#endif
            // Verify the mean and the variance:

            // >>> abs(mu - np.mean(s)) < 0.01
            // True
            // 

#if TODO
             given=  abs(mu - np.mean(s)) < 0.01;
            var expected=
                "True";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> abs(sigma - np.std(s, ddof=1)) < 0.01
            // True
            // 

#if TODO
             given=  abs(sigma - np.std(s, ddof=1)) < 0.01;
             expected=
                "True";
            Assert.AreEqual(expected, given.repr);
#endif
            // Display the histogram of the samples, along with
            // the probability density function:

            // >>> import matplotlib.pyplot as plt
            // >>> count, bins, ignored = plt.hist(s, 30, density=True)
            // >>> plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *
            // ...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),
            // ...          linewidth=2, color='r')
            // >>> plt.show()
            // 

#if TODO
             given=  import matplotlib.pyplot as plt;
             given=  count, bins, ignored = plt.hist(s, 30, density=True);
             given=  plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *;
             expected=
                "...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),\n" +
                "...          linewidth=2, color='r')";
            Assert.AreEqual(expected, given.repr);
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void paretoTest()
        {
            // Draw samples from the distribution:

            // >>> a, m = 3., 2.  # shape and mode
            // >>> s = (np.random.pareto(a, 1000) + 1) * m
            // 

#if TODO
            var given=  a, m = 3., 2.  # shape and mode;
             given=  s = (np.random.pareto(a, 1000) + 1) * m;
#endif
            // Display the histogram of the samples, along with the probability
            // density function:

            // >>> import matplotlib.pyplot as plt
            // >>> count, bins, _ = plt.hist(s, 100, density=True)
            // >>> fit = a*m**a / bins**(a+1)
            // >>> plt.plot(bins, max(count)*fit/max(fit), linewidth=2, color='r')
            // >>> plt.show()
            // 

#if TODO
             given=  import matplotlib.pyplot as plt;
             given=  count, bins, _ = plt.hist(s, 100, density=True);
             given=  fit = a*m**a / bins**(a+1);
             given=  plt.plot(bins, max(count)*fit/max(fit), linewidth=2, color='r');
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void poissonTest()
        {
            // Draw samples from the distribution:

            // >>> import numpy as np
            // >>> s = np.random.poisson(5, 10000)
            // 

#if TODO
            var given=  import numpy as np;
             given=  s = np.random.poisson(5, 10000);
#endif
            // Display histogram of the sample:

            // >>> import matplotlib.pyplot as plt
            // >>> count, bins, ignored = plt.hist(s, 14, density=True)
            // >>> plt.show()
            // 

#if TODO
             given=  import matplotlib.pyplot as plt;
             given=  count, bins, ignored = plt.hist(s, 14, density=True);
             given=  plt.show();
#endif
            // Draw each 100 values for lambda 100 and 500:

            // >>> s = np.random.poisson(lam=(100., 500.), size=(100, 2))
            // 

#if TODO
             given=  s = np.random.poisson(lam=(100., 500.), size=(100, 2));
#endif
        }


        [TestMethod]
        public void rayleighTest()
        {
            // Draw values from the distribution and plot the histogram

            // >>> from matplotlib.pyplot import hist
            // >>> values = hist(np.random.rayleigh(3, 100000), bins=200, density=True)
            // 

#if TODO
            var given=  from matplotlib.pyplot import hist;
             given=  values = hist(np.random.rayleigh(3, 100000), bins=200, density=True);
#endif
            // Wave heights tend to follow a Rayleigh distribution. If the mean wave
            // height is 1 meter, what fraction of waves are likely to be larger than 3
            // meters?

            // >>> meanvalue = 1
            // >>> modevalue = np.sqrt(2 / np.pi) * meanvalue
            // >>> s = np.random.rayleigh(modevalue, 1000000)
            // 

#if TODO
             given=  meanvalue = 1;
             given=  modevalue = np.sqrt(2 / np.pi) * meanvalue;
             given=  s = np.random.rayleigh(modevalue, 1000000);
#endif
            // The percentage of waves larger than 3 meters is:

            // >>> 100.*sum(s>3)/1000000.
            // 0.087300000000000003
            // 

#if TODO
             given=  100.*sum(s>3)/1000000.;
            var expected=
                "0.087300000000000003";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void standard_cauchyTest()
        {
            // Draw samples and plot the distribution:

            // >>> import matplotlib.pyplot as plt
            // >>> s = np.random.standard_cauchy(1000000)
            // >>> s = s[(s>-25) & (s<25)]  # truncate distribution so it plots well
            // >>> plt.hist(s, bins=100)
            // >>> plt.show()
            // 

#if TODO
            var given=  import matplotlib.pyplot as plt;
             given=  s = np.random.standard_cauchy(1000000);
             given=  s = s[(s>-25) & (s<25)]  # truncate distribution so it plots well;
             given=  plt.hist(s, bins=100);
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void standard_exponentialTest()
        {
            // Output a 3x8000 array:

            // >>> n = np.random.standard_exponential((3, 8000))
            // 

#if TODO
            var given=  n = np.random.standard_exponential((3, 8000));
#endif
        }


        [TestMethod]
        public void standard_gammaTest()
        {
            // Draw samples from the distribution:

            // >>> shape, scale = 2., 1. # mean and width
            // >>> s = np.random.standard_gamma(shape, 1000000)
            // 

#if TODO
            var given=  shape, scale = 2., 1. # mean and width;
             given=  s = np.random.standard_gamma(shape, 1000000);
#endif
            // Display the histogram of the samples, along with
            // the probability density function:

            // >>> import matplotlib.pyplot as plt
            // >>> import scipy.special as sps
            // >>> count, bins, ignored = plt.hist(s, 50, density=True)
            // >>> y = bins**(shape-1) * ((np.exp(-bins/scale))/ \
            // ...                       (sps.gamma(shape) * scale**shape))
            // >>> plt.plot(bins, y, linewidth=2, color='r')
            // >>> plt.show()
            // 

#if TODO
             given=  import matplotlib.pyplot as plt;
             given=  import scipy.special as sps;
             given=  count, bins, ignored = plt.hist(s, 50, density=True);
             given=  y = bins**(shape-1) * ((np.exp(-bins/scale))/ \;
            var expected=
                "...                       (sps.gamma(shape) * scale**shape))";
            Assert.AreEqual(expected, given.repr);
             given=  plt.plot(bins, y, linewidth=2, color='r');
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void standard_normalTest()
        {
            // >>> s = np.random.standard_normal(8000)
            // >>> s
            // array([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311, #random
            //        -0.38672696, -0.4685006 ])                               #random
            // >>> s.shape
            // (8000,)
            // >>> s = np.random.standard_normal(size=(3, 4, 2))
            // >>> s.shape
            // (3, 4, 2)
            // 

#if TODO
            var given=  s = np.random.standard_normal(8000);
             given=  s;
            var expected=
                "array([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311, #random\n" +
                "       -0.38672696, -0.4685006 ])                               #random";
            Assert.AreEqual(expected, given.repr);
             given=  s.shape;
             expected=
                "(8000,)";
            Assert.AreEqual(expected, given.repr);
             given=  s = np.random.standard_normal(size=(3, 4, 2));
             given=  s.shape;
             expected=
                "(3, 4, 2)";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void standard_tTest()
        {
            // From Dalgaard page 83 [1], suppose the daily energy intake for 11
            // women in kilojoules (kJ) is:

            // >>> intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \
            // ...                    7515, 8230, 8770])
            // 

#if TODO
            var given=  intake = np.array({5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \;
            var expected=
                "...                    7515, 8230, 8770])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Does their energy intake deviate systematically from the recommended
            // value of 7725 kJ?

            // We have 10 degrees of freedom, so is the sample mean within 95% of the
            // recommended value?

            // >>> s = np.random.standard_t(10, size=100000)
            // >>> np.mean(intake)
            // 6753.636363636364
            // >>> intake.std(ddof=1)
            // 1142.1232221373727
            // 

#if TODO
             given=  s = np.random.standard_t(10, size=100000);
             given=  np.mean(intake);
             expected=
                "6753.636363636364";
            Assert.AreEqual(expected, given.repr);
             given=  intake.std(ddof=1);
             expected=
                "1142.1232221373727";
            Assert.AreEqual(expected, given.repr);
#endif
            // Calculate the t statistic, setting the ddof parameter to the unbiased
            // value so the divisor in the standard deviation will be degrees of
            // freedom, N-1.

            // >>> t = (np.mean(intake)-7725)/(intake.std(ddof=1)/np.sqrt(len(intake)))
            // >>> import matplotlib.pyplot as plt
            // >>> h = plt.hist(s, bins=100, density=True)
            // 

#if TODO
             given=  t = (np.mean(intake)-7725)/(intake.std(ddof=1)/np.sqrt(len(intake)));
             given=  import matplotlib.pyplot as plt;
             given=  h = plt.hist(s, bins=100, density=True);
#endif
            // For a one-sided t-test, how far out in the distribution does the t
            // statistic appear?

            // >>> np.sum(s<t) / float(len(s))
            // 0.0090699999999999999  #random
            // 

#if TODO
             given=  np.sum(s<t) / float(len(s));
             expected=
                "0.0090699999999999999  #random";
            Assert.AreEqual(expected, given.repr);
#endif
            // So the p-value is about 0.009, which says the null hypothesis has a
            // probability of about 99% of being true.

        }


        [TestMethod]
        public void triangularTest()
        {
            // Draw values from the distribution and plot the histogram:

            // >>> import matplotlib.pyplot as plt
            // >>> h = plt.hist(np.random.triangular(-3, 0, 8, 100000), bins=200,
            // ...              density=True)
            // >>> plt.show()
            // 

#if TODO
            var given=  import matplotlib.pyplot as plt;
             given=  h = plt.hist(np.random.triangular(-3, 0, 8, 100000), bins=200,;
            var expected=
                "...              density=True)";
            Assert.AreEqual(expected, given.repr);
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void uniformTest()
        {
            // Draw samples from the distribution:

            // >>> s = np.random.uniform(-1,0,1000)
            // 

#if TODO
            var given=  s = np.random.uniform(-1,0,1000);
#endif
            // All values are within the given interval:

            // >>> np.all(s >= -1)
            // True
            // >>> np.all(s < 0)
            // True
            // 

#if TODO
             given=  np.all(s >= -1);
            var expected=
                "True";
            Assert.AreEqual(expected, given.repr);
             given=  np.all(s < 0);
             expected=
                "True";
            Assert.AreEqual(expected, given.repr);
#endif
            // Display the histogram of the samples, along with the
            // probability density function:

            // >>> import matplotlib.pyplot as plt
            // >>> count, bins, ignored = plt.hist(s, 15, density=True)
            // >>> plt.plot(bins, np.ones_like(bins), linewidth=2, color='r')
            // >>> plt.show()
            // 

#if TODO
             given=  import matplotlib.pyplot as plt;
             given=  count, bins, ignored = plt.hist(s, 15, density=True);
             given=  plt.plot(bins, np.ones_like(bins), linewidth=2, color='r');
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void vonmisesTest()
        {
            // Draw samples from the distribution:

            // >>> mu, kappa = 0.0, 4.0 # mean and dispersion
            // >>> s = np.random.vonmises(mu, kappa, 1000)
            // 

#if TODO
            var given=  mu, kappa = 0.0, 4.0 # mean and dispersion;
             given=  s = np.random.vonmises(mu, kappa, 1000);
#endif
            // Display the histogram of the samples, along with
            // the probability density function:

            // >>> import matplotlib.pyplot as plt
            // >>> from scipy.special import i0
            // >>> plt.hist(s, 50, density=True)
            // >>> x = np.linspace(-np.pi, np.pi, num=51)
            // >>> y = np.exp(kappa*np.cos(x-mu))/(2*np.pi*i0(kappa))
            // >>> plt.plot(x, y, linewidth=2, color='r')
            // >>> plt.show()
            // 

#if TODO
             given=  import matplotlib.pyplot as plt;
             given=  from scipy.special import i0;
             given=  plt.hist(s, 50, density=True);
             given=  x = np.linspace(-np.pi, np.pi, num=51);
             given=  y = np.exp(kappa*np.cos(x-mu))/(2*np.pi*i0(kappa));
             given=  plt.plot(x, y, linewidth=2, color='r');
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void waldTest()
        {
            // Draw values from the distribution and plot the histogram:

            // >>> import matplotlib.pyplot as plt
            // >>> h = plt.hist(np.random.wald(3, 2, 100000), bins=200, density=True)
            // >>> plt.show()
            // 

#if TODO
            var given=  import matplotlib.pyplot as plt;
             given=  h = plt.hist(np.random.wald(3, 2, 100000), bins=200, density=True);
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void weibullTest()
        {
            // Draw samples from the distribution:

            // >>> a = 5. # shape
            // >>> s = np.random.weibull(a, 1000)
            // 

#if TODO
            var given=  a = 5. # shape;
             given=  s = np.random.weibull(a, 1000);
#endif
            // Display the histogram of the samples, along with
            // the probability density function:

            // >>> import matplotlib.pyplot as plt
            // >>> x = np.arange(1,100.)/50.
            // >>> def weib(x,n,a):
            // ...     return (a / n) * (x / n)**(a - 1) * np.exp(-(x / n)**a)
            // 

#if TODO
             given=  import matplotlib.pyplot as plt;
             given=  x = np.arange(1,100.)/50.;
             given=  def weib(x,n,a):;
            var expected=
                "...     return (a / n) * (x / n)**(a - 1) * np.exp(-(x / n)**a)";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> count, bins, ignored = plt.hist(np.random.weibull(5.,1000))
            // >>> x = np.arange(1,100.)/50.
            // >>> scale = count.max()/weib(x, 1., 5.).max()
            // >>> plt.plot(x, weib(x, 1., 5.)*scale)
            // >>> plt.show()
            // 

#if TODO
             given=  count, bins, ignored = plt.hist(np.random.weibull(5.,1000));
             given=  x = np.arange(1,100.)/50.;
             given=  scale = count.max()/weib(x, 1., 5.).max();
             given=  plt.plot(x, weib(x, 1., 5.)*scale);
             given=  plt.show();
#endif
        }


        [TestMethod]
        public void zipfTest()
        {
            // Draw samples from the distribution:

            // >>> a = 2. # parameter
            // >>> s = np.random.zipf(a, 1000)
            // 

#if TODO
            var given=  a = 2. # parameter;
             given=  s = np.random.zipf(a, 1000);
#endif
            // Display the histogram of the samples, along with
            // the probability density function:

            // >>> import matplotlib.pyplot as plt
            // >>> from scipy import special
            // 

#if TODO
             given=  import matplotlib.pyplot as plt;
             given=  from scipy import special;
#endif
            // Truncate s values at 50 so plot is interesting:

            // >>> count, bins, ignored = plt.hist(s[s<50], 50, density=True)
            // >>> x = np.arange(1., 50.)
            // >>> y = x**(-a) / special.zetac(a)
            // >>> plt.plot(x, y/max(y), linewidth=2, color='r')
            // >>> plt.show()
            // 

#if TODO
             given=  count, bins, ignored = plt.hist(s[s<50], 50, density=True);
             given=  x = np.arange(1., 50.);
             given=  y = x**(-a) / special.zetac(a);
             given=  plt.plot(x, y/max(y), linewidth=2, color='r');
             given=  plt.show();
#endif
        }

    }
}
