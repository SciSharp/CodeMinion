// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Numpy.Models;

using Microsoft.VisualStudio.TestTools.UnitTesting;
using Assert = NUnit.Framework.Assert;

namespace Numpy.UnitTest
{
    [TestClass]
    public class NumPy_staticsticsTest : BaseTestCase
    {

        [TestMethod]
        public void aminTest()
        {
            // >>> a = np.arange(4).reshape((2,2))
            // >>> a
            // array([[0, 1],
            //        [2, 3]])
            // >>> np.amin(a)           # Minimum of the flattened array
            // 0
            // >>> np.amin(a, axis=0)   # Minima along the first axis
            // array([0, 1])
            // >>> np.amin(a, axis=1)   # Minima along the second axis
            // array([0, 2])
            // 

            var a = np.arange(4).reshape(2, 2);
            var given = a;
            var expected =
                "array([[0, 1],\n" +
                "       [2, 3]])";
            Assert.AreEqual(expected, given.repr);
            given = np.amin(a);           // Minimum of the flattened array;
            expected =
               "0";
            Assert.AreEqual(expected, given.repr);
            given = np.amin(a, axis: new int[] { 0 });   // Minima along the first axis;
            expected =
               "array([0, 1])";
            Assert.AreEqual(expected, given.repr);
            given = np.amin(a, axis: new int[] { 1 });   // Minima along the second axis;
            expected =
               "array([0, 2])";
            Assert.AreEqual(expected, given.repr);

            // >>> b = np.arange(5, dtype=float)
            // >>> b[2] = np.NaN
            // >>> np.amin(b)
            // nan
            // >>> np.nanmin(b)
            // 0.0
            // 

#if TODO
             given=  b = np.arange(5, dtype=float);
             given=  b{2} = np.NaN;
             given=  np.amin(b);
             expected=
                "nan";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanmin(b);
             expected=
                "0.0";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> np.min([[-50], [10]], axis=-1, initial=0)
            // array([-50,   0])
            // 

#if TODO
             given=  np.min({{-50}, {10}}, axis=-1, initial=0);
             expected=
                "array([-50,   0])";
            Assert.AreEqual(expected, given.repr);
#endif
            // Notice that the initial value is used as one of the elements for which the
            // minimum is determined, unlike for the default argument Pythonâ€™s max
            // function, which is only used for empty iterables.

            // Notice that this isnâ€™t the same as Pythonâ€™s default argument.

            // >>> np.min([6], initial=5)
            // 5
            // >>> min([6], default=5)
            // 6
            // 

#if TODO
             given=  np.min({6}, initial=5);
             expected=
                "5";
            Assert.AreEqual(expected, given.repr);
             given=  min([6], default=5);
             expected=
                "6";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void amaxTest()
        {
            // >>> a = np.arange(4).reshape((2,2))
            // >>> a
            // array([[0, 1],
            //        [2, 3]])
            // >>> np.amax(a)           # Maximum of the flattened array
            // 3
            // >>> np.amax(a, axis=0)   # Maxima along the first axis
            // array([2, 3])
            // >>> np.amax(a, axis=1)   # Maxima along the second axis
            // array([1, 3])
            // 
            
            #if TODO
            var given=  a = np.arange(4).reshape((2,2));
             given=  a;
            var expected=
                "array([[0, 1],\n" +
                "       [2, 3]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.amax(a)           # Maximum of the flattened array;
             expected=
                "3";
            Assert.AreEqual(expected, given.repr);
             given=  np.amax(a, axis=0)   # Maxima along the first axis;
             expected=
                "array([2, 3])";
            Assert.AreEqual(expected, given.repr);
             given=  np.amax(a, axis=1)   # Maxima along the second axis;
             expected=
                "array([1, 3])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> b = np.arange(5, dtype=float)
            // >>> b[2] = np.NaN
            // >>> np.amax(b)
            // nan
            // >>> np.nanmax(b)
            // 4.0
            // 
            
            #if TODO
             given=  b = np.arange(5, dtype=float);
             given=  b{2} = np.NaN;
             given=  np.amax(b);
             expected=
                "nan";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanmax(b);
             expected=
                "4.0";
            Assert.AreEqual(expected, given.repr);
            #endif
            // You can use an initial value to compute the maximum of an empty slice, or
            // to initialize it to a different value:
            
            // >>> np.max([[-50], [10]], axis=-1, initial=0)
            // array([ 0, 10])
            // 
            
            #if TODO
             given=  np.max({{-50}, {10}}, axis=-1, initial=0);
             expected=
                "array([ 0, 10])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Notice that the initial value is used as one of the elements for which the
            // maximum is determined, unlike for the default argument Pythonâ€™s max
            // function, which is only used for empty iterables.
            
            // >>> np.max([5], initial=6)
            // 6
            // >>> max([5], default=6)
            // 5
            // 
            
            #if TODO
             given=  np.max({5}, initial=6);
             expected=
                "6";
            Assert.AreEqual(expected, given.repr);
             given=  max([5], default=6);
             expected=
                "5";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void nanminTest()
        {
            // >>> a = np.array([[1, 2], [3, np.nan]])
            // >>> np.nanmin(a)
            // 1.0
            // >>> np.nanmin(a, axis=0)
            // array([ 1.,  2.])
            // >>> np.nanmin(a, axis=1)
            // array([ 1.,  3.])
            // 
            
            #if TODO
            var given=  a = np.array({{1, 2}, {3, np.nan}});
             given=  np.nanmin(a);
            var expected=
                "1.0";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanmin(a, axis=0);
             expected=
                "array([ 1.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanmin(a, axis=1);
             expected=
                "array([ 1.,  3.])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // When positive infinity and negative infinity are present:
            
            // >>> np.nanmin([1, 2, np.nan, np.inf])
            // 1.0
            // >>> np.nanmin([1, 2, np.nan, np.NINF])
            // -inf
            // 
            
            #if TODO
             given=  np.nanmin({1, 2, np.nan, np.inf});
             expected=
                "1.0";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanmin({1, 2, np.nan, np.NINF});
             expected=
                "-inf";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void nanmaxTest()
        {
            // >>> a = np.array([[1, 2], [3, np.nan]])
            // >>> np.nanmax(a)
            // 3.0
            // >>> np.nanmax(a, axis=0)
            // array([ 3.,  2.])
            // >>> np.nanmax(a, axis=1)
            // array([ 2.,  3.])
            // 
            
            #if TODO
            var given=  a = np.array({{1, 2}, {3, np.nan}});
             given=  np.nanmax(a);
            var expected=
                "3.0";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanmax(a, axis=0);
             expected=
                "array([ 3.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanmax(a, axis=1);
             expected=
                "array([ 2.,  3.])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // When positive infinity and negative infinity are present:
            
            // >>> np.nanmax([1, 2, np.nan, np.NINF])
            // 2.0
            // >>> np.nanmax([1, 2, np.nan, np.inf])
            // inf
            // 
            
            #if TODO
             given=  np.nanmax({1, 2, np.nan, np.NINF});
             expected=
                "2.0";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanmax({1, 2, np.nan, np.inf});
             expected=
                "inf";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void ptpTest()
        {
            // >>> x = np.arange(4).reshape((2,2))
            // >>> x
            // array([[0, 1],
            //        [2, 3]])
            // 
            
            #if TODO
            var given=  x = np.arange(4).reshape((2,2));
             given=  x;
            var expected=
                "array([[0, 1],\n" +
                "       [2, 3]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.ptp(x, axis=0)
            // array([2, 2])
            // 
            
            #if TODO
             given=  np.ptp(x, axis=0);
             expected=
                "array([2, 2])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.ptp(x, axis=1)
            // array([1, 1])
            // 
            
            #if TODO
             given=  np.ptp(x, axis=1);
             expected=
                "array([1, 1])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void percentileTest()
        {
            // >>> a = np.array([[10, 7, 4], [3, 2, 1]])
            // >>> a
            // array([[10,  7,  4],
            //        [ 3,  2,  1]])
            // >>> np.percentile(a, 50)
            // 3.5
            // >>> np.percentile(a, 50, axis=0)
            // array([[ 6.5,  4.5,  2.5]])
            // >>> np.percentile(a, 50, axis=1)
            // array([ 7.,  2.])
            // >>> np.percentile(a, 50, axis=1, keepdims=True)
            // array([[ 7.],
            //        [ 2.]])
            // 
            
            #if TODO
            var given=  a = np.array({{10, 7, 4}, {3, 2, 1}});
             given=  a;
            var expected=
                "array([[10,  7,  4],\n" +
                "       [ 3,  2,  1]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.percentile(a, 50);
             expected=
                "3.5";
            Assert.AreEqual(expected, given.repr);
             given=  np.percentile(a, 50, axis=0);
             expected=
                "array([[ 6.5,  4.5,  2.5]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.percentile(a, 50, axis=1);
             expected=
                "array([ 7.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given=  np.percentile(a, 50, axis=1, keepdims=True);
             expected=
                "array([[ 7.],\n" +
                "       [ 2.]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> m = np.percentile(a, 50, axis=0)
            // >>> out = np.zeros_like(m)
            // >>> np.percentile(a, 50, axis=0, out=out)
            // array([[ 6.5,  4.5,  2.5]])
            // >>> m
            // array([[ 6.5,  4.5,  2.5]])
            // 
            
            #if TODO
             given=  m = np.percentile(a, 50, axis=0);
             given=  out = np.zeros_like(m);
             given=  np.percentile(a, 50, axis=0, out=out);
             expected=
                "array([[ 6.5,  4.5,  2.5]])";
            Assert.AreEqual(expected, given.repr);
             given=  m;
             expected=
                "array([[ 6.5,  4.5,  2.5]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> b = a.copy()
            // >>> np.percentile(b, 50, axis=1, overwrite_input=True)
            // array([ 7.,  2.])
            // >>> assert not np.all(a == b)
            // 
            
            #if TODO
             given=  b = a.copy();
             given=  np.percentile(b, 50, axis=1, overwrite_input=True);
             expected=
                "array([ 7.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given=  assert not np.all(a == b);
            #endif
            // The different types of interpolation can be visualized graphically:
            
            // import matplotlib.pyplot as plt
            // 
            // a = np.arange(4)
            // p = np.linspace(0, 100, 6001)
            // ax = plt.gca()
            // lines = [
            //     ('linear', None),
            //     ('higher', '--'),
            //     ('lower', '--'),
            //     ('nearest', '-.'),
            //     ('midpoint', '-.'),
            // ]
            // for interpolation, style in lines:
            //     ax.plot(
            //         p, np.percentile(a, p, interpolation=interpolation),
            //         label=interpolation, linestyle=style)
            // ax.set(
            //     title='Interpolation methods for list: ' + str(a),
            //     xlabel='Percentile',
            //     ylabel='List item returned',
            //     yticks=a)
            // ax.legend()
            // plt.show()
            // 
            
            #if TODO
             expected=
                "import matplotlib.pyplot as plt\n" +
                "\n" +
                "a = np.arange(4)\n" +
                "p = np.linspace(0, 100, 6001)\n" +
                "ax = plt.gca()\n" +
                "lines = [\n" +
                "    ('linear', None),\n" +
                "    ('higher', '--'),\n" +
                "    ('lower', '--'),\n" +
                "    ('nearest', '-.'),\n" +
                "    ('midpoint', '-.'),\n" +
                "]\n" +
                "for interpolation, style in lines:\n" +
                "    ax.plot(\n" +
                "        p, np.percentile(a, p, interpolation=interpolation),\n" +
                "        label=interpolation, linestyle=style)\n" +
                "ax.set(\n" +
                "    title='Interpolation methods for list: ' + str(a),\n" +
                "    xlabel='Percentile',\n" +
                "    ylabel='List item returned',\n" +
                "    yticks=a)\n" +
                "ax.legend()\n" +
                "plt.show()";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void nanpercentileTest()
        {
            // >>> a = np.array([[10., 7., 4.], [3., 2., 1.]])
            // >>> a[0][1] = np.nan
            // >>> a
            // array([[ 10.,  nan,   4.],
            //       [  3.,   2.,   1.]])
            // >>> np.percentile(a, 50)
            // nan
            // >>> np.nanpercentile(a, 50)
            // 3.5
            // >>> np.nanpercentile(a, 50, axis=0)
            // array([ 6.5,  2.,   2.5])
            // >>> np.nanpercentile(a, 50, axis=1, keepdims=True)
            // array([[ 7.],
            //        [ 2.]])
            // >>> m = np.nanpercentile(a, 50, axis=0)
            // >>> out = np.zeros_like(m)
            // >>> np.nanpercentile(a, 50, axis=0, out=out)
            // array([ 6.5,  2.,   2.5])
            // >>> m
            // array([ 6.5,  2. ,  2.5])
            // 
            
            #if TODO
            var given=  a = np.array({{10., 7., 4.}, {3., 2., 1.}});
             given=  a{0}{1} = np.nan;
             given=  a;
            var expected=
                "array([[ 10.,  nan,   4.],\n" +
                "      [  3.,   2.,   1.]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.percentile(a, 50);
             expected=
                "nan";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanpercentile(a, 50);
             expected=
                "3.5";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanpercentile(a, 50, axis=0);
             expected=
                "array([ 6.5,  2.,   2.5])";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanpercentile(a, 50, axis=1, keepdims=True);
             expected=
                "array([[ 7.],\n" +
                "       [ 2.]])";
            Assert.AreEqual(expected, given.repr);
             given=  m = np.nanpercentile(a, 50, axis=0);
             given=  out = np.zeros_like(m);
             given=  np.nanpercentile(a, 50, axis=0, out=out);
             expected=
                "array([ 6.5,  2.,   2.5])";
            Assert.AreEqual(expected, given.repr);
             given=  m;
             expected=
                "array([ 6.5,  2. ,  2.5])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> b = a.copy()
            // >>> np.nanpercentile(b, 50, axis=1, overwrite_input=True)
            // array([  7.,  2.])
            // >>> assert not np.all(a==b)
            // 
            
            #if TODO
             given=  b = a.copy();
             given=  np.nanpercentile(b, 50, axis=1, overwrite_input=True);
             expected=
                "array([  7.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given=  assert not np.all(a==b);
            #endif
        }
        
        
        [TestMethod]
        public void quantileTest()
        {
            // >>> a = np.array([[10, 7, 4], [3, 2, 1]])
            // >>> a
            // array([[10,  7,  4],
            //        [ 3,  2,  1]])
            // >>> np.quantile(a, 0.5)
            // 3.5
            // >>> np.quantile(a, 0.5, axis=0)
            // array([[ 6.5,  4.5,  2.5]])
            // >>> np.quantile(a, 0.5, axis=1)
            // array([ 7.,  2.])
            // >>> np.quantile(a, 0.5, axis=1, keepdims=True)
            // array([[ 7.],
            //        [ 2.]])
            // >>> m = np.quantile(a, 0.5, axis=0)
            // >>> out = np.zeros_like(m)
            // >>> np.quantile(a, 0.5, axis=0, out=out)
            // array([[ 6.5,  4.5,  2.5]])
            // >>> m
            // array([[ 6.5,  4.5,  2.5]])
            // >>> b = a.copy()
            // >>> np.quantile(b, 0.5, axis=1, overwrite_input=True)
            // array([ 7.,  2.])
            // >>> assert not np.all(a == b)
            // 
            
            #if TODO
            var given=  a = np.array({{10, 7, 4}, {3, 2, 1}});
             given=  a;
            var expected=
                "array([[10,  7,  4],\n" +
                "       [ 3,  2,  1]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.quantile(a, 0.5);
             expected=
                "3.5";
            Assert.AreEqual(expected, given.repr);
             given=  np.quantile(a, 0.5, axis=0);
             expected=
                "array([[ 6.5,  4.5,  2.5]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.quantile(a, 0.5, axis=1);
             expected=
                "array([ 7.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given=  np.quantile(a, 0.5, axis=1, keepdims=True);
             expected=
                "array([[ 7.],\n" +
                "       [ 2.]])";
            Assert.AreEqual(expected, given.repr);
             given=  m = np.quantile(a, 0.5, axis=0);
             given=  out = np.zeros_like(m);
             given=  np.quantile(a, 0.5, axis=0, out=out);
             expected=
                "array([[ 6.5,  4.5,  2.5]])";
            Assert.AreEqual(expected, given.repr);
             given=  m;
             expected=
                "array([[ 6.5,  4.5,  2.5]])";
            Assert.AreEqual(expected, given.repr);
             given=  b = a.copy();
             given=  np.quantile(b, 0.5, axis=1, overwrite_input=True);
             expected=
                "array([ 7.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given=  assert not np.all(a == b);
            #endif
        }
        
        
        [TestMethod]
        public void nanquantileTest()
        {
            // >>> a = np.array([[10., 7., 4.], [3., 2., 1.]])
            // >>> a[0][1] = np.nan
            // >>> a
            // array([[ 10.,  nan,   4.],
            //       [  3.,   2.,   1.]])
            // >>> np.quantile(a, 0.5)
            // nan
            // >>> np.nanquantile(a, 0.5)
            // 3.5
            // >>> np.nanquantile(a, 0.5, axis=0)
            // array([ 6.5,  2.,   2.5])
            // >>> np.nanquantile(a, 0.5, axis=1, keepdims=True)
            // array([[ 7.],
            //        [ 2.]])
            // >>> m = np.nanquantile(a, 0.5, axis=0)
            // >>> out = np.zeros_like(m)
            // >>> np.nanquantile(a, 0.5, axis=0, out=out)
            // array([ 6.5,  2.,   2.5])
            // >>> m
            // array([ 6.5,  2. ,  2.5])
            // >>> b = a.copy()
            // >>> np.nanquantile(b, 0.5, axis=1, overwrite_input=True)
            // array([  7.,  2.])
            // >>> assert not np.all(a==b)
            // 
            
            #if TODO
            var given=  a = np.array({{10., 7., 4.}, {3., 2., 1.}});
             given=  a{0}{1} = np.nan;
             given=  a;
            var expected=
                "array([[ 10.,  nan,   4.],\n" +
                "      [  3.,   2.,   1.]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.quantile(a, 0.5);
             expected=
                "nan";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanquantile(a, 0.5);
             expected=
                "3.5";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanquantile(a, 0.5, axis=0);
             expected=
                "array([ 6.5,  2.,   2.5])";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanquantile(a, 0.5, axis=1, keepdims=True);
             expected=
                "array([[ 7.],\n" +
                "       [ 2.]])";
            Assert.AreEqual(expected, given.repr);
             given=  m = np.nanquantile(a, 0.5, axis=0);
             given=  out = np.zeros_like(m);
             given=  np.nanquantile(a, 0.5, axis=0, out=out);
             expected=
                "array([ 6.5,  2.,   2.5])";
            Assert.AreEqual(expected, given.repr);
             given=  m;
             expected=
                "array([ 6.5,  2. ,  2.5])";
            Assert.AreEqual(expected, given.repr);
             given=  b = a.copy();
             given=  np.nanquantile(b, 0.5, axis=1, overwrite_input=True);
             expected=
                "array([  7.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given=  assert not np.all(a==b);
            #endif
        }
        
        
        [TestMethod]
        public void medianTest()
        {
            // >>> a = np.array([[10, 7, 4], [3, 2, 1]])
            // >>> a
            // array([[10,  7,  4],
            //        [ 3,  2,  1]])
            // >>> np.median(a)
            // 3.5
            // >>> np.median(a, axis=0)
            // array([ 6.5,  4.5,  2.5])
            // >>> np.median(a, axis=1)
            // array([ 7.,  2.])
            // >>> m = np.median(a, axis=0)
            // >>> out = np.zeros_like(m)
            // >>> np.median(a, axis=0, out=m)
            // array([ 6.5,  4.5,  2.5])
            // >>> m
            // array([ 6.5,  4.5,  2.5])
            // >>> b = a.copy()
            // >>> np.median(b, axis=1, overwrite_input=True)
            // array([ 7.,  2.])
            // >>> assert not np.all(a==b)
            // >>> b = a.copy()
            // >>> np.median(b, axis=None, overwrite_input=True)
            // 3.5
            // >>> assert not np.all(a==b)
            // 
            
            #if TODO
            var given=  a = np.array({{10, 7, 4}, {3, 2, 1}});
             given=  a;
            var expected=
                "array([[10,  7,  4],\n" +
                "       [ 3,  2,  1]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.median(a);
             expected=
                "3.5";
            Assert.AreEqual(expected, given.repr);
             given=  np.median(a, axis=0);
             expected=
                "array([ 6.5,  4.5,  2.5])";
            Assert.AreEqual(expected, given.repr);
             given=  np.median(a, axis=1);
             expected=
                "array([ 7.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given=  m = np.median(a, axis=0);
             given=  out = np.zeros_like(m);
             given=  np.median(a, axis=0, out=m);
             expected=
                "array([ 6.5,  4.5,  2.5])";
            Assert.AreEqual(expected, given.repr);
             given=  m;
             expected=
                "array([ 6.5,  4.5,  2.5])";
            Assert.AreEqual(expected, given.repr);
             given=  b = a.copy();
             given=  np.median(b, axis=1, overwrite_input=True);
             expected=
                "array([ 7.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given=  assert not np.all(a==b);
             given=  b = a.copy();
             given=  np.median(b, axis=None, overwrite_input=True);
             expected=
                "3.5";
            Assert.AreEqual(expected, given.repr);
             given=  assert not np.all(a==b);
            #endif
        }
        
        
        [TestMethod]
        public void averageTest()
        {
            // >>> data = range(1,5)
            // >>> data
            // [1, 2, 3, 4]
            // >>> np.average(data)
            // 2.5
            // >>> np.average(range(1,11), weights=range(10,0,-1))
            // 4.0
            // 
            
            #if TODO
            var given=  data = range(1,5);
             given=  data;
            var expected=
                "[1, 2, 3, 4]";
            Assert.AreEqual(expected, given.repr);
             given=  np.average(data);
             expected=
                "2.5";
            Assert.AreEqual(expected, given.repr);
             given=  np.average(range(1,11), weights=range(10,0,-1));
             expected=
                "4.0";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> data = np.arange(6).reshape((3,2))
            // >>> data
            // array([[0, 1],
            //        [2, 3],
            //        [4, 5]])
            // >>> np.average(data, axis=1, weights=[1./4, 3./4])
            // array([ 0.75,  2.75,  4.75])
            // >>> np.average(data, weights=[1./4, 3./4])
            // 
            
            #if TODO
             given=  data = np.arange(6).reshape((3,2));
             given=  data;
             expected=
                "array([[0, 1],\n" +
                "       [2, 3],\n" +
                "       [4, 5]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.average(data, axis=1, weights={1./4, 3./4});
             expected=
                "array([ 0.75,  2.75,  4.75])";
            Assert.AreEqual(expected, given.repr);
             given=  np.average(data, weights={1./4, 3./4});
            #endif
            // Traceback (most recent call last):
            // â€¦
            // TypeError: Axis must be specified when shapes of a and weights differ.
            
            // >>> a = np.ones(5, dtype=np.float128)
            // >>> w = np.ones(5, dtype=np.complex64)
            // >>> avg = np.average(a, weights=w)
            // >>> print(avg.dtype)
            // complex256
            // 
            
            #if TODO
             given=  a = np.ones(5, dtype=np.float128);
             given=  w = np.ones(5, dtype=np.complex64);
             given=  avg = np.average(a, weights=w);
             given=  print(avg.dtype);
             expected=
                "complex256";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void meanTest()
        {
            // >>> a = np.array([[1, 2], [3, 4]])
            // >>> np.mean(a)
            // 2.5
            // >>> np.mean(a, axis=0)
            // array([ 2.,  3.])
            // >>> np.mean(a, axis=1)
            // array([ 1.5,  3.5])
            // 
            
            #if TODO
            var given=  a = np.array({{1, 2}, {3, 4}});
             given=  np.mean(a);
            var expected=
                "2.5";
            Assert.AreEqual(expected, given.repr);
             given=  np.mean(a, axis=0);
             expected=
                "array([ 2.,  3.])";
            Assert.AreEqual(expected, given.repr);
             given=  np.mean(a, axis=1);
             expected=
                "array([ 1.5,  3.5])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // In single precision, mean can be inaccurate:
            
            // >>> a = np.zeros((2, 512*512), dtype=np.float32)
            // >>> a[0, :] = 1.0
            // >>> a[1, :] = 0.1
            // >>> np.mean(a)
            // 0.54999924
            // 
            
            #if TODO
             given=  a = np.zeros((2, 512*512), dtype=np.float32);
             given=  a[0, :] = 1.0;
             given=  a[1, :] = 0.1;
             given=  np.mean(a);
             expected=
                "0.54999924";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Computing the mean in float64 is more accurate:
            
            // >>> np.mean(a, dtype=np.float64)
            // 0.55000000074505806
            // 
            
            #if TODO
             given=  np.mean(a, dtype=np.float64);
             expected=
                "0.55000000074505806";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void stdTest()
        {
            // >>> a = np.array([[1, 2], [3, 4]])
            // >>> np.std(a)
            // 1.1180339887498949
            // >>> np.std(a, axis=0)
            // array([ 1.,  1.])
            // >>> np.std(a, axis=1)
            // array([ 0.5,  0.5])
            // 
            
            #if TODO
            var given=  a = np.array({{1, 2}, {3, 4}});
             given=  np.std(a);
            var expected=
                "1.1180339887498949";
            Assert.AreEqual(expected, given.repr);
             given=  np.std(a, axis=0);
             expected=
                "array([ 1.,  1.])";
            Assert.AreEqual(expected, given.repr);
             given=  np.std(a, axis=1);
             expected=
                "array([ 0.5,  0.5])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // In single precision, std() can be inaccurate:
            
            // >>> a = np.zeros((2, 512*512), dtype=np.float32)
            // >>> a[0, :] = 1.0
            // >>> a[1, :] = 0.1
            // >>> np.std(a)
            // 0.45000005
            // 
            
            #if TODO
             given=  a = np.zeros((2, 512*512), dtype=np.float32);
             given=  a[0, :] = 1.0;
             given=  a[1, :] = 0.1;
             given=  np.std(a);
             expected=
                "0.45000005";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Computing the standard deviation in float64 is more accurate:
            
            // >>> np.std(a, dtype=np.float64)
            // 0.44999999925494177
            // 
            
            #if TODO
             given=  np.std(a, dtype=np.float64);
             expected=
                "0.44999999925494177";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void varTest()
        {
            // >>> a = np.array([[1, 2], [3, 4]])
            // >>> np.var(a)
            // 1.25
            // >>> np.var(a, axis=0)
            // array([ 1.,  1.])
            // >>> np.var(a, axis=1)
            // array([ 0.25,  0.25])
            // 
            
            #if TODO
            var given=  a = np.array({{1, 2}, {3, 4}});
             given=  np.var(a);
            var expected=
                "1.25";
            Assert.AreEqual(expected, given.repr);
             given=  np.var(a, axis=0);
             expected=
                "array([ 1.,  1.])";
            Assert.AreEqual(expected, given.repr);
             given=  np.var(a, axis=1);
             expected=
                "array([ 0.25,  0.25])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // In single precision, var() can be inaccurate:
            
            // >>> a = np.zeros((2, 512*512), dtype=np.float32)
            // >>> a[0, :] = 1.0
            // >>> a[1, :] = 0.1
            // >>> np.var(a)
            // 0.20250003
            // 
            
            #if TODO
             given=  a = np.zeros((2, 512*512), dtype=np.float32);
             given=  a[0, :] = 1.0;
             given=  a[1, :] = 0.1;
             given=  np.var(a);
             expected=
                "0.20250003";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Computing the variance in float64 is more accurate:
            
            // >>> np.var(a, dtype=np.float64)
            // 0.20249999932944759
            // >>> ((1-0.55)**2 + (0.1-0.55)**2)/2
            // 0.2025
            // 
            
            #if TODO
             given=  np.var(a, dtype=np.float64);
             expected=
                "0.20249999932944759";
            Assert.AreEqual(expected, given.repr);
             given=  ((1-0.55)**2 + (0.1-0.55)**2)/2;
             expected=
                "0.2025";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void nanmedianTest()
        {
            // >>> a = np.array([[10.0, 7, 4], [3, 2, 1]])
            // >>> a[0, 1] = np.nan
            // >>> a
            // array([[ 10.,  nan,   4.],
            //    [  3.,   2.,   1.]])
            // >>> np.median(a)
            // nan
            // >>> np.nanmedian(a)
            // 3.0
            // >>> np.nanmedian(a, axis=0)
            // array([ 6.5,  2.,  2.5])
            // >>> np.median(a, axis=1)
            // array([ 7.,  2.])
            // >>> b = a.copy()
            // >>> np.nanmedian(b, axis=1, overwrite_input=True)
            // array([ 7.,  2.])
            // >>> assert not np.all(a==b)
            // >>> b = a.copy()
            // >>> np.nanmedian(b, axis=None, overwrite_input=True)
            // 3.0
            // >>> assert not np.all(a==b)
            // 
            
            #if TODO
            var given=  a = np.array({{10.0, 7, 4}, {3, 2, 1}});
             given=  a{0, 1} = np.nan;
             given=  a;
            var expected=
                "array([[ 10.,  nan,   4.],\n" +
                "   [  3.,   2.,   1.]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.median(a);
             expected=
                "nan";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanmedian(a);
             expected=
                "3.0";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanmedian(a, axis=0);
             expected=
                "array([ 6.5,  2.,  2.5])";
            Assert.AreEqual(expected, given.repr);
             given=  np.median(a, axis=1);
             expected=
                "array([ 7.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given=  b = a.copy();
             given=  np.nanmedian(b, axis=1, overwrite_input=True);
             expected=
                "array([ 7.,  2.])";
            Assert.AreEqual(expected, given.repr);
             given=  assert not np.all(a==b);
             given=  b = a.copy();
             given=  np.nanmedian(b, axis=None, overwrite_input=True);
             expected=
                "3.0";
            Assert.AreEqual(expected, given.repr);
             given=  assert not np.all(a==b);
            #endif
        }
        
        
        [TestMethod]
        public void nanmeanTest()
        {
            // >>> a = np.array([[1, np.nan], [3, 4]])
            // >>> np.nanmean(a)
            // 2.6666666666666665
            // >>> np.nanmean(a, axis=0)
            // array([ 2.,  4.])
            // >>> np.nanmean(a, axis=1)
            // array([ 1.,  3.5])
            // 
            
            #if TODO
            var given=  a = np.array({{1, np.nan}, {3, 4}});
             given=  np.nanmean(a);
            var expected=
                "2.6666666666666665";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanmean(a, axis=0);
             expected=
                "array([ 2.,  4.])";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanmean(a, axis=1);
             expected=
                "array([ 1.,  3.5])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void nanstdTest()
        {
            // >>> a = np.array([[1, np.nan], [3, 4]])
            // >>> np.nanstd(a)
            // 1.247219128924647
            // >>> np.nanstd(a, axis=0)
            // array([ 1.,  0.])
            // >>> np.nanstd(a, axis=1)
            // array([ 0.,  0.5])
            // 
            
            #if TODO
            var given=  a = np.array({{1, np.nan}, {3, 4}});
             given=  np.nanstd(a);
            var expected=
                "1.247219128924647";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanstd(a, axis=0);
             expected=
                "array([ 1.,  0.])";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanstd(a, axis=1);
             expected=
                "array([ 0.,  0.5])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void nanvarTest()
        {
            // >>> a = np.array([[1, np.nan], [3, 4]])
            // >>> np.var(a)
            // 1.5555555555555554
            // >>> np.nanvar(a, axis=0)
            // array([ 1.,  0.])
            // >>> np.nanvar(a, axis=1)
            // array([ 0.,  0.25])
            // 
            
            #if TODO
            var given=  a = np.array({{1, np.nan}, {3, 4}});
             given=  np.var(a);
            var expected=
                "1.5555555555555554";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanvar(a, axis=0);
             expected=
                "array([ 1.,  0.])";
            Assert.AreEqual(expected, given.repr);
             given=  np.nanvar(a, axis=1);
             expected=
                "array([ 0.,  0.25])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void correlateTest()
        {
            // >>> np.correlate([1, 2, 3], [0, 1, 0.5])
            // array([ 3.5])
            // >>> np.correlate([1, 2, 3], [0, 1, 0.5], "same")
            // array([ 2. ,  3.5,  3. ])
            // >>> np.correlate([1, 2, 3], [0, 1, 0.5], "full")
            // array([ 0.5,  2. ,  3.5,  3. ,  0. ])
            // 
            
            #if TODO
            var given=  np.correlate({1, 2, 3}, {0, 1, 0.5});
            var expected=
                "array([ 3.5])";
            Assert.AreEqual(expected, given.repr);
             given=  np.correlate({1, 2, 3}, {0, 1, 0.5}, "same");
             expected=
                "array([ 2. ,  3.5,  3. ])";
            Assert.AreEqual(expected, given.repr);
             given=  np.correlate({1, 2, 3}, {0, 1, 0.5}, "full");
             expected=
                "array([ 0.5,  2. ,  3.5,  3. ,  0. ])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Using complex sequences:
            
            // >>> np.correlate([1+1j, 2, 3-1j], [0, 1, 0.5j], 'full')
            // array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])
            // 
            
            #if TODO
             given=  np.correlate({1+1j, 2, 3-1j}, {0, 1, 0.5j}, 'full');
             expected=
                "array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Note that you get the time reversed, complex conjugated result
            // when the two input sequences change places, i.e.,
            // c_{va}[k] = c^{*}_{av}[-k]:
            
            // >>> np.correlate([0, 1, 0.5j], [1+1j, 2, 3-1j], 'full')
            // array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])
            // 
            
            #if TODO
             given=  np.correlate({0, 1, 0.5j}, {1+1j, 2, 3-1j}, 'full');
             expected=
                "array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void covTest()
        {
            // Consider two variables,  and , which
            // correlate perfectly, but in opposite directions:
            
            // >>> x = np.array([[0, 2], [1, 1], [2, 0]]).T
            // >>> x
            // array([[0, 1, 2],
            //        [2, 1, 0]])
            // 
            
            #if TODO
            var given=  x = np.array({{0, 2}, {1, 1}, {2, 0}}).T;
             given=  x;
            var expected=
                "array([[0, 1, 2],\n" +
                "       [2, 1, 0]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Note how  increases while  decreases. The covariance
            // matrix shows this clearly:
            
            // >>> np.cov(x)
            // array([[ 1., -1.],
            //        [-1.,  1.]])
            // 
            
            #if TODO
             given=  np.cov(x);
             expected=
                "array([[ 1., -1.],\n" +
                "       [-1.,  1.]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Note that element , which shows the correlation between
            //  and , is negative.
            
            // Further, note how x and y are combined:
            
            // >>> x = [-2.1, -1,  4.3]
            // >>> y = [3,  1.1,  0.12]
            // >>> X = np.stack((x, y), axis=0)
            // >>> print(np.cov(X))
            // [[ 11.71        -4.286     ]
            //  [ -4.286        2.14413333]]
            // >>> print(np.cov(x, y))
            // [[ 11.71        -4.286     ]
            //  [ -4.286        2.14413333]]
            // >>> print(np.cov(x))
            // 11.71
            // 
            
            #if TODO
             given=  x = [-2.1, -1,  4.3];
             given=  y = [3,  1.1,  0.12];
             given=  X = np.stack((x, y), axis=0);
             given=  print(np.cov(X));
             expected=
                "[[ 11.71        -4.286     ]\n" +
                " [ -4.286        2.14413333]]";
            Assert.AreEqual(expected, given.repr);
             given=  print(np.cov(x, y));
             expected=
                "[[ 11.71        -4.286     ]\n" +
                " [ -4.286        2.14413333]]";
            Assert.AreEqual(expected, given.repr);
             given=  print(np.cov(x));
             expected=
                "11.71";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void histogramTest()
        {
            // >>> np.histogram([1, 2, 1], bins=[0, 1, 2, 3])
            // (array([0, 2, 1]), array([0, 1, 2, 3]))
            // >>> np.histogram(np.arange(4), bins=np.arange(5), density=True)
            // (array([ 0.25,  0.25,  0.25,  0.25]), array([0, 1, 2, 3, 4]))
            // >>> np.histogram([[1, 2, 1], [1, 0, 1]], bins=[0,1,2,3])
            // (array([1, 4, 1]), array([0, 1, 2, 3]))
            // 
            
            #if TODO
            var given=  np.histogram({1, 2, 1}, bins={0, 1, 2, 3});
            var expected=
                "(array([0, 2, 1]), array([0, 1, 2, 3]))";
            Assert.AreEqual(expected, given.repr);
             given=  np.histogram(np.arange(4), bins=np.arange(5), density=True);
             expected=
                "(array([ 0.25,  0.25,  0.25,  0.25]), array([0, 1, 2, 3, 4]))";
            Assert.AreEqual(expected, given.repr);
             given=  np.histogram({{1, 2, 1}, {1, 0, 1}}, bins={0,1,2,3});
             expected=
                "(array([1, 4, 1]), array([0, 1, 2, 3]))";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> a = np.arange(5)
            // >>> hist, bin_edges = np.histogram(a, density=True)
            // >>> hist
            // array([ 0.5,  0. ,  0.5,  0. ,  0. ,  0.5,  0. ,  0.5,  0. ,  0.5])
            // >>> hist.sum()
            // 2.4999999999999996
            // >>> np.sum(hist * np.diff(bin_edges))
            // 1.0
            // 
            
            #if TODO
             given=  a = np.arange(5);
             given=  hist, bin_edges = np.histogram(a, density=True);
             given=  hist;
             expected=
                "array([ 0.5,  0. ,  0.5,  0. ,  0. ,  0.5,  0. ,  0.5,  0. ,  0.5])";
            Assert.AreEqual(expected, given.repr);
             given=  hist.sum();
             expected=
                "2.4999999999999996";
            Assert.AreEqual(expected, given.repr);
             given=  np.sum(hist * np.diff(bin_edges));
             expected=
                "1.0";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Automated Bin Selection Methods example, using 2 peak random data
            // with 2000 points:
            
            // >>> import matplotlib.pyplot as plt
            // >>> rng = np.random.RandomState(10)  # deterministic random data
            // >>> a = np.hstack((rng.normal(size=1000),
            // ...                rng.normal(loc=5, scale=2, size=1000)))
            // >>> plt.hist(a, bins='auto')  # arguments are passed to np.histogram
            // >>> plt.title("Histogram with 'auto' bins")
            // >>> plt.show()
            // 
            
            #if TODO
             given=  import matplotlib.pyplot as plt;
             given=  rng = np.random.RandomState(10)  # deterministic random data;
             given=  a = np.hstack((rng.normal(size=1000),;
             expected=
                "...                rng.normal(loc=5, scale=2, size=1000)))";
            Assert.AreEqual(expected, given.repr);
             given=  plt.hist(a, bins='auto')  # arguments are passed to np.histogram;
             given=  plt.title("Histogram with 'auto' bins");
             given=  plt.show();
            #endif
        }
        
        
        [TestMethod]
        public void histogram2dTest()
        {
            // >>> from matplotlib.image import NonUniformImage
            // >>> import matplotlib.pyplot as plt
            // 
            
            #if TODO
            var given=  from matplotlib.image import NonUniformImage;
             given=  import matplotlib.pyplot as plt;
            #endif
            // Construct a 2-D histogram with variable bin width. First define the bin
            // edges:
            
            // >>> xedges = [0, 1, 3, 5]
            // >>> yedges = [0, 2, 3, 4, 6]
            // 
            
            #if TODO
             given=  xedges = [0, 1, 3, 5];
             given=  yedges = [0, 2, 3, 4, 6];
            #endif
            // Next we create a histogram H with random bin content:
            
            // >>> x = np.random.normal(2, 1, 100)
            // >>> y = np.random.normal(1, 1, 100)
            // >>> H, xedges, yedges = np.histogram2d(x, y, bins=(xedges, yedges))
            // >>> H = H.T  # Let each row list bins with common y range.
            // 
            
            #if TODO
             given=  x = np.random.normal(2, 1, 100);
             given=  y = np.random.normal(1, 1, 100);
             given=  H, xedges, yedges = np.histogram2d(x, y, bins=(xedges, yedges));
             given=  H = H.T  # Let each row list bins with common y range.;
            #endif
            // imshow can only display square bins:
            
            // >>> fig = plt.figure(figsize=(7, 3))
            // >>> ax = fig.add_subplot(131, title='imshow: square bins')
            // >>> plt.imshow(H, interpolation='nearest', origin='low',
            // ...         extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]])
            // 
            
            #if TODO
             given=  fig = plt.figure(figsize=(7, 3));
             given=  ax = fig.add_subplot(131, title='imshow: square bins');
             given=  plt.imshow(H, interpolation='nearest', origin='low',;
            var expected=
                "...         extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // pcolormesh can display actual edges:
            
            // >>> ax = fig.add_subplot(132, title='pcolormesh: actual edges',
            // ...         aspect='equal')
            // >>> X, Y = np.meshgrid(xedges, yedges)
            // >>> ax.pcolormesh(X, Y, H)
            // 
            
            #if TODO
             given=  ax = fig.add_subplot(132, title='pcolormesh: actual edges',;
             expected=
                "...         aspect='equal')";
            Assert.AreEqual(expected, given.repr);
             given=  X, Y = np.meshgrid(xedges, yedges);
             given=  ax.pcolormesh(X, Y, H);
            #endif
            // NonUniformImage can be used to
            // display actual bin edges with interpolation:
            
            // >>> ax = fig.add_subplot(133, title='NonUniformImage: interpolated',
            // ...         aspect='equal', xlim=xedges[[0, -1]], ylim=yedges[[0, -1]])
            // >>> im = NonUniformImage(ax, interpolation='bilinear')
            // >>> xcenters = (xedges[:-1] + xedges[1:]) / 2
            // >>> ycenters = (yedges[:-1] + yedges[1:]) / 2
            // >>> im.set_data(xcenters, ycenters, H)
            // >>> ax.images.append(im)
            // >>> plt.show()
            // 
            
            #if TODO
             given=  ax = fig.add_subplot(133, title='NonUniformImage: interpolated',;
             expected=
                "...         aspect='equal', xlim=xedges[[0, -1]], ylim=yedges[[0, -1]])";
            Assert.AreEqual(expected, given.repr);
             given=  im = NonUniformImage(ax, interpolation='bilinear');
             given=  xcenters = (xedges[:-1] + xedges[1:]) / 2;
             given=  ycenters = (yedges[:-1] + yedges[1:]) / 2;
             given=  im.set_data(xcenters, ycenters, H);
             given=  ax.images.append(im);
             given=  plt.show();
            #endif
        }
        
        
        [TestMethod]
        public void histogramddTest()
        {
            // >>> r = np.random.randn(100,3)
            // >>> H, edges = np.histogramdd(r, bins = (5, 8, 4))
            // >>> H.shape, edges[0].size, edges[1].size, edges[2].size
            // ((5, 8, 4), 6, 9, 5)
            // 
            
            #if TODO
            var given=  r = np.random.randn(100,3);
             given=  H, edges = np.histogramdd(r, bins = (5, 8, 4));
             given=  H.shape, edges[0].size, edges[1].size, edges[2].size;
            var expected=
                "((5, 8, 4), 6, 9, 5)";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void bincountTest()
        {
            // >>> np.bincount(np.arange(5))
            // array([1, 1, 1, 1, 1])
            // >>> np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))
            // array([1, 3, 1, 1, 0, 0, 0, 1])
            // 
            
            #if TODO
            var given=  np.bincount(np.arange(5));
            var expected=
                "array([1, 1, 1, 1, 1])";
            Assert.AreEqual(expected, given.repr);
             given=  np.bincount(np.array({0, 1, 1, 3, 2, 1, 7}));
             expected=
                "array([1, 3, 1, 1, 0, 0, 0, 1])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> x = np.array([0, 1, 1, 3, 2, 1, 7, 23])
            // >>> np.bincount(x).size == np.amax(x)+1
            // True
            // 
            
            #if TODO
             given=  x = np.array({0, 1, 1, 3, 2, 1, 7, 23});
             given=  np.bincount(x).size == np.amax(x)+1;
             expected=
                "True";
            Assert.AreEqual(expected, given.repr);
            #endif
            // The input array needs to be of integer dtype, otherwise a
            // TypeError is raised:
            
            // >>> np.bincount(np.arange(5, dtype=float))
            // Traceback (most recent call last):
            //   File "<stdin>", line 1, in <module>
            // TypeError: array cannot be safely cast to required type
            // 
            
            #if TODO
             given=  np.bincount(np.arange(5, dtype=float));
             expected=
                "Traceback (most recent call last):\n" +
                "  File "<stdin>", line 1, in <module>\n" +
                "TypeError: array cannot be safely cast to required type";
            Assert.AreEqual(expected, given.repr);
            #endif
            // A possible use of bincount is to perform sums over
            // variable-size chunks of an array, using the weights keyword.
            
            // >>> w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights
            // >>> x = np.array([0, 1, 1, 2, 2, 2])
            // >>> np.bincount(x,  weights=w)
            // array([ 0.3,  0.7,  1.1])
            // 
            
            #if TODO
             given=  w = np.array({0.3, 0.5, 0.2, 0.7, 1., -0.6}) # weights;
             given=  x = np.array({0, 1, 1, 2, 2, 2});
             given=  np.bincount(x,  weights=w);
             expected=
                "array([ 0.3,  0.7,  1.1])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void histogram_bin_edgesTest()
        {
            // >>> arr = np.array([0, 0, 0, 1, 2, 3, 3, 4, 5])
            // >>> np.histogram_bin_edges(arr, bins='auto', range=(0, 1))
            // array([0.  , 0.25, 0.5 , 0.75, 1.  ])
            // >>> np.histogram_bin_edges(arr, bins=2)
            // array([0. , 2.5, 5. ])
            // 
            
            #if TODO
            var given=  arr = np.array({0, 0, 0, 1, 2, 3, 3, 4, 5});
             given=  np.histogram_bin_edges(arr, bins='auto', range=(0, 1));
            var expected=
                "array([0.  , 0.25, 0.5 , 0.75, 1.  ])";
            Assert.AreEqual(expected, given.repr);
             given=  np.histogram_bin_edges(arr, bins=2);
             expected=
                "array([0. , 2.5, 5. ])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // For consistency with histogram, an array of pre-computed bins is
            // passed through unmodified:
            
            // >>> np.histogram_bin_edges(arr, [1, 2])
            // array([1, 2])
            // 
            
            #if TODO
             given=  np.histogram_bin_edges(arr, {1, 2});
             expected=
                "array([1, 2])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // This function allows one set of bins to be computed, and reused across
            // multiple histograms:
            
            // >>> shared_bins = np.histogram_bin_edges(arr, bins='auto')
            // >>> shared_bins
            // array([0., 1., 2., 3., 4., 5.])
            // 
            
            #if TODO
             given=  shared_bins = np.histogram_bin_edges(arr, bins='auto');
             given=  shared_bins;
             expected=
                "array([0., 1., 2., 3., 4., 5.])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> group_id = np.array([0, 1, 1, 0, 1, 1, 0, 1, 1])
            // >>> hist_0, _ = np.histogram(arr[group_id == 0], bins=shared_bins)
            // >>> hist_1, _ = np.histogram(arr[group_id == 1], bins=shared_bins)
            // 
            
            #if TODO
             given=  group_id = np.array({0, 1, 1, 0, 1, 1, 0, 1, 1});
             given=  hist_0, _ = np.histogram(arr{group_id == 0}, bins=shared_bins);
             given=  hist_1, _ = np.histogram(arr{group_id == 1}, bins=shared_bins);
            #endif
            // >>> hist_0; hist_1
            // array([1, 1, 0, 1, 0])
            // array([2, 0, 1, 1, 2])
            // 
            
            #if TODO
             given=  hist_0; hist_1;
             expected=
                "array([1, 1, 0, 1, 0])\n" +
                "array([2, 0, 1, 1, 2])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Which gives more easily comparable results than using separate bins for
            // each histogram:
            
            // >>> hist_0, bins_0 = np.histogram(arr[group_id == 0], bins='auto')
            // >>> hist_1, bins_1 = np.histogram(arr[group_id == 1], bins='auto')
            // >>> hist_0; hist1
            // array([1, 1, 1])
            // array([2, 1, 1, 2])
            // >>> bins_0; bins_1
            // array([0., 1., 2., 3.])
            // array([0.  , 1.25, 2.5 , 3.75, 5.  ])
            // 
            
            #if TODO
             given=  hist_0, bins_0 = np.histogram(arr{group_id == 0}, bins='auto');
             given=  hist_1, bins_1 = np.histogram(arr{group_id == 1}, bins='auto');
             given=  hist_0; hist1;
             expected=
                "array([1, 1, 1])\n" +
                "array([2, 1, 1, 2])";
            Assert.AreEqual(expected, given.repr);
             given=  bins_0; bins_1;
             expected=
                "array([0., 1., 2., 3.])\n" +
                "array([0.  , 1.25, 2.5 , 3.75, 5.  ])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void digitizeTest()
        {
            // >>> x = np.array([0.2, 6.4, 3.0, 1.6])
            // >>> bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])
            // >>> inds = np.digitize(x, bins)
            // >>> inds
            // array([1, 4, 3, 2])
            // >>> for n in range(x.size):
            // ...   print(bins[inds[n]-1], "<=", x[n], "<", bins[inds[n]])
            // ...
            // 0.0 <= 0.2 < 1.0
            // 4.0 <= 6.4 < 10.0
            // 2.5 <= 3.0 < 4.0
            // 1.0 <= 1.6 < 2.5
            // 
            
            #if TODO
            var given=  x = np.array({0.2, 6.4, 3.0, 1.6});
             given=  bins = np.array({0.0, 1.0, 2.5, 4.0, 10.0});
             given=  inds = np.digitize(x, bins);
             given=  inds;
            var expected=
                "array([1, 4, 3, 2])";
            Assert.AreEqual(expected, given.repr);
             given=  for n in range(x.size):;
             expected=
                "...   print(bins[inds[n]-1], "<=", x[n], "<", bins[inds[n]])\n" +
                "...\n" +
                "0.0 <= 0.2 < 1.0\n" +
                "4.0 <= 6.4 < 10.0\n" +
                "2.5 <= 3.0 < 4.0\n" +
                "1.0 <= 1.6 < 2.5";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> x = np.array([1.2, 10.0, 12.4, 15.5, 20.])
            // >>> bins = np.array([0, 5, 10, 15, 20])
            // >>> np.digitize(x,bins,right=True)
            // array([1, 2, 3, 4, 4])
            // >>> np.digitize(x,bins,right=False)
            // array([1, 3, 3, 4, 5])
            // 
            
            #if TODO
             given=  x = np.array({1.2, 10.0, 12.4, 15.5, 20.});
             given=  bins = np.array({0, 5, 10, 15, 20});
             given=  np.digitize(x,bins,right=True);
             expected=
                "array([1, 2, 3, 4, 4])";
            Assert.AreEqual(expected, given.repr);
             given=  np.digitize(x,bins,right=False);
             expected=
                "array([1, 3, 3, 4, 5])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
    }
}
