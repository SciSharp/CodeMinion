// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Numpy.Models;

using Microsoft.VisualStudio.TestTools.UnitTesting;
using Assert = NUnit.Framework.Assert;

namespace Numpy.UnitTest
{
    [TestClass]
    public class NumPy_indexingTest : BaseTestCase
    {
        
        [TestMethod]
        public void r_Test()
        {
            // >>> np.r_[np.array([1,2,3]), 0, 0, np.array([4,5,6])]
            // array([1, 2, 3, 0, 0, 4, 5, 6])
            // >>> np.r_[-1:1:6j, [0]*3, 5, 6]
            // array([-1. , -0.6, -0.2,  0.2,  0.6,  1. ,  0. ,  0. ,  0. ,  5. ,  6. ])
            // 
            
            #if TODO
            var given=  np.r_{np.array({1,2,3}), 0, 0, np.array({4,5,6})};
            var expected=
                "array([1, 2, 3, 0, 0, 4, 5, 6])";
            Assert.AreEqual(expected, given.repr);
             given=  np.r_{-1:1:6j, {0}*3, 5, 6};
             expected=
                "array([-1. , -0.6, -0.2,  0.2,  0.6,  1. ,  0. ,  0. ,  0. ,  5. ,  6. ])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // String integers specify the axis to concatenate along or the minimum
            // number of dimensions to force entries into.
            
            // >>> a = np.array([[0, 1, 2], [3, 4, 5]])
            // >>> np.r_['-1', a, a] # concatenate along last axis
            // array([[0, 1, 2, 0, 1, 2],
            //        [3, 4, 5, 3, 4, 5]])
            // >>> np.r_['0,2', [1,2,3], [4,5,6]] # concatenate along first axis, dim>=2
            // array([[1, 2, 3],
            //        [4, 5, 6]])
            // 
            
            #if TODO
             given=  a = np.array({{0, 1, 2}, {3, 4, 5}});
             given=  np.r_{'-1', a, a} # concatenate along last axis;
             expected=
                "array([[0, 1, 2, 0, 1, 2],\n" +
                "       [3, 4, 5, 3, 4, 5]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.r_{'0,2', {1,2,3}, {4,5,6}} # concatenate along first axis, dim>=2;
             expected=
                "array([[1, 2, 3],\n" +
                "       [4, 5, 6]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.r_['0,2,0', [1,2,3], [4,5,6]]
            // array([[1],
            //        [2],
            //        [3],
            //        [4],
            //        [5],
            //        [6]])
            // >>> np.r_['1,2,0', [1,2,3], [4,5,6]]
            // array([[1, 4],
            //        [2, 5],
            //        [3, 6]])
            // 
            
            #if TODO
             given=  np.r_{'0,2,0', {1,2,3}, {4,5,6}};
             expected=
                "array([[1],\n" +
                "       [2],\n" +
                "       [3],\n" +
                "       [4],\n" +
                "       [5],\n" +
                "       [6]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.r_{'1,2,0', {1,2,3}, {4,5,6}};
             expected=
                "array([[1, 4],\n" +
                "       [2, 5],\n" +
                "       [3, 6]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Using ‘r’ or ‘c’ as a first string argument creates a matrix.
            
            // >>> np.r_['r',[1,2,3], [4,5,6]]
            // matrix([[1, 2, 3, 4, 5, 6]])
            // 
            
            #if TODO
             given=  np.r_{'r',{1,2,3}, {4,5,6}};
             expected=
                "matrix([[1, 2, 3, 4, 5, 6]])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void s_Test()
        {
            // >>> np.s_[2::2]
            // slice(2, None, 2)
            // >>> np.index_exp[2::2]
            // (slice(2, None, 2),)
            // 
            
            #if TODO
            var given=  np.s_{2::2};
            var expected=
                "slice(2, None, 2)";
            Assert.AreEqual(expected, given.repr);
             given=  np.index_exp{2::2};
             expected=
                "(slice(2, None, 2),)";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.array([0, 1, 2, 3, 4])[np.s_[2::2]]
            // array([2, 4])
            // 
            
            #if TODO
             given=  np.array({0, 1, 2, 3, 4}){np.s_{2::2}};
             expected=
                "array([2, 4])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void nonzeroTest()
        {
            // >>> x = np.array([[3, 0, 0], [0, 4, 0], [5, 6, 0]])
            // >>> x
            // array([[3, 0, 0],
            //        [0, 4, 0],
            //        [5, 6, 0]])
            // >>> np.nonzero(x)
            // (array([0, 1, 2, 2]), array([0, 1, 0, 1]))
            // 
            
            #if TODO
            var given=  x = np.array({{3, 0, 0}, {0, 4, 0}, {5, 6, 0}});
             given=  x;
            var expected=
                "array([[3, 0, 0],\n" +
                "       [0, 4, 0],\n" +
                "       [5, 6, 0]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.nonzero(x);
             expected=
                "(array([0, 1, 2, 2]), array([0, 1, 0, 1]))";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> x[np.nonzero(x)]
            // array([3, 4, 5, 6])
            // >>> np.transpose(np.nonzero(x))
            // array([[0, 0],
            //        [1, 1],
            //        [2, 0],
            //        [2, 1])
            // 
            
            #if TODO
             given=  x{np.nonzero(x)};
             expected=
                "array([3, 4, 5, 6])";
            Assert.AreEqual(expected, given.repr);
             given=  np.transpose(np.nonzero(x));
             expected=
                "array([[0, 0],\n" +
                "       [1, 1],\n" +
                "       [2, 0],\n" +
                "       [2, 1])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // A common use for nonzero is to find the indices of an array, where
            // a condition is True.  Given an array a, the condition a > 3 is a
            // boolean array and since False is interpreted as 0, np.nonzero(a > 3)
            // yields the indices of the a where the condition is true.
            
            // >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
            // >>> a > 3
            // array([[False, False, False],
            //        [ True,  True,  True],
            //        [ True,  True,  True]])
            // >>> np.nonzero(a > 3)
            // (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
            // 
            
            #if TODO
             given=  a = np.array({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}});
             given=  a > 3;
             expected=
                "array([[False, False, False],\n" +
                "       [ True,  True,  True],\n" +
                "       [ True,  True,  True]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.nonzero(a > 3);
             expected=
                "(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Using this result to index a is equivalent to using the mask directly:
            
            // >>> a[np.nonzero(a > 3)]
            // array([4, 5, 6, 7, 8, 9])
            // >>> a[a > 3]  # prefer this spelling
            // array([4, 5, 6, 7, 8, 9])
            // 
            
            #if TODO
             given=  a{np.nonzero(a > 3)};
             expected=
                "array([4, 5, 6, 7, 8, 9])";
            Assert.AreEqual(expected, given.repr);
             given=  a[a > 3]  # prefer this spelling;
             expected=
                "array([4, 5, 6, 7, 8, 9])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // nonzero can also be called as a method of the array.
            
            // >>> (a > 3).nonzero()
            // (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
            // 
            
            #if TODO
             given=  (a > 3).nonzero();
             expected=
                "(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void whereTest()
        {
            // >>> a = np.arange(10)
            // >>> a
            // array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
            // >>> np.where(a < 5, a, 10*a)
            // array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])
            // 
            
            #if TODO
            var given=  a = np.arange(10);
             given=  a;
            var expected=
                "array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])";
            Assert.AreEqual(expected, given.repr);
             given=  np.where(a < 5, a, 10*a);
             expected=
                "array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // This can be used on multidimensional arrays too:
            
            // >>> np.where([[True, False], [True, True]],
            // ...          [[1, 2], [3, 4]],
            // ...          [[9, 8], [7, 6]])
            // array([[1, 8],
            //        [3, 4]])
            // 
            
            #if TODO
             given=  np.where({{True, False}, {True, True}},;
             expected=
                "...          [[1, 2], [3, 4]],\n" +
                "...          [[9, 8], [7, 6]])\n" +
                "array([[1, 8],\n" +
                "       [3, 4]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // The shapes of x, y, and the condition are broadcast together:
            
            // >>> x, y = np.ogrid[:3, :4]
            // >>> np.where(x < y, x, 10 + y)  # both x and 10+y are broadcast
            // array([[10,  0,  0,  0],
            //        [10, 11,  1,  1],
            //        [10, 11, 12,  2]])
            // 
            
            #if TODO
             given=  x, y = np.ogrid{:3, :4};
             given=  np.where(x < y, x, 10 + y)  # both x and 10+y are broadcast;
             expected=
                "array([[10,  0,  0,  0],\n" +
                "       [10, 11,  1,  1],\n" +
                "       [10, 11, 12,  2]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> a = np.array([[0, 1, 2],
            // ...               [0, 2, 4],
            // ...               [0, 3, 6]])
            // >>> np.where(a < 4, a, -1)  # -1 is broadcast
            // array([[ 0,  1,  2],
            //        [ 0,  2, -1],
            //        [ 0,  3, -1]])
            // 
            
            #if TODO
             given=  a = np.array({{0, 1, 2},;
             expected=
                "...               [0, 2, 4],\n" +
                "...               [0, 3, 6]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.where(a < 4, a, -1)  # -1 is broadcast;
             expected=
                "array([[ 0,  1,  2],\n" +
                "       [ 0,  2, -1],\n" +
                "       [ 0,  3, -1]])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void indicesTest()
        {
            // >>> grid = np.indices((2, 3))
            // >>> grid.shape
            // (2, 2, 3)
            // >>> grid[0]        # row indices
            // array([[0, 0, 0],
            //        [1, 1, 1]])
            // >>> grid[1]        # column indices
            // array([[0, 1, 2],
            //        [0, 1, 2]])
            // 
            
            #if TODO
            var given=  grid = np.indices((2, 3));
             given=  grid.shape;
            var expected=
                "(2, 2, 3)";
            Assert.AreEqual(expected, given.repr);
             given=  grid[0]        # row indices;
             expected=
                "array([[0, 0, 0],\n" +
                "       [1, 1, 1]])";
            Assert.AreEqual(expected, given.repr);
             given=  grid[1]        # column indices;
             expected=
                "array([[0, 1, 2],\n" +
                "       [0, 1, 2]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // The indices can be used as an index into an array.
            
            // >>> x = np.arange(20).reshape(5, 4)
            // >>> row, col = np.indices((2, 3))
            // >>> x[row, col]
            // array([[0, 1, 2],
            //        [4, 5, 6]])
            // 
            
            #if TODO
             given=  x = np.arange(20).reshape(5, 4);
             given=  row, col = np.indices((2, 3));
             given=  x[row, col];
             expected=
                "array([[0, 1, 2],\n" +
                "       [4, 5, 6]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Note that it would be more straightforward in the above example to
            // extract the required elements directly with x[:2, :3].
            
        }
        
        
        [TestMethod]
        public void ix_Test()
        {
            // >>> a = np.arange(10).reshape(2, 5)
            // >>> a
            // array([[0, 1, 2, 3, 4],
            //        [5, 6, 7, 8, 9]])
            // >>> ixgrid = np.ix_([0, 1], [2, 4])
            // >>> ixgrid
            // (array([[0],
            //        [1]]), array([[2, 4]]))
            // >>> ixgrid[0].shape, ixgrid[1].shape
            // ((2, 1), (1, 2))
            // >>> a[ixgrid]
            // array([[2, 4],
            //        [7, 9]])
            // 
            
            #if TODO
            var given=  a = np.arange(10).reshape(2, 5);
             given=  a;
            var expected=
                "array([[0, 1, 2, 3, 4],\n" +
                "       [5, 6, 7, 8, 9]])";
            Assert.AreEqual(expected, given.repr);
             given=  ixgrid = np.ix_({0, 1}, {2, 4});
             given=  ixgrid;
             expected=
                "(array([[0],\n" +
                "       [1]]), array([[2, 4]]))";
            Assert.AreEqual(expected, given.repr);
             given=  ixgrid[0].shape, ixgrid[1].shape;
             expected=
                "((2, 1), (1, 2))";
            Assert.AreEqual(expected, given.repr);
             given=  a[ixgrid];
             expected=
                "array([[2, 4],\n" +
                "       [7, 9]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> ixgrid = np.ix_([True, True], [2, 4])
            // >>> a[ixgrid]
            // array([[2, 4],
            //        [7, 9]])
            // >>> ixgrid = np.ix_([True, True], [False, False, True, False, True])
            // >>> a[ixgrid]
            // array([[2, 4],
            //        [7, 9]])
            // 
            
            #if TODO
             given=  ixgrid = np.ix_({True, True}, {2, 4});
             given=  a[ixgrid];
             expected=
                "array([[2, 4],\n" +
                "       [7, 9]])";
            Assert.AreEqual(expected, given.repr);
             given=  ixgrid = np.ix_({True, True}, {False, False, True, False, True});
             given=  a[ixgrid];
             expected=
                "array([[2, 4],\n" +
                "       [7, 9]])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void ravel_multi_indexTest()
        {
            // >>> arr = np.array([[3,6,6],[4,5,1]])
            // >>> np.ravel_multi_index(arr, (7,6))
            // array([22, 41, 37])
            // >>> np.ravel_multi_index(arr, (7,6), order='F')
            // array([31, 41, 13])
            // >>> np.ravel_multi_index(arr, (4,6), mode='clip')
            // array([22, 23, 19])
            // >>> np.ravel_multi_index(arr, (4,4), mode=('clip','wrap'))
            // array([12, 13, 13])
            // 
            
            #if TODO
            var given=  arr = np.array({{3,6,6},{4,5,1}});
             given=  np.ravel_multi_index(arr, (7,6));
            var expected=
                "array([22, 41, 37])";
            Assert.AreEqual(expected, given.repr);
             given=  np.ravel_multi_index(arr, (7,6), order='F');
             expected=
                "array([31, 41, 13])";
            Assert.AreEqual(expected, given.repr);
             given=  np.ravel_multi_index(arr, (4,6), mode='clip');
             expected=
                "array([22, 23, 19])";
            Assert.AreEqual(expected, given.repr);
             given=  np.ravel_multi_index(arr, (4,4), mode=('clip','wrap'));
             expected=
                "array([12, 13, 13])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.ravel_multi_index((3,1,4,1), (6,7,8,9))
            // 1621
            // 
            
            #if TODO
             given=  np.ravel_multi_index((3,1,4,1), (6,7,8,9));
             expected=
                "1621";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void unravel_indexTest()
        {
            // >>> np.unravel_index([22, 41, 37], (7,6))
            // (array([3, 6, 6]), array([4, 5, 1]))
            // >>> np.unravel_index([31, 41, 13], (7,6), order='F')
            // (array([3, 6, 6]), array([4, 5, 1]))
            // 
            
            #if TODO
            var given=  np.unravel_index({22, 41, 37}, (7,6));
            var expected=
                "(array([3, 6, 6]), array([4, 5, 1]))";
            Assert.AreEqual(expected, given.repr);
             given=  np.unravel_index({31, 41, 13}, (7,6), order='F');
             expected=
                "(array([3, 6, 6]), array([4, 5, 1]))";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.unravel_index(1621, (6,7,8,9))
            // (3, 1, 4, 1)
            // 
            
            #if TODO
             given=  np.unravel_index(1621, (6,7,8,9));
             expected=
                "(3, 1, 4, 1)";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void diag_indicesTest()
        {
            // Create a set of indices to access the diagonal of a (4, 4) array:
            
            // >>> di = np.diag_indices(4)
            // >>> di
            // (array([0, 1, 2, 3]), array([0, 1, 2, 3]))
            // >>> a = np.arange(16).reshape(4, 4)
            // >>> a
            // array([[ 0,  1,  2,  3],
            //        [ 4,  5,  6,  7],
            //        [ 8,  9, 10, 11],
            //        [12, 13, 14, 15]])
            // >>> a[di] = 100
            // >>> a
            // array([[100,   1,   2,   3],
            //        [  4, 100,   6,   7],
            //        [  8,   9, 100,  11],
            //        [ 12,  13,  14, 100]])
            // 
            
            #if TODO
            var given=  di = np.diag_indices(4);
             given=  di;
            var expected=
                "(array([0, 1, 2, 3]), array([0, 1, 2, 3]))";
            Assert.AreEqual(expected, given.repr);
             given=  a = np.arange(16).reshape(4, 4);
             given=  a;
             expected=
                "array([[ 0,  1,  2,  3],\n" +
                "       [ 4,  5,  6,  7],\n" +
                "       [ 8,  9, 10, 11],\n" +
                "       [12, 13, 14, 15]])";
            Assert.AreEqual(expected, given.repr);
             given=  a[di] = 100;
             given=  a;
             expected=
                "array([[100,   1,   2,   3],\n" +
                "       [  4, 100,   6,   7],\n" +
                "       [  8,   9, 100,  11],\n" +
                "       [ 12,  13,  14, 100]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Now, we create indices to manipulate a 3-D array:
            
            // >>> d3 = np.diag_indices(2, 3)
            // >>> d3
            // (array([0, 1]), array([0, 1]), array([0, 1]))
            // 
            
            #if TODO
             given=  d3 = np.diag_indices(2, 3);
             given=  d3;
             expected=
                "(array([0, 1]), array([0, 1]), array([0, 1]))";
            Assert.AreEqual(expected, given.repr);
            #endif
            // And use it to set the diagonal of an array of zeros to 1:
            
            // >>> a = np.zeros((2, 2, 2), dtype=int)
            // >>> a[d3] = 1
            // >>> a
            // array([[[1, 0],
            //         [0, 0]],
            //        [[0, 0],
            //         [0, 1]]])
            // 
            
            #if TODO
             given=  a = np.zeros((2, 2, 2), dtype=int);
             given=  a[d3] = 1;
             given=  a;
             expected=
                "array([[[1, 0],\n" +
                "        [0, 0]],\n" +
                "       [[0, 0],\n" +
                "        [0, 1]]])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void mask_indicesTest()
        {
            // These are the indices that would allow you to access the upper triangular
            // part of any 3x3 array:
            
            // >>> iu = np.mask_indices(3, np.triu)
            // 
            
            #if TODO
            var given=  iu = np.mask_indices(3, np.triu);
            #endif
            // For example, if a is a 3x3 array:
            
            // >>> a = np.arange(9).reshape(3, 3)
            // >>> a
            // array([[0, 1, 2],
            //        [3, 4, 5],
            //        [6, 7, 8]])
            // >>> a[iu]
            // array([0, 1, 2, 4, 5, 8])
            // 
            
            #if TODO
             given=  a = np.arange(9).reshape(3, 3);
             given=  a;
            var expected=
                "array([[0, 1, 2],\n" +
                "       [3, 4, 5],\n" +
                "       [6, 7, 8]])";
            Assert.AreEqual(expected, given.repr);
             given=  a[iu];
             expected=
                "array([0, 1, 2, 4, 5, 8])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // An offset can be passed also to the masking function.  This gets us the
            // indices starting on the first diagonal right of the main one:
            
            // >>> iu1 = np.mask_indices(3, np.triu, 1)
            // 
            
            #if TODO
             given=  iu1 = np.mask_indices(3, np.triu, 1);
            #endif
            // with which we now extract only three elements:
            
            // >>> a[iu1]
            // array([1, 2, 5])
            // 
            
            #if TODO
             given=  a[iu1];
             expected=
                "array([1, 2, 5])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void tril_indicesTest()
        {
            // Compute two different sets of indices to access 4x4 arrays, one for the
            // lower triangular part starting at the main diagonal, and one starting two
            // diagonals further right:
            
            // >>> il1 = np.tril_indices(4)
            // >>> il2 = np.tril_indices(4, 2)
            // 
            
            #if TODO
            var given=  il1 = np.tril_indices(4);
             given=  il2 = np.tril_indices(4, 2);
            #endif
            // Here is how they can be used with a sample array:
            
            // >>> a = np.arange(16).reshape(4, 4)
            // >>> a
            // array([[ 0,  1,  2,  3],
            //        [ 4,  5,  6,  7],
            //        [ 8,  9, 10, 11],
            //        [12, 13, 14, 15]])
            // 
            
            #if TODO
             given=  a = np.arange(16).reshape(4, 4);
             given=  a;
            var expected=
                "array([[ 0,  1,  2,  3],\n" +
                "       [ 4,  5,  6,  7],\n" +
                "       [ 8,  9, 10, 11],\n" +
                "       [12, 13, 14, 15]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Both for indexing:
            
            // >>> a[il1]
            // array([ 0,  4,  5,  8,  9, 10, 12, 13, 14, 15])
            // 
            
            #if TODO
             given=  a[il1];
             expected=
                "array([ 0,  4,  5,  8,  9, 10, 12, 13, 14, 15])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // And for assigning values:
            
            // >>> a[il1] = -1
            // >>> a
            // array([[-1,  1,  2,  3],
            //        [-1, -1,  6,  7],
            //        [-1, -1, -1, 11],
            //        [-1, -1, -1, -1]])
            // 
            
            #if TODO
             given=  a[il1] = -1;
             given=  a;
             expected=
                "array([[-1,  1,  2,  3],\n" +
                "       [-1, -1,  6,  7],\n" +
                "       [-1, -1, -1, 11],\n" +
                "       [-1, -1, -1, -1]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // These cover almost the whole array (two diagonals right of the main one):
            
            // >>> a[il2] = -10
            // >>> a
            // array([[-10, -10, -10,   3],
            //        [-10, -10, -10, -10],
            //        [-10, -10, -10, -10],
            //        [-10, -10, -10, -10]])
            // 
            
            #if TODO
             given=  a[il2] = -10;
             given=  a;
             expected=
                "array([[-10, -10, -10,   3],\n" +
                "       [-10, -10, -10, -10],\n" +
                "       [-10, -10, -10, -10],\n" +
                "       [-10, -10, -10, -10]])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void triu_indicesTest()
        {
            // Compute two different sets of indices to access 4x4 arrays, one for the
            // upper triangular part starting at the main diagonal, and one starting two
            // diagonals further right:
            
            // >>> iu1 = np.triu_indices(4)
            // >>> iu2 = np.triu_indices(4, 2)
            // 
            
            #if TODO
            var given=  iu1 = np.triu_indices(4);
             given=  iu2 = np.triu_indices(4, 2);
            #endif
            // Here is how they can be used with a sample array:
            
            // >>> a = np.arange(16).reshape(4, 4)
            // >>> a
            // array([[ 0,  1,  2,  3],
            //        [ 4,  5,  6,  7],
            //        [ 8,  9, 10, 11],
            //        [12, 13, 14, 15]])
            // 
            
            #if TODO
             given=  a = np.arange(16).reshape(4, 4);
             given=  a;
            var expected=
                "array([[ 0,  1,  2,  3],\n" +
                "       [ 4,  5,  6,  7],\n" +
                "       [ 8,  9, 10, 11],\n" +
                "       [12, 13, 14, 15]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Both for indexing:
            
            // >>> a[iu1]
            // array([ 0,  1,  2,  3,  5,  6,  7, 10, 11, 15])
            // 
            
            #if TODO
             given=  a[iu1];
             expected=
                "array([ 0,  1,  2,  3,  5,  6,  7, 10, 11, 15])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // And for assigning values:
            
            // >>> a[iu1] = -1
            // >>> a
            // array([[-1, -1, -1, -1],
            //        [ 4, -1, -1, -1],
            //        [ 8,  9, -1, -1],
            //        [12, 13, 14, -1]])
            // 
            
            #if TODO
             given=  a[iu1] = -1;
             given=  a;
             expected=
                "array([[-1, -1, -1, -1],\n" +
                "       [ 4, -1, -1, -1],\n" +
                "       [ 8,  9, -1, -1],\n" +
                "       [12, 13, 14, -1]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // These cover only a small part of the whole array (two diagonals right
            // of the main one):
            
            // >>> a[iu2] = -10
            // >>> a
            // array([[ -1,  -1, -10, -10],
            //        [  4,  -1,  -1, -10],
            //        [  8,   9,  -1,  -1],
            //        [ 12,  13,  14,  -1]])
            // 
            
            #if TODO
             given=  a[iu2] = -10;
             given=  a;
             expected=
                "array([[ -1,  -1, -10, -10],\n" +
                "       [  4,  -1,  -1, -10],\n" +
                "       [  8,   9,  -1,  -1],\n" +
                "       [ 12,  13,  14,  -1]])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void takeTest()
        {
            // >>> a = [4, 3, 5, 7, 6, 8]
            // >>> indices = [0, 1, 4]
            // >>> np.take(a, indices)
            // array([4, 3, 6])
            // 
            
            #if TODO
            var given=  a = [4, 3, 5, 7, 6, 8];
             given=  indices = [0, 1, 4];
             given=  np.take(a, indices);
            var expected=
                "array([4, 3, 6])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // In this example if a is an ndarray, “fancy” indexing can be used.
            
            // >>> a = np.array(a)
            // >>> a[indices]
            // array([4, 3, 6])
            // 
            
            #if TODO
             given=  a = np.array(a);
             given=  a[indices];
             expected=
                "array([4, 3, 6])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // If indices is not one dimensional, the output also has these dimensions.
            
            // >>> np.take(a, [[0, 1], [2, 3]])
            // array([[4, 3],
            //        [5, 7]])
            // 
            
            #if TODO
             given=  np.take(a, {{0, 1}, {2, 3}});
             expected=
                "array([[4, 3],\n" +
                "       [5, 7]])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void take_along_axisTest()
        {
            // For this sample array

            // >>> a = np.array([[10, 30, 20], [60, 40, 50]])
            var a=  np.array(new[,]{{10, 30, 20}, {60, 40, 50}});

            // We can sort either by using sort directly, or argsort and this function

            // >>> np.sort(a, axis=1)
            // array([[10, 20, 30],
            //        [40, 50, 60]])
            // >>> ai = np.argsort(a, axis=1); ai
            // array([[0, 2, 1],
            //        [1, 2, 0]], dtype=int64)
            // >>> np.take_along_axis(a, ai, axis=1)
            // array([[10, 20, 30],
            //        [40, 50, 60]])
            // 
            
            var given=  np.sort(a, axis: 1);
            var expected=
                "array([[10, 20, 30],\n" +
                "       [40, 50, 60]])";
            Assert.AreEqual(expected, given.repr);
            var ai = np.argsort(a, axis: 1);
            given = ai;
             expected=
                "array([[0, 2, 1],\n" +
                "       [1, 2, 0]], dtype=int64)";
            Assert.AreEqual(expected, given.repr);
             given=  np.take_along_axis(a, ai, axis: 1);
             expected=
                "array([[10, 20, 30],\n" +
                "       [40, 50, 60]])";
            Assert.AreEqual(expected, given.repr);

            // The same works for max and min, if you expand the dimensions:
            
            // >>> np.expand_dims(np.max(a, axis=1), axis=1)
            // array([[30],
            //        [60]])
            // >>> ai = np.expand_dims(np.argmax(a, axis=1), axis=1)
            // >>> ai
            // array([[1],
            //        [0], dtype=int64)
            // >>> np.take_along_axis(a, ai, axis=1)
            // array([[30],
            //        [60]])
            // 

             given=  np.expand_dims(np.max(a, axis:new int[]{1}), axis:1);
             expected=
                "array([[30],\n" +
                "       [60]])";
            Assert.AreEqual(expected, given.repr);
             given=  ai = np.expand_dims(np.argmax(a, axis:1), axis:1);
             given=  ai;
             expected=
                "array([[1],\n" +
                "       [0]], dtype=int64)";
            Assert.AreEqual(expected, given.repr);
             given=  np.take_along_axis(a, ai, axis:1);
             expected=
                "array([[30],\n" +
                "       [60]])";
            Assert.AreEqual(expected, given.repr);

            // If we want to get the max and min at the same time, we can stack the
            // indices first
            
            // >>> ai_min = np.expand_dims(np.argmin(a, axis=1), axis=1)
            // >>> ai_max = np.expand_dims(np.argmax(a, axis=1), axis=1)
            // >>> ai = np.concatenate([ai_min, ai_max], axis=axis)
            // >> ai
            // array([[0, 1],
            //        [1, 0]], dtype=int64)
            // >>> np.take_along_axis(a, ai, axis=1)
            // array([[10, 30],
            //        [40, 60]])
            // 

             var ai_min = np.expand_dims(np.argmin(a, axis:1), axis:1);
             var  ai_max = np.expand_dims(np.argmax(a, axis:1), axis:1);
             given=  ai = np.concatenate(new[]{ai_min, ai_max}, axis: 1);
             expected=
                "array([[0, 1],\n" +
                "       [1, 0]], dtype=int64)";
            Assert.AreEqual(expected, given.repr);
             given=  np.take_along_axis(a, ai, axis:1);
             expected=
                "array([[10, 30],\n" +
                "       [40, 60]])";
            Assert.AreEqual(expected, given.repr);
        }
        
        
        [TestMethod]
        public void chooseTest()
        {
            // >>> choices = [[0, 1, 2, 3], [10, 11, 12, 13],
            // ...   [20, 21, 22, 23], [30, 31, 32, 33]]
            // >>> np.choose([2, 3, 1, 0], choices
            // ... # the first element of the result will be the first element of the
            // ... # third (2+1) "array" in choices, namely, 20; the second element
            // ... # will be the second element of the fourth (3+1) choice array, i.e.,
            // ... # 31, etc.
            // ... )
            // array([20, 31, 12,  3])
            // >>> np.choose([2, 4, 1, 0], choices, mode='clip') # 4 goes to 3 (4-1)
            // array([20, 31, 12,  3])
            // >>> # because there are 4 choice arrays
            // >>> np.choose([2, 4, 1, 0], choices, mode='wrap') # 4 goes to (4 mod 4)
            // array([20,  1, 12,  3])
            // >>> # i.e., 0
            // 
            
            #if TODO
            var given=  choices = [[0, 1, 2, 3], [10, 11, 12, 13],;
            var expected=
                "...   [20, 21, 22, 23], [30, 31, 32, 33]]";
            Assert.AreEqual(expected, given.repr);
             given=  np.choose({2, 3, 1, 0}, choices;
             expected=
                "... # the first element of the result will be the first element of the\n" +
                "... # third (2+1) "array" in choices, namely, 20; the second element\n" +
                "... # will be the second element of the fourth (3+1) choice array, i.e.,\n" +
                "... # 31, etc.\n" +
                "... )\n" +
                "array([20, 31, 12,  3])";
            Assert.AreEqual(expected, given.repr);
             given=  np.choose({2, 4, 1, 0}, choices, mode='clip') # 4 goes to 3 (4-1);
             expected=
                "array([20, 31, 12,  3])";
            Assert.AreEqual(expected, given.repr);
             given=  # because there are 4 choice arrays;
             given=  np.choose({2, 4, 1, 0}, choices, mode='wrap') # 4 goes to (4 mod 4);
             expected=
                "array([20,  1, 12,  3])";
            Assert.AreEqual(expected, given.repr);
             given=  # i.e., 0;
            #endif
            // A couple examples illustrating how choose broadcasts:
            
            // >>> a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]
            // >>> choices = [-10, 10]
            // >>> np.choose(a, choices)
            // array([[ 10, -10,  10],
            //        [-10,  10, -10],
            //        [ 10, -10,  10]])
            // 
            
            #if TODO
             given=  a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]];
             given=  choices = [-10, 10];
             given=  np.choose(a, choices);
             expected=
                "array([[ 10, -10,  10],\n" +
                "       [-10,  10, -10],\n" +
                "       [ 10, -10,  10]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> # With thanks to Anne Archibald
            // >>> a = np.array([0, 1]).reshape((2,1,1))
            // >>> c1 = np.array([1, 2, 3]).reshape((1,3,1))
            // >>> c2 = np.array([-1, -2, -3, -4, -5]).reshape((1,1,5))
            // >>> np.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2
            // array([[[ 1,  1,  1,  1,  1],
            //         [ 2,  2,  2,  2,  2],
            //         [ 3,  3,  3,  3,  3]],
            //        [[-1, -2, -3, -4, -5],
            //         [-1, -2, -3, -4, -5],
            //         [-1, -2, -3, -4, -5]]])
            // 
            
            #if TODO
             given=  # With thanks to Anne Archibald;
             given=  a = np.array({0, 1}).reshape((2,1,1));
             given=  c1 = np.array({1, 2, 3}).reshape((1,3,1));
             given=  c2 = np.array({-1, -2, -3, -4, -5}).reshape((1,1,5));
             given=  np.choose(a, (c1, c2)) # result is 2x3x5, res{0,:,:}=c1, res{1,:,:}=c2;
             expected=
                "array([[[ 1,  1,  1,  1,  1],\n" +
                "        [ 2,  2,  2,  2,  2],\n" +
                "        [ 3,  3,  3,  3,  3]],\n" +
                "       [[-1, -2, -3, -4, -5],\n" +
                "        [-1, -2, -3, -4, -5],\n" +
                "        [-1, -2, -3, -4, -5]]])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void compressTest()
        {
            // >>> a = np.array([[1, 2], [3, 4], [5, 6]])
            // >>> a
            // array([[1, 2],
            //        [3, 4],
            //        [5, 6]])
            // >>> np.compress([0, 1], a, axis=0)
            // array([[3, 4]])
            // >>> np.compress([False, True, True], a, axis=0)
            // array([[3, 4],
            //        [5, 6]])
            // >>> np.compress([False, True], a, axis=1)
            // array([[2],
            //        [4],
            //        [6]])
            // 
            
            #if TODO
            var given=  a = np.array({{1, 2}, {3, 4}, {5, 6}});
             given=  a;
            var expected=
                "array([[1, 2],\n" +
                "       [3, 4],\n" +
                "       [5, 6]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.compress({0, 1}, a, axis=0);
             expected=
                "array([[3, 4]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.compress({False, True, True}, a, axis=0);
             expected=
                "array([[3, 4],\n" +
                "       [5, 6]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.compress({False, True}, a, axis=1);
             expected=
                "array([[2],\n" +
                "       [4],\n" +
                "       [6]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Working on the flattened array does not return slices along an axis but
            // selects elements.
            
            // >>> np.compress([False, True], a)
            // array([2])
            // 
            
            #if TODO
             given=  np.compress({False, True}, a);
             expected=
                "array([2])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void diagonalTest()
        {
            // >>> a = np.arange(4).reshape(2,2)
            // >>> a
            // array([[0, 1],
            //        [2, 3]])
            // >>> a.diagonal()
            // array([0, 3])
            // >>> a.diagonal(1)
            // array([1])
            // 
            
            #if TODO
            var given=  a = np.arange(4).reshape(2,2);
             given=  a;
            var expected=
                "array([[0, 1],\n" +
                "       [2, 3]])";
            Assert.AreEqual(expected, given.repr);
             given=  a.diagonal();
             expected=
                "array([0, 3])";
            Assert.AreEqual(expected, given.repr);
             given=  a.diagonal(1);
             expected=
                "array([1])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // A 3-D example:
            
            // >>> a = np.arange(8).reshape(2,2,2); a
            // array([[[0, 1],
            //         [2, 3]],
            //        [[4, 5],
            //         [6, 7]]])
            // >>> a.diagonal(0, # Main diagonals of two arrays created by skipping
            // ...            0, # across the outer(left)-most axis last and
            // ...            1) # the "middle" (row) axis first.
            // array([[0, 6],
            //        [1, 7]])
            // 
            
            #if TODO
             given=  a = np.arange(8).reshape(2,2,2); a;
             expected=
                "array([[[0, 1],\n" +
                "        [2, 3]],\n" +
                "       [[4, 5],\n" +
                "        [6, 7]]])";
            Assert.AreEqual(expected, given.repr);
             given=  a.diagonal(0, # Main diagonals of two arrays created by skipping;
             expected=
                "...            0, # across the outer(left)-most axis last and\n" +
                "...            1) # the "middle" (row) axis first.\n" +
                "array([[0, 6],\n" +
                "       [1, 7]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // The sub-arrays whose main diagonals we just obtained; note that each
            // corresponds to fixing the right-most (column) axis, and that the
            // diagonals are “packed” in rows.
            
            // >>> a[:,:,0] # main diagonal is [0 6]
            // array([[0, 2],
            //        [4, 6]])
            // >>> a[:,:,1] # main diagonal is [1 7]
            // array([[1, 3],
            //        [5, 7]])
            // 
            
            #if TODO
             given=  a[:,:,0] # main diagonal is [0 6];
             expected=
                "array([[0, 2],\n" +
                "       [4, 6]])";
            Assert.AreEqual(expected, given.repr);
             given=  a[:,:,1] # main diagonal is [1 7];
             expected=
                "array([[1, 3],\n" +
                "       [5, 7]])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void selectTest()
        {
            // >>> x = np.arange(10)
            // >>> condlist = [x<3, x>5]
            // >>> choicelist = [x, x**2]
            // >>> np.select(condlist, choicelist)
            // array([ 0,  1,  2,  0,  0,  0, 36, 49, 64, 81])
            // 
            
            #if TODO
            var given=  x = np.arange(10);
             given=  condlist = [x<3, x>5];
             given=  choicelist = [x, x**2];
             given=  np.select(condlist, choicelist);
            var expected=
                "array([ 0,  1,  2,  0,  0,  0, 36, 49, 64, 81])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void placeTest()
        {
            // >>> arr = np.arange(6).reshape(2, 3)
            // >>> np.place(arr, arr>2, [44, 55])
            // >>> arr
            // array([[ 0,  1,  2],
            //        [44, 55, 44]])
            // 
            
            #if TODO
            var given=  arr = np.arange(6).reshape(2, 3);
             given=  np.place(arr, arr>2, {44, 55});
             given=  arr;
            var expected=
                "array([[ 0,  1,  2],\n" +
                "       [44, 55, 44]])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void putTest()
        {
            // >>> a = np.arange(5)
            // >>> np.put(a, [0, 2], [-44, -55])
            // >>> a
            // array([-44,   1, -55,   3,   4])
            // 
            
            #if TODO
            var given=  a = np.arange(5);
             given=  np.put(a, {0, 2}, {-44, -55});
             given=  a;
            var expected=
                "array([-44,   1, -55,   3,   4])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> a = np.arange(5)
            // >>> np.put(a, 22, -5, mode='clip')
            // >>> a
            // array([ 0,  1,  2,  3, -5])
            // 
            
            #if TODO
             given=  a = np.arange(5);
             given=  np.put(a, 22, -5, mode='clip');
             given=  a;
             expected=
                "array([ 0,  1,  2,  3, -5])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void put_along_axisTest()
        {
            // For this sample array
            
            // >>> a = np.array([[10, 30, 20], [60, 40, 50]])
            // 
            
            #if TODO
            var given=  a = np.array({{10, 30, 20}, {60, 40, 50}});
            #endif
            // We can replace the maximum values with:
            
            // >>> ai = np.expand_dims(np.argmax(a, axis=1), axis=1)
            // >>> ai
            // array([[1],
            //        [0]], dtype=int64)
            // >>> np.put_along_axis(a, ai, 99, axis=1)
            // >>> a
            // array([[10, 99, 20],
            //        [99, 40, 50]])
            // 
            
            #if TODO
             given=  ai = np.expand_dims(np.argmax(a, axis=1), axis=1);
             given=  ai;
            var expected=
                "array([[1],\n" +
                "       [0]], dtype=int64)";
            Assert.AreEqual(expected, given.repr);
             given=  np.put_along_axis(a, ai, 99, axis=1);
             given=  a;
             expected=
                "array([[10, 99, 20],\n" +
                "       [99, 40, 50]])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void putmaskTest()
        {
            // >>> x = np.arange(6).reshape(2, 3)
            // >>> np.putmask(x, x>2, x**2)
            // >>> x
            // array([[ 0,  1,  2],
            //        [ 9, 16, 25]])
            // 
            
            #if TODO
            var given=  x = np.arange(6).reshape(2, 3);
             given=  np.putmask(x, x>2, x**2);
             given=  x;
            var expected=
                "array([[ 0,  1,  2],\n" +
                "       [ 9, 16, 25]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // If values is smaller than a it is repeated:
            
            // >>> x = np.arange(5)
            // >>> np.putmask(x, x>1, [-33, -44])
            // >>> x
            // array([  0,   1, -33, -44, -33])
            // 
            
            #if TODO
             given=  x = np.arange(5);
             given=  np.putmask(x, x>1, {-33, -44});
             given=  x;
             expected=
                "array([  0,   1, -33, -44, -33])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void fill_diagonalTest()
        {
            // >>> a = np.zeros((3, 3), int)
            // >>> np.fill_diagonal(a, 5)
            // >>> a
            // array([[5, 0, 0],
            //        [0, 5, 0],
            //        [0, 0, 5]])
            // 
            
            #if TODO
            var given=  a = np.zeros((3, 3), int);
             given=  np.fill_diagonal(a, 5);
             given=  a;
            var expected=
                "array([[5, 0, 0],\n" +
                "       [0, 5, 0],\n" +
                "       [0, 0, 5]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // The same function can operate on a 4-D array:
            
            // >>> a = np.zeros((3, 3, 3, 3), int)
            // >>> np.fill_diagonal(a, 4)
            // 
            
            #if TODO
             given=  a = np.zeros((3, 3, 3, 3), int);
             given=  np.fill_diagonal(a, 4);
            #endif
            // We only show a few blocks for clarity:
            
            // >>> a[0, 0]
            // array([[4, 0, 0],
            //        [0, 0, 0],
            //        [0, 0, 0]])
            // >>> a[1, 1]
            // array([[0, 0, 0],
            //        [0, 4, 0],
            //        [0, 0, 0]])
            // >>> a[2, 2]
            // array([[0, 0, 0],
            //        [0, 0, 0],
            //        [0, 0, 4]])
            // 
            
            #if TODO
             given=  a[0, 0];
             expected=
                "array([[4, 0, 0],\n" +
                "       [0, 0, 0],\n" +
                "       [0, 0, 0]])";
            Assert.AreEqual(expected, given.repr);
             given=  a[1, 1];
             expected=
                "array([[0, 0, 0],\n" +
                "       [0, 4, 0],\n" +
                "       [0, 0, 0]])";
            Assert.AreEqual(expected, given.repr);
             given=  a[2, 2];
             expected=
                "array([[0, 0, 0],\n" +
                "       [0, 0, 0],\n" +
                "       [0, 0, 4]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // The wrap option affects only tall matrices:
            
            // >>> # tall matrices no wrap
            // >>> a = np.zeros((5, 3),int)
            // >>> fill_diagonal(a, 4)
            // >>> a
            // array([[4, 0, 0],
            //        [0, 4, 0],
            //        [0, 0, 4],
            //        [0, 0, 0],
            //        [0, 0, 0]])
            // 
            
            #if TODO
             given=  # tall matrices no wrap;
             given=  a = np.zeros((5, 3),int);
             given=  fill_diagonal(a, 4);
             given=  a;
             expected=
                "array([[4, 0, 0],\n" +
                "       [0, 4, 0],\n" +
                "       [0, 0, 4],\n" +
                "       [0, 0, 0],\n" +
                "       [0, 0, 0]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> # tall matrices wrap
            // >>> a = np.zeros((5, 3),int)
            // >>> fill_diagonal(a, 4, wrap=True)
            // >>> a
            // array([[4, 0, 0],
            //        [0, 4, 0],
            //        [0, 0, 4],
            //        [0, 0, 0],
            //        [4, 0, 0]])
            // 
            
            #if TODO
             given=  # tall matrices wrap;
             given=  a = np.zeros((5, 3),int);
             given=  fill_diagonal(a, 4, wrap=True);
             given=  a;
             expected=
                "array([[4, 0, 0],\n" +
                "       [0, 4, 0],\n" +
                "       [0, 0, 4],\n" +
                "       [0, 0, 0],\n" +
                "       [4, 0, 0]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> # wide matrices
            // >>> a = np.zeros((3, 5),int)
            // >>> fill_diagonal(a, 4, wrap=True)
            // >>> a
            // array([[4, 0, 0, 0, 0],
            //        [0, 4, 0, 0, 0],
            //        [0, 0, 4, 0, 0]])
            // 
            
            #if TODO
             given=  # wide matrices;
             given=  a = np.zeros((3, 5),int);
             given=  fill_diagonal(a, 4, wrap=True);
             given=  a;
             expected=
                "array([[4, 0, 0, 0, 0],\n" +
                "       [0, 4, 0, 0, 0],\n" +
                "       [0, 0, 4, 0, 0]])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void nditerTest()
        {
            // Here is how we might write an iter_add function, using the
            // Python iterator protocol:
            
            // def iter_add_py(x, y, out=None):
            //     addop = np.add
            //     it = np.nditer([x, y, out], [],
            //                 [['readonly'], ['readonly'], ['writeonly','allocate']])
            //     with it:
            //         for (a, b, c) in it:
            //             addop(a, b, out=c)
            //     return it.operands[2]
            // 
            
            #if TODO
            var expected=
                "def iter_add_py(x, y, out=None):\n" +
                "    addop = np.add\n" +
                "    it = np.nditer([x, y, out], [],\n" +
                "                [['readonly'], ['readonly'], ['writeonly','allocate']])\n" +
                "    with it:\n" +
                "        for (a, b, c) in it:\n" +
                "            addop(a, b, out=c)\n" +
                "    return it.operands[2]";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Here is the same function, but following the C-style pattern:
            
            // def iter_add(x, y, out=None):
            //     addop = np.add
            // 
            //     it = np.nditer([x, y, out], [],
            //                 [['readonly'], ['readonly'], ['writeonly','allocate']])
            //     with it:
            //         while not it.finished:
            //             addop(it[0], it[1], out=it[2])
            //             it.iternext()
            // 
            //         return it.operands[2]
            // 
            
            #if TODO
             expected=
                "def iter_add(x, y, out=None):\n" +
                "    addop = np.add\n" +
                "\n" +
                "    it = np.nditer([x, y, out], [],\n" +
                "                [['readonly'], ['readonly'], ['writeonly','allocate']])\n" +
                "    with it:\n" +
                "        while not it.finished:\n" +
                "            addop(it[0], it[1], out=it[2])\n" +
                "            it.iternext()\n" +
                "\n" +
                "        return it.operands[2]";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Here is an example outer product function:
            
            // def outer_it(x, y, out=None):
            //     mulop = np.multiply
            // 
            //     it = np.nditer([x, y, out], ['external_loop'],
            //             [['readonly'], ['readonly'], ['writeonly', 'allocate']],
            //             op_axes=[list(range(x.ndim)) + [-1] * y.ndim,
            //                      [-1] * x.ndim + list(range(y.ndim)),
            //                      None])
            //     with it:
            //         for (a, b, c) in it:
            //             mulop(a, b, out=c)
            //         return it.operands[2]
            // 
            // >>> a = np.arange(2)+1
            // >>> b = np.arange(3)+1
            // >>> outer_it(a,b)
            // array([[1, 2, 3],
            //        [2, 4, 6]])
            // 
            
            #if TODO
             expected=
                "def outer_it(x, y, out=None):\n" +
                "    mulop = np.multiply\n" +
                "\n" +
                "    it = np.nditer([x, y, out], ['external_loop'],\n" +
                "            [['readonly'], ['readonly'], ['writeonly', 'allocate']],\n" +
                "            op_axes=[list(range(x.ndim)) + [-1] * y.ndim,\n" +
                "                     [-1] * x.ndim + list(range(y.ndim)),\n" +
                "                     None])\n" +
                "    with it:\n" +
                "        for (a, b, c) in it:\n" +
                "            mulop(a, b, out=c)\n" +
                "        return it.operands[2]\n" +
                "";
            Assert.AreEqual(expected, given.repr);
            var given=  a = np.arange(2)+1;
             given=  b = np.arange(3)+1;
             given=  outer_it(a,b);
             expected=
                "array([[1, 2, 3],\n" +
                "       [2, 4, 6]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Here is an example function which operates like a “lambda” ufunc:
            
            // def luf(lamdaexpr, *args, **kwargs):
            //     "luf(lambdaexpr, op1, ..., opn, out=None, order='K', casting='safe', buffersize=0)"
            //     nargs = len(args)
            //     op = (kwargs.get('out',None),) + args
            //     it = np.nditer(op, ['buffered','external_loop'],
            //             [['writeonly','allocate','no_broadcast']] +
            //                             [['readonly','nbo','aligned']]*nargs,
            //             order=kwargs.get('order','K'),
            //             casting=kwargs.get('casting','safe'),
            //             buffersize=kwargs.get('buffersize',0))
            //     while not it.finished:
            //         it[0] = lamdaexpr(*it[1:])
            //         it.iternext()
            //         return it.operands[0]
            // 
            // >>> a = np.arange(5)
            // >>> b = np.ones(5)
            // >>> luf(lambda i,j:i*i + j/2, a, b)
            // array([  0.5,   1.5,   4.5,   9.5,  16.5])
            // 
            
            #if TODO
             expected=
                "def luf(lamdaexpr, *args, **kwargs):\n" +
                "    "luf(lambdaexpr, op1, ..., opn, out=None, order='K', casting='safe', buffersize=0)"\n" +
                "    nargs = len(args)\n" +
                "    op = (kwargs.get('out',None),) + args\n" +
                "    it = np.nditer(op, ['buffered','external_loop'],\n" +
                "            [['writeonly','allocate','no_broadcast']] +\n" +
                "                            [['readonly','nbo','aligned']]*nargs,\n" +
                "            order=kwargs.get('order','K'),\n" +
                "            casting=kwargs.get('casting','safe'),\n" +
                "            buffersize=kwargs.get('buffersize',0))\n" +
                "    while not it.finished:\n" +
                "        it[0] = lamdaexpr(*it[1:])\n" +
                "        it.iternext()\n" +
                "        return it.operands[0]\n" +
                "";
            Assert.AreEqual(expected, given.repr);
             given=  a = np.arange(5);
             given=  b = np.ones(5);
             given=  luf(lambda i,j:i*i + j/2, a, b);
             expected=
                "array([  0.5,   1.5,   4.5,   9.5,  16.5])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // If operand flags “writeonly” or “readwrite” are used the operands may
            // be views into the original data with the WRITEBACKIFCOPY flag. In this case
            // nditer must be used as a context manager or the nditer.close
            // method must be called before using the result. The temporary
            // data will be written back to the original data when the __exit__
            // function is called but not before:
            
            // >>> a = np.arange(6, dtype='i4')[::-2]
            // >>> with nditer(a, [],
            // ...        [['writeonly', 'updateifcopy']],
            // ...        casting='unsafe',
            // ...        op_dtypes=[np.dtype('f4')]) as i:
            // ...    x = i.operands[0]
            // ...    x[:] = [-1, -2, -3]
            // ...    # a still unchanged here
            // >>> a, x
            // array([-1, -2, -3]), array([-1, -2, -3])
            // 
            
            #if TODO
             given=  a = np.arange(6, dtype='i4'){::-2};
             given=  with nditer(a, [],;
             expected=
                "...        [['writeonly', 'updateifcopy']],\n" +
                "...        casting='unsafe',\n" +
                "...        op_dtypes=[np.dtype('f4')]) as i:\n" +
                "...    x = i.operands[0]\n" +
                "...    x[:] = [-1, -2, -3]\n" +
                "...    # a still unchanged here";
            Assert.AreEqual(expected, given.repr);
             given=  a, x;
             expected=
                "array([-1, -2, -3]), array([-1, -2, -3])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // It is important to note that once the iterator is exited, dangling
            // references (like x in the example) may or may not share data with
            // the original data a. If writeback semantics were active, i.e. if
            // x.base.flags.writebackifcopy is True, then exiting the iterator
            // will sever the connection between x and a, writing to x will
            // no longer write to a. If writeback semantics are not active, then
            // x.data will still point at some part of a.data, and writing to
            // one will affect the other.
            
            // Methods
            
        }
        
        
        [TestMethod]
        public void ndenumerateTest()
        {
            // >>> a = np.array([[1, 2], [3, 4]])
            // >>> for index, x in np.ndenumerate(a):
            // ...     print(index, x)
            // (0, 0) 1
            // (0, 1) 2
            // (1, 0) 3
            // (1, 1) 4
            // 
            
            #if TODO
            var given=  a = np.array({{1, 2}, {3, 4}});
             given=  for index, x in np.ndenumerate(a):;
            var expected=
                "...     print(index, x)\n" +
                "(0, 0) 1\n" +
                "(0, 1) 2\n" +
                "(1, 0) 3\n" +
                "(1, 1) 4";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Methods
            
        }
        
        
        [TestMethod]
        public void ndindexTest()
        {
            // >>> for index in np.ndindex(3, 2, 1):
            // ...     print(index)
            // (0, 0, 0)
            // (0, 1, 0)
            // (1, 0, 0)
            // (1, 1, 0)
            // (2, 0, 0)
            // (2, 1, 0)
            // 
            
            #if TODO
            var given=  for index in np.ndindex(3, 2, 1):;
            var expected=
                "...     print(index)\n" +
                "(0, 0, 0)\n" +
                "(0, 1, 0)\n" +
                "(1, 0, 0)\n" +
                "(1, 1, 0)\n" +
                "(2, 0, 0)\n" +
                "(2, 1, 0)";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Methods
            
        }
        
        
        [TestMethod]
        public void nested_itersTest()
        {
            // Basic usage. Note how y is the “flattened” version of
            // [a[:, 0, :], a[:, 1, 0], a[:, 2, :]] since we specified
            // the first iter’s axes as [1]
            
            // >>> a = np.arange(12).reshape(2, 3, 2)
            // >>> i, j = np.nested_iters(a, [[1], [0, 2]], flags=["multi_index"])
            // >>> for x in i:
            // ...      print(i.multi_index)
            // ...      for y in j:
            // ...          print('', j.multi_index, y)
            // 
            
            #if TODO
            var given=  a = np.arange(12).reshape(2, 3, 2);
             given=  i, j = np.nested_iters(a, {{1}, {0, 2}}, flags={"multi_index"});
             given=  for x in i:;
            var expected=
                "...      print(i.multi_index)\n" +
                "...      for y in j:\n" +
                "...          print('', j.multi_index, y)";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void flatiterTest()
        {
            // >>> x = np.arange(6).reshape(2, 3)
            // >>> fl = x.flat
            // >>> type(fl)
            // <type 'numpy.flatiter'>
            // >>> for item in fl:
            // ...     print(item)
            // ...
            // 0
            // 1
            // 2
            // 3
            // 4
            // 5
            // 
            
            #if TODO
            var given=  x = np.arange(6).reshape(2, 3);
             given=  fl = x.flat;
             given=  type(fl);
            var expected=
                "<type 'numpy.flatiter'>";
            Assert.AreEqual(expected, given.repr);
             given=  for item in fl:;
             expected=
                "...     print(item)\n" +
                "...\n" +
                "0\n" +
                "1\n" +
                "2\n" +
                "3\n" +
                "4\n" +
                "5";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> fl[2:4]
            // array([2, 3])
            // 
            
            #if TODO
             given=  fl[2:4];
             expected=
                "array([2, 3])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> x = np.arange(5)
            // >>> fl = x.flat
            // >>> fl.base is x
            // True
            // 
            
            #if TODO
             given=  x = np.arange(5);
             given=  fl = x.flat;
             given=  fl.base is x;
             expected=
                "True";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Methods
            
        }
        
        
        [TestMethod]
        public void ArrayteratorTest()
        {
            // >>> a = np.arange(3 * 4 * 5 * 6).reshape(3, 4, 5, 6)
            // >>> a_itor = np.lib.Arrayterator(a, 2)
            // >>> a_itor.shape
            // (3, 4, 5, 6)
            // 
            
            #if TODO
            var given=  a = np.arange(3 * 4 * 5 * 6).reshape(3, 4, 5, 6);
             given=  a_itor = np.lib.Arrayterator(a, 2);
             given=  a_itor.shape;
            var expected=
                "(3, 4, 5, 6)";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Now we can iterate over a_itor, and it will return arrays of size
            // two. Since buf_size was smaller than any dimension, the first
            // dimension will be iterated over first:
            
            // >>> for subarr in a_itor:
            // ...     if not subarr.all():
            // ...         print(subarr, subarr.shape)
            // ...
            // [[[[0 1]]]] (1, 1, 1, 2)
            // 
            
            #if TODO
             given=  for subarr in a_itor:;
             expected=
                "...     if not subarr.all():\n" +
                "...         print(subarr, subarr.shape)\n" +
                "...\n" +
                "[[[[0 1]]]] (1, 1, 1, 2)";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
    }
}
