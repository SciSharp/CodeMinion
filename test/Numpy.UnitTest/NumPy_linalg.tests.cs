// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Numpy.Models;

using Microsoft.VisualStudio.TestTools.UnitTesting;
using Assert = NUnit.Framework.Assert;

namespace Numpy.UnitTest
{
    [TestClass]
    public class NumPy_linalgTest : BaseTestCase
    {
        
        [TestMethod]
        public void dotTest()
        {
            // >>> np.dot(3, 4)
            // 12
            // 
            
            #if TODO
            var given=  np.dot(3, 4);
            var expected=
                "12";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Neither argument is complex-conjugated:
            
            // >>> np.dot([2j, 3j], [2j, 3j])
            // (-13+0j)
            // 
            
            #if TODO
             given=  np.dot({2j, 3j}, {2j, 3j});
             expected=
                "(-13+0j)";
            Assert.AreEqual(expected, given.repr);
            #endif
            // For 2-D arrays it is the matrix product:
            
            // >>> a = [[1, 0], [0, 1]]
            // >>> b = [[4, 1], [2, 2]]
            // >>> np.dot(a, b)
            // array([[4, 1],
            //        [2, 2]])
            // 
            
            #if TODO
             given=  a = [[1, 0], [0, 1]];
             given=  b = [[4, 1], [2, 2]];
             given=  np.dot(a, b);
             expected=
                "array([[4, 1],\n" +
                "       [2, 2]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> a = np.arange(3*4*5*6).reshape((3,4,5,6))
            // >>> b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))
            // >>> np.dot(a, b)[2,3,2,1,2,2]
            // 499128
            // >>> sum(a[2,3,2,:] * b[1,2,:,2])
            // 499128
            // 
            
            #if TODO
             given=  a = np.arange(3*4*5*6).reshape((3,4,5,6));
             given=  b = np.arange(3*4*5*6){::-1}.reshape((5,4,6,3));
             given=  np.dot(a, b){2,3,2,1,2,2};
             expected=
                "499128";
            Assert.AreEqual(expected, given.repr);
             given=  sum(a[2,3,2,:] * b[1,2,:,2]);
             expected=
                "499128";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void multi_dotTest()
        {
            // multi_dot allows you to write:
            
            // >>> from numpy.linalg import multi_dot
            // >>> # Prepare some data
            // >>> A = np.random.random(10000, 100)
            // >>> B = np.random.random(100, 1000)
            // >>> C = np.random.random(1000, 5)
            // >>> D = np.random.random(5, 333)
            // >>> # the actual dot multiplication
            // >>> multi_dot([A, B, C, D])
            // 
            
            #if TODO
            var given=  from numpy.linalg import multi_dot;
             given=  # Prepare some data;
             given=  A = np.random.random(10000, 100);
             given=  B = np.random.random(100, 1000);
             given=  C = np.random.random(1000, 5);
             given=  D = np.random.random(5, 333);
             given=  # the actual dot multiplication;
             given=  multi_dot([A, B, C, D]);
            #endif
            // instead of:
            
            // >>> np.dot(np.dot(np.dot(A, B), C), D)
            // >>> # or
            // >>> A.dot(B).dot(C).dot(D)
            // 
            
            #if TODO
             given=  np.dot(np.dot(np.dot(A, B), C), D);
             given=  # or;
             given=  A.dot(B).dot(C).dot(D);
            #endif
        }
        
        
        [TestMethod]
        public void vdotTest()
        {
            // >>> a = np.array([1+2j,3+4j])
            // >>> b = np.array([5+6j,7+8j])
            // >>> np.vdot(a, b)
            // (70-8j)
            // >>> np.vdot(b, a)
            // (70+8j)
            // 
            
            #if TODO
            var given=  a = np.array({1+2j,3+4j});
             given=  b = np.array({5+6j,7+8j});
             given=  np.vdot(a, b);
            var expected=
                "(70-8j)";
            Assert.AreEqual(expected, given.repr);
             given=  np.vdot(b, a);
             expected=
                "(70+8j)";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Note that higher-dimensional arrays are flattened!
            
            // >>> a = np.array([[1, 4], [5, 6]])
            // >>> b = np.array([[4, 1], [2, 2]])
            // >>> np.vdot(a, b)
            // 30
            // >>> np.vdot(b, a)
            // 30
            // >>> 1*4 + 4*1 + 5*2 + 6*2
            // 30
            // 
            
            #if TODO
             given=  a = np.array({{1, 4}, {5, 6}});
             given=  b = np.array({{4, 1}, {2, 2}});
             given=  np.vdot(a, b);
             expected=
                "30";
            Assert.AreEqual(expected, given.repr);
             given=  np.vdot(b, a);
             expected=
                "30";
            Assert.AreEqual(expected, given.repr);
             given=  1*4 + 4*1 + 5*2 + 6*2;
             expected=
                "30";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void innerTest()
        {
            // Ordinary inner product for vectors:
            
            // >>> a = np.array([1,2,3])
            // >>> b = np.array([0,1,0])
            // >>> np.inner(a, b)
            // 2
            // 
            
            #if TODO
            var given=  a = np.array({1,2,3});
             given=  b = np.array({0,1,0});
             given=  np.inner(a, b);
            var expected=
                "2";
            Assert.AreEqual(expected, given.repr);
            #endif
            // A multidimensional example:
            
            // >>> a = np.arange(24).reshape((2,3,4))
            // >>> b = np.arange(4)
            // >>> np.inner(a, b)
            // array([[ 14,  38,  62],
            //        [ 86, 110, 134]])
            // 
            
            #if TODO
             given=  a = np.arange(24).reshape((2,3,4));
             given=  b = np.arange(4);
             given=  np.inner(a, b);
             expected=
                "array([[ 14,  38,  62],\n" +
                "       [ 86, 110, 134]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // An example where b is a scalar:
            
            // >>> np.inner(np.eye(2), 7)
            // array([[ 7.,  0.],
            //        [ 0.,  7.]])
            // 
            
            #if TODO
             given=  np.inner(np.eye(2), 7);
             expected=
                "array([[ 7.,  0.],\n" +
                "       [ 0.,  7.]])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void outerTest()
        {
            // Make a (very coarse) grid for computing a Mandelbrot set:
            
            // >>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
            // >>> rl
            // array([[-2., -1.,  0.,  1.,  2.],
            //        [-2., -1.,  0.,  1.,  2.],
            //        [-2., -1.,  0.,  1.,  2.],
            //        [-2., -1.,  0.,  1.,  2.],
            //        [-2., -1.,  0.,  1.,  2.]])
            // >>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
            // >>> im
            // array([[ 0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j],
            //        [ 0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j],
            //        [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],
            //        [ 0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j],
            //        [ 0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j]])
            // >>> grid = rl + im
            // >>> grid
            // array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
            //        [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
            //        [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
            //        [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
            //        [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])
            // 
            
            #if TODO
            var given=  rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5));
             given=  rl;
            var expected=
                "array([[-2., -1.,  0.,  1.,  2.],\n" +
                "       [-2., -1.,  0.,  1.,  2.],\n" +
                "       [-2., -1.,  0.,  1.,  2.],\n" +
                "       [-2., -1.,  0.,  1.,  2.],\n" +
                "       [-2., -1.,  0.,  1.,  2.]])";
            Assert.AreEqual(expected, given.repr);
             given=  im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)));
             given=  im;
             expected=
                "array([[ 0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j,  0.+2.j],\n" +
                "       [ 0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j,  0.+1.j],\n" +
                "       [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],\n" +
                "       [ 0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j,  0.-1.j],\n" +
                "       [ 0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j,  0.-2.j]])";
            Assert.AreEqual(expected, given.repr);
             given=  grid = rl + im;
             given=  grid;
             expected=
                "array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n" +
                "       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n" +
                "       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n" +
                "       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n" +
                "       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // An example using a “vector” of letters:
            
            // >>> x = np.array(['a', 'b', 'c'], dtype=object)
            // >>> np.outer(x, [1, 2, 3])
            // array([[a, aa, aaa],
            //        [b, bb, bbb],
            //        [c, cc, ccc]], dtype=object)
            // 
            
            #if TODO
             given=  x = np.array({'a', 'b', 'c'}, dtype=object);
             given=  np.outer(x, {1, 2, 3});
             expected=
                "array([[a, aa, aaa],\n" +
                "       [b, bb, bbb],\n" +
                "       [c, cc, ccc]], dtype=object)";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void matmulTest()
        {
            // For 2-D arrays it is the matrix product:
            
            // >>> a = np.array([[1, 0],
            // ...               [0, 1]])
            // >>> b = np.array([[4, 1], 
            // ...               [2, 2]]
            // >>> np.matmul(a, b)
            // array([[4, 1],
            //        [2, 2]])
            // 
            
            #if TODO
            var given=  a = np.array({{1, 0},;
            var expected=
                "...               [0, 1]])";
            Assert.AreEqual(expected, given.repr);
             given=  b = np.array({{4, 1}, ;
             expected=
                "...               [2, 2]]";
            Assert.AreEqual(expected, given.repr);
             given=  np.matmul(a, b);
             expected=
                "array([[4, 1],\n" +
                "       [2, 2]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // For 2-D mixed with 1-D, the result is the usual.
            
            // >>> a = np.array([[1, 0],
            // ...               [0, 1]]
            // >>> b = np.array([1, 2])
            // >>> np.matmul(a, b)
            // array([1, 2])
            // >>> np.matmul(b, a)
            // array([1, 2])
            // 
            
            #if TODO
             given=  a = np.array({{1, 0},;
             expected=
                "...               [0, 1]]";
            Assert.AreEqual(expected, given.repr);
             given=  b = np.array({1, 2});
             given=  np.matmul(a, b);
             expected=
                "array([1, 2])";
            Assert.AreEqual(expected, given.repr);
             given=  np.matmul(b, a);
             expected=
                "array([1, 2])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Broadcasting is conventional for stacks of arrays
            
            // >>> a = np.arange(2 * 2 * 4).reshape((2, 2, 4))
            // >>> b = np.arange(2 * 2 * 4).reshape((2, 4, 2))
            // >>> np.matmul(a,b).shape
            // (2, 2, 2)
            // >>> np.matmul(a, b)[0, 1, 1]
            // 98
            // >>> sum(a[0, 1, :] * b[0 , :, 1])
            // 98
            // 
            
            #if TODO
             given=  a = np.arange(2 * 2 * 4).reshape((2, 2, 4));
             given=  b = np.arange(2 * 2 * 4).reshape((2, 4, 2));
             given=  np.matmul(a,b).shape;
             expected=
                "(2, 2, 2)";
            Assert.AreEqual(expected, given.repr);
             given=  np.matmul(a, b){0, 1, 1};
             expected=
                "98";
            Assert.AreEqual(expected, given.repr);
             given=  sum(a[0, 1, :] * b[0 , :, 1]);
             expected=
                "98";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Vector, vector returns the scalar inner product, but neither argument
            // is complex-conjugated:
            
            // >>> np.matmul([2j, 3j], [2j, 3j])
            // (-13+0j)
            // 
            
            #if TODO
             given=  np.matmul({2j, 3j}, {2j, 3j});
             expected=
                "(-13+0j)";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Scalar multiplication raises an error.
            
            // >>> np.matmul([1,2], 3)
            // Traceback (most recent call last):
            // ...
            // ValueError: matmul: Input operand 1 does not have enough dimensions ...
            // 
            
            #if TODO
             given=  np.matmul({1,2}, 3);
             expected=
                "Traceback (most recent call last):\n" +
                "...\n" +
                "ValueError: matmul: Input operand 1 does not have enough dimensions ...";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void tensordotTest()
        {
            // A “traditional” example:
            
            // >>> a = np.arange(60.).reshape(3,4,5)
            // >>> b = np.arange(24.).reshape(4,3,2)
            // >>> c = np.tensordot(a,b, axes=([1,0],[0,1]))
            // >>> c.shape
            // (5, 2)
            // >>> c
            // array([[ 4400.,  4730.],
            //        [ 4532.,  4874.],
            //        [ 4664.,  5018.],
            //        [ 4796.,  5162.],
            //        [ 4928.,  5306.]])
            // >>> # A slower but equivalent way of computing the same...
            // >>> d = np.zeros((5,2))
            // >>> for i in range(5):
            // ...   for j in range(2):
            // ...     for k in range(3):
            // ...       for n in range(4):
            // ...         d[i,j] += a[k,n,i] * b[n,k,j]
            // >>> c == d
            // array([[ True,  True],
            //        [ True,  True],
            //        [ True,  True],
            //        [ True,  True],
            //        [ True,  True]])
            // 
            
            #if TODO
            var given=  a = np.arange(60.).reshape(3,4,5);
             given=  b = np.arange(24.).reshape(4,3,2);
             given=  c = np.tensordot(a,b, axes=({1,0},{0,1}));
             given=  c.shape;
            var expected=
                "(5, 2)";
            Assert.AreEqual(expected, given.repr);
             given=  c;
             expected=
                "array([[ 4400.,  4730.],\n" +
                "       [ 4532.,  4874.],\n" +
                "       [ 4664.,  5018.],\n" +
                "       [ 4796.,  5162.],\n" +
                "       [ 4928.,  5306.]])";
            Assert.AreEqual(expected, given.repr);
             given=  # A slower but equivalent way of computing the same...;
             given=  d = np.zeros((5,2));
             given=  for i in range(5):;
             expected=
                "...   for j in range(2):\n" +
                "...     for k in range(3):\n" +
                "...       for n in range(4):\n" +
                "...         d[i,j] += a[k,n,i] * b[n,k,j]";
            Assert.AreEqual(expected, given.repr);
             given=  c == d;
             expected=
                "array([[ True,  True],\n" +
                "       [ True,  True],\n" +
                "       [ True,  True],\n" +
                "       [ True,  True],\n" +
                "       [ True,  True]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // An extended example taking advantage of the overloading of + and *:
            
            // >>> a = np.array(range(1, 9))
            // >>> a.shape = (2, 2, 2)
            // >>> A = np.array(('a', 'b', 'c', 'd'), dtype=object)
            // >>> A.shape = (2, 2)
            // >>> a; A
            // array([[[1, 2],
            //         [3, 4]],
            //        [[5, 6],
            //         [7, 8]]])
            // array([[a, b],
            //        [c, d]], dtype=object)
            // 
            
            #if TODO
             given=  a = np.array(range(1, 9));
             given=  a.shape = (2, 2, 2);
             given=  A = np.array(('a', 'b', 'c', 'd'), dtype=object);
             given=  A.shape = (2, 2);
             given=  a; A;
             expected=
                "array([[[1, 2],\n" +
                "        [3, 4]],\n" +
                "       [[5, 6],\n" +
                "        [7, 8]]])\n" +
                "array([[a, b],\n" +
                "       [c, d]], dtype=object)";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.tensordot(a, A) # third argument default is 2 for double-contraction
            // array([abbcccdddd, aaaaabbbbbbcccccccdddddddd], dtype=object)
            // 
            
            #if TODO
             given=  np.tensordot(a, A) # third argument default is 2 for double-contraction;
             expected=
                "array([abbcccdddd, aaaaabbbbbbcccccccdddddddd], dtype=object)";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.tensordot(a, A, 1)
            // array([[[acc, bdd],
            //         [aaacccc, bbbdddd]],
            //        [[aaaaacccccc, bbbbbdddddd],
            //         [aaaaaaacccccccc, bbbbbbbdddddddd]]], dtype=object)
            // 
            
            #if TODO
             given=  np.tensordot(a, A, 1);
             expected=
                "array([[[acc, bdd],\n" +
                "        [aaacccc, bbbdddd]],\n" +
                "       [[aaaaacccccc, bbbbbdddddd],\n" +
                "        [aaaaaaacccccccc, bbbbbbbdddddddd]]], dtype=object)";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.tensordot(a, A, 0) # tensor product (result too long to incl.)
            // array([[[[[a, b],
            //           [c, d]],
            //           ...
            // 
            
            #if TODO
             given=  np.tensordot(a, A, 0) # tensor product (result too long to incl.);
             expected=
                "array([[[[[a, b],\n" +
                "          [c, d]],\n" +
                "          ...";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.tensordot(a, A, (0, 1))
            // array([[[abbbbb, cddddd],
            //         [aabbbbbb, ccdddddd]],
            //        [[aaabbbbbbb, cccddddddd],
            //         [aaaabbbbbbbb, ccccdddddddd]]], dtype=object)
            // 
            
            #if TODO
             given=  np.tensordot(a, A, (0, 1));
             expected=
                "array([[[abbbbb, cddddd],\n" +
                "        [aabbbbbb, ccdddddd]],\n" +
                "       [[aaabbbbbbb, cccddddddd],\n" +
                "        [aaaabbbbbbbb, ccccdddddddd]]], dtype=object)";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.tensordot(a, A, (2, 1))
            // array([[[abb, cdd],
            //         [aaabbbb, cccdddd]],
            //        [[aaaaabbbbbb, cccccdddddd],
            //         [aaaaaaabbbbbbbb, cccccccdddddddd]]], dtype=object)
            // 
            
            #if TODO
             given=  np.tensordot(a, A, (2, 1));
             expected=
                "array([[[abb, cdd],\n" +
                "        [aaabbbb, cccdddd]],\n" +
                "       [[aaaaabbbbbb, cccccdddddd],\n" +
                "        [aaaaaaabbbbbbbb, cccccccdddddddd]]], dtype=object)";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.tensordot(a, A, ((0, 1), (0, 1)))
            // array([abbbcccccddddddd, aabbbbccccccdddddddd], dtype=object)
            // 
            
            #if TODO
             given=  np.tensordot(a, A, ((0, 1), (0, 1)));
             expected=
                "array([abbbcccccddddddd, aabbbbccccccdddddddd], dtype=object)";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.tensordot(a, A, ((2, 1), (1, 0)))
            // array([acccbbdddd, aaaaacccccccbbbbbbdddddddd], dtype=object)
            // 
            
            #if TODO
             given=  np.tensordot(a, A, ((2, 1), (1, 0)));
             expected=
                "array([acccbbdddd, aaaaacccccccbbbbbbdddddddd], dtype=object)";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void einsumTest()
        {
            // >>> a = np.arange(25).reshape(5,5)
            // >>> b = np.arange(5)
            // >>> c = np.arange(6).reshape(2,3)
            // 
            
            #if TODO
            var given=  a = np.arange(25).reshape(5,5);
             given=  b = np.arange(5);
             given=  c = np.arange(6).reshape(2,3);
            #endif
            // Trace of a matrix:
            
            // >>> np.einsum('ii', a)
            // 60
            // >>> np.einsum(a, [0,0])
            // 60
            // >>> np.trace(a)
            // 60
            // 
            
            #if TODO
             given=  np.einsum('ii', a);
            var expected=
                "60";
            Assert.AreEqual(expected, given.repr);
             given=  np.einsum(a, {0,0});
             expected=
                "60";
            Assert.AreEqual(expected, given.repr);
             given=  np.trace(a);
             expected=
                "60";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Extract the diagonal (requires explicit form):
            
            // >>> np.einsum('ii->i', a)
            // array([ 0,  6, 12, 18, 24])
            // >>> np.einsum(a, [0,0], [0])
            // array([ 0,  6, 12, 18, 24])
            // >>> np.diag(a)
            // array([ 0,  6, 12, 18, 24])
            // 
            
            #if TODO
             given=  np.einsum('ii->i', a);
             expected=
                "array([ 0,  6, 12, 18, 24])";
            Assert.AreEqual(expected, given.repr);
             given=  np.einsum(a, {0,0}, {0});
             expected=
                "array([ 0,  6, 12, 18, 24])";
            Assert.AreEqual(expected, given.repr);
             given=  np.diag(a);
             expected=
                "array([ 0,  6, 12, 18, 24])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Sum over an axis (requires explicit form):
            
            // >>> np.einsum('ij->i', a)
            // array([ 10,  35,  60,  85, 110])
            // >>> np.einsum(a, [0,1], [0])
            // array([ 10,  35,  60,  85, 110])
            // >>> np.sum(a, axis=1)
            // array([ 10,  35,  60,  85, 110])
            // 
            
            #if TODO
             given=  np.einsum('ij->i', a);
             expected=
                "array([ 10,  35,  60,  85, 110])";
            Assert.AreEqual(expected, given.repr);
             given=  np.einsum(a, {0,1}, {0});
             expected=
                "array([ 10,  35,  60,  85, 110])";
            Assert.AreEqual(expected, given.repr);
             given=  np.sum(a, axis=1);
             expected=
                "array([ 10,  35,  60,  85, 110])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // For higher dimensional arrays summing a single axis can be done with ellipsis:
            
            // >>> np.einsum('...j->...', a)
            // array([ 10,  35,  60,  85, 110])
            // >>> np.einsum(a, [Ellipsis,1], [Ellipsis])
            // array([ 10,  35,  60,  85, 110])
            // 
            
            #if TODO
             given=  np.einsum('...j->...', a);
             expected=
                "array([ 10,  35,  60,  85, 110])";
            Assert.AreEqual(expected, given.repr);
             given=  np.einsum(a, {Ellipsis,1}, {Ellipsis});
             expected=
                "array([ 10,  35,  60,  85, 110])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Compute a matrix transpose, or reorder any number of axes:
            
            // >>> np.einsum('ji', c)
            // array([[0, 3],
            //        [1, 4],
            //        [2, 5]])
            // >>> np.einsum('ij->ji', c)
            // array([[0, 3],
            //        [1, 4],
            //        [2, 5]])
            // >>> np.einsum(c, [1,0])
            // array([[0, 3],
            //        [1, 4],
            //        [2, 5]])
            // >>> np.transpose(c)
            // array([[0, 3],
            //        [1, 4],
            //        [2, 5]])
            // 
            
            #if TODO
             given=  np.einsum('ji', c);
             expected=
                "array([[0, 3],\n" +
                "       [1, 4],\n" +
                "       [2, 5]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.einsum('ij->ji', c);
             expected=
                "array([[0, 3],\n" +
                "       [1, 4],\n" +
                "       [2, 5]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.einsum(c, {1,0});
             expected=
                "array([[0, 3],\n" +
                "       [1, 4],\n" +
                "       [2, 5]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.transpose(c);
             expected=
                "array([[0, 3],\n" +
                "       [1, 4],\n" +
                "       [2, 5]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Vector inner products:
            
            // >>> np.einsum('i,i', b, b)
            // 30
            // >>> np.einsum(b, [0], b, [0])
            // 30
            // >>> np.inner(b,b)
            // 30
            // 
            
            #if TODO
             given=  np.einsum('i,i', b, b);
             expected=
                "30";
            Assert.AreEqual(expected, given.repr);
             given=  np.einsum(b, {0}, b, {0});
             expected=
                "30";
            Assert.AreEqual(expected, given.repr);
             given=  np.inner(b,b);
             expected=
                "30";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Matrix vector multiplication:
            
            // >>> np.einsum('ij,j', a, b)
            // array([ 30,  80, 130, 180, 230])
            // >>> np.einsum(a, [0,1], b, [1])
            // array([ 30,  80, 130, 180, 230])
            // >>> np.dot(a, b)
            // array([ 30,  80, 130, 180, 230])
            // >>> np.einsum('...j,j', a, b)
            // array([ 30,  80, 130, 180, 230])
            // 
            
            #if TODO
             given=  np.einsum('ij,j', a, b);
             expected=
                "array([ 30,  80, 130, 180, 230])";
            Assert.AreEqual(expected, given.repr);
             given=  np.einsum(a, {0,1}, b, {1});
             expected=
                "array([ 30,  80, 130, 180, 230])";
            Assert.AreEqual(expected, given.repr);
             given=  np.dot(a, b);
             expected=
                "array([ 30,  80, 130, 180, 230])";
            Assert.AreEqual(expected, given.repr);
             given=  np.einsum('...j,j', a, b);
             expected=
                "array([ 30,  80, 130, 180, 230])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Broadcasting and scalar multiplication:
            
            // >>> np.einsum('..., ...', 3, c)
            // array([[ 0,  3,  6],
            //        [ 9, 12, 15]])
            // >>> np.einsum(',ij', 3, c)
            // array([[ 0,  3,  6],
            //        [ 9, 12, 15]])
            // >>> np.einsum(3, [Ellipsis], c, [Ellipsis])
            // array([[ 0,  3,  6],
            //        [ 9, 12, 15]])
            // >>> np.multiply(3, c)
            // array([[ 0,  3,  6],
            //        [ 9, 12, 15]])
            // 
            
            #if TODO
             given=  np.einsum('..., ...', 3, c);
             expected=
                "array([[ 0,  3,  6],\n" +
                "       [ 9, 12, 15]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.einsum(',ij', 3, c);
             expected=
                "array([[ 0,  3,  6],\n" +
                "       [ 9, 12, 15]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.einsum(3, {Ellipsis}, c, {Ellipsis});
             expected=
                "array([[ 0,  3,  6],\n" +
                "       [ 9, 12, 15]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.multiply(3, c);
             expected=
                "array([[ 0,  3,  6],\n" +
                "       [ 9, 12, 15]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Vector outer product:
            
            // >>> np.einsum('i,j', np.arange(2)+1, b)
            // array([[0, 1, 2, 3, 4],
            //        [0, 2, 4, 6, 8]])
            // >>> np.einsum(np.arange(2)+1, [0], b, [1])
            // array([[0, 1, 2, 3, 4],
            //        [0, 2, 4, 6, 8]])
            // >>> np.outer(np.arange(2)+1, b)
            // array([[0, 1, 2, 3, 4],
            //        [0, 2, 4, 6, 8]])
            // 
            
            #if TODO
             given=  np.einsum('i,j', np.arange(2)+1, b);
             expected=
                "array([[0, 1, 2, 3, 4],\n" +
                "       [0, 2, 4, 6, 8]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.einsum(np.arange(2)+1, {0}, b, {1});
             expected=
                "array([[0, 1, 2, 3, 4],\n" +
                "       [0, 2, 4, 6, 8]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.outer(np.arange(2)+1, b);
             expected=
                "array([[0, 1, 2, 3, 4],\n" +
                "       [0, 2, 4, 6, 8]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Tensor contraction:
            
            // >>> a = np.arange(60.).reshape(3,4,5)
            // >>> b = np.arange(24.).reshape(4,3,2)
            // >>> np.einsum('ijk,jil->kl', a, b)
            // array([[ 4400.,  4730.],
            //        [ 4532.,  4874.],
            //        [ 4664.,  5018.],
            //        [ 4796.,  5162.],
            //        [ 4928.,  5306.]])
            // >>> np.einsum(a, [0,1,2], b, [1,0,3], [2,3])
            // array([[ 4400.,  4730.],
            //        [ 4532.,  4874.],
            //        [ 4664.,  5018.],
            //        [ 4796.,  5162.],
            //        [ 4928.,  5306.]])
            // >>> np.tensordot(a,b, axes=([1,0],[0,1]))
            // array([[ 4400.,  4730.],
            //        [ 4532.,  4874.],
            //        [ 4664.,  5018.],
            //        [ 4796.,  5162.],
            //        [ 4928.,  5306.]])
            // 
            
            #if TODO
             given=  a = np.arange(60.).reshape(3,4,5);
             given=  b = np.arange(24.).reshape(4,3,2);
             given=  np.einsum('ijk,jil->kl', a, b);
             expected=
                "array([[ 4400.,  4730.],\n" +
                "       [ 4532.,  4874.],\n" +
                "       [ 4664.,  5018.],\n" +
                "       [ 4796.,  5162.],\n" +
                "       [ 4928.,  5306.]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.einsum(a, {0,1,2}, b, {1,0,3}, {2,3});
             expected=
                "array([[ 4400.,  4730.],\n" +
                "       [ 4532.,  4874.],\n" +
                "       [ 4664.,  5018.],\n" +
                "       [ 4796.,  5162.],\n" +
                "       [ 4928.,  5306.]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.tensordot(a,b, axes=({1,0},{0,1}));
             expected=
                "array([[ 4400.,  4730.],\n" +
                "       [ 4532.,  4874.],\n" +
                "       [ 4664.,  5018.],\n" +
                "       [ 4796.,  5162.],\n" +
                "       [ 4928.,  5306.]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Writeable returned arrays (since version 1.10.0):
            
            // >>> a = np.zeros((3, 3))
            // >>> np.einsum('ii->i', a)[:] = 1
            // >>> a
            // array([[ 1.,  0.,  0.],
            //        [ 0.,  1.,  0.],
            //        [ 0.,  0.,  1.]])
            // 
            
            #if TODO
             given=  a = np.zeros((3, 3));
             given=  np.einsum('ii->i', a){:} = 1;
             given=  a;
             expected=
                "array([[ 1.,  0.,  0.],\n" +
                "       [ 0.,  1.,  0.],\n" +
                "       [ 0.,  0.,  1.]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Example of ellipsis use:
            
            // >>> a = np.arange(6).reshape((3,2))
            // >>> b = np.arange(12).reshape((4,3))
            // >>> np.einsum('ki,jk->ij', a, b)
            // array([[10, 28, 46, 64],
            //        [13, 40, 67, 94]])
            // >>> np.einsum('ki,...k->i...', a, b)
            // array([[10, 28, 46, 64],
            //        [13, 40, 67, 94]])
            // >>> np.einsum('k...,jk', a, b)
            // array([[10, 28, 46, 64],
            //        [13, 40, 67, 94]])
            // 
            
            #if TODO
             given=  a = np.arange(6).reshape((3,2));
             given=  b = np.arange(12).reshape((4,3));
             given=  np.einsum('ki,jk->ij', a, b);
             expected=
                "array([[10, 28, 46, 64],\n" +
                "       [13, 40, 67, 94]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.einsum('ki,...k->i...', a, b);
             expected=
                "array([[10, 28, 46, 64],\n" +
                "       [13, 40, 67, 94]])";
            Assert.AreEqual(expected, given.repr);
             given=  np.einsum('k...,jk', a, b);
             expected=
                "array([[10, 28, 46, 64],\n" +
                "       [13, 40, 67, 94]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Chained array operations. For more complicated contractions, speed ups
            // might be achieved by repeatedly computing a ‘greedy’ path or pre-computing the
            // ‘optimal’ path and repeatedly applying it, using an
            // einsum_path insertion (since version 1.12.0). Performance improvements can be
            // particularly significant with larger arrays:
            
            // >>> a = np.ones(64).reshape(2,4,8)
            // # Basic `einsum`: ~1520ms  (benchmarked on 3.1GHz Intel i5.)
            // >>> for iteration in range(500):
            // ...     np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a)
            // # Sub-optimal `einsum` (due to repeated path calculation time): ~330ms
            // >>> for iteration in range(500):
            // ...     np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='optimal')
            // # Greedy `einsum` (faster optimal path approximation): ~160ms
            // >>> for iteration in range(500):
            // ...     np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='greedy')
            // # Optimal `einsum` (best usage pattern in some use cases): ~110ms
            // >>> path = np.einsum_path('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='optimal')[0]
            // >>> for iteration in range(500):
            // ...     np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize=path)
            // 
            
            #if TODO
             given=  a = np.ones(64).reshape(2,4,8);
            // Basic `einsum`: ~1520ms  (benchmarked on 3.1GHz Intel i5.)
             given=  for iteration in range(500):;
             expected=
                "...     np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a)";
            Assert.AreEqual(expected, given.repr);
            // Sub-optimal `einsum` (due to repeated path calculation time): ~330ms
             given=  for iteration in range(500):;
             expected=
                "...     np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='optimal')";
            Assert.AreEqual(expected, given.repr);
            // Greedy `einsum` (faster optimal path approximation): ~160ms
             given=  for iteration in range(500):;
             expected=
                "...     np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='greedy')";
            Assert.AreEqual(expected, given.repr);
            // Optimal `einsum` (best usage pattern in some use cases): ~110ms
             given=  path = np.einsum_path('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize='optimal'){0};
             given=  for iteration in range(500):;
             expected=
                "...     np.einsum('ijk,ilm,njm,nlk,abc->',a,a,a,a,a, optimize=path)";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void einsum_pathTest()
        {
            // We can begin with a chain dot example. In this case, it is optimal to
            // contract the b and c tensors first as represented by the first
            // element of the path (1, 2). The resulting tensor is added to the end
            // of the contraction and the remaining contraction (0, 1) is then
            // completed.
            
            // >>> a = np.random.rand(2, 2)
            // >>> b = np.random.rand(2, 5)
            // >>> c = np.random.rand(5, 2)
            // >>> path_info = np.einsum_path('ij,jk,kl->il', a, b, c, optimize='greedy')
            // >>> print(path_info[0])
            // ['einsum_path', (1, 2), (0, 1)]
            // >>> print(path_info[1])
            //   Complete contraction:  ij,jk,kl->il
            //          Naive scaling:  4
            //      Optimized scaling:  3
            //       Naive FLOP count:  1.600e+02
            //   Optimized FLOP count:  5.600e+01
            //    Theoretical speedup:  2.857
            //   Largest intermediate:  4.000e+00 elements
            // -------------------------------------------------------------------------
            // scaling                  current                                remaining
            // -------------------------------------------------------------------------
            //    3                   kl,jk->jl                                ij,jl->il
            //    3                   jl,ij->il                                   il->il
            // 
            
            #if TODO
            var given=  a = np.random.rand(2, 2);
             given=  b = np.random.rand(2, 5);
             given=  c = np.random.rand(5, 2);
             given=  path_info = np.einsum_path('ij,jk,kl->il', a, b, c, optimize='greedy');
             given=  print(path_info[0]);
            var expected=
                "['einsum_path', (1, 2), (0, 1)]";
            Assert.AreEqual(expected, given.repr);
             given=  print(path_info[1]);
             expected=
                "  Complete contraction:  ij,jk,kl->il\n" +
                "         Naive scaling:  4\n" +
                "     Optimized scaling:  3\n" +
                "      Naive FLOP count:  1.600e+02\n" +
                "  Optimized FLOP count:  5.600e+01\n" +
                "   Theoretical speedup:  2.857\n" +
                "  Largest intermediate:  4.000e+00 elements\n" +
                "-------------------------------------------------------------------------\n" +
                "scaling                  current                                remaining\n" +
                "-------------------------------------------------------------------------\n" +
                "   3                   kl,jk->jl                                ij,jl->il\n" +
                "   3                   jl,ij->il                                   il->il";
            Assert.AreEqual(expected, given.repr);
            #endif
            // A more complex index transformation example.
            
            // >>> I = np.random.rand(10, 10, 10, 10)
            // >>> C = np.random.rand(10, 10)
            // >>> path_info = np.einsum_path('ea,fb,abcd,gc,hd->efgh', C, C, I, C, C,
            //                                optimize='greedy')
            // 
            
            #if TODO
             given=  I = np.random.rand(10, 10, 10, 10);
             given=  C = np.random.rand(10, 10);
             given=  path_info = np.einsum_path('ea,fb,abcd,gc,hd->efgh', C, C, I, C, C,;
             expected=
                "                               optimize='greedy')";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> print(path_info[0])
            // ['einsum_path', (0, 2), (0, 3), (0, 2), (0, 1)]
            // >>> print(path_info[1])
            //   Complete contraction:  ea,fb,abcd,gc,hd->efgh
            //          Naive scaling:  8
            //      Optimized scaling:  5
            //       Naive FLOP count:  8.000e+08
            //   Optimized FLOP count:  8.000e+05
            //    Theoretical speedup:  1000.000
            //   Largest intermediate:  1.000e+04 elements
            // --------------------------------------------------------------------------
            // scaling                  current                                remaining
            // --------------------------------------------------------------------------
            //    5               abcd,ea->bcde                      fb,gc,hd,bcde->efgh
            //    5               bcde,fb->cdef                         gc,hd,cdef->efgh
            //    5               cdef,gc->defg                            hd,defg->efgh
            //    5               defg,hd->efgh                               efgh->efgh
            // 
            
            #if TODO
             given=  print(path_info[0]);
             expected=
                "['einsum_path', (0, 2), (0, 3), (0, 2), (0, 1)]";
            Assert.AreEqual(expected, given.repr);
             given=  print(path_info[1]);
             expected=
                "  Complete contraction:  ea,fb,abcd,gc,hd->efgh\n" +
                "         Naive scaling:  8\n" +
                "     Optimized scaling:  5\n" +
                "      Naive FLOP count:  8.000e+08\n" +
                "  Optimized FLOP count:  8.000e+05\n" +
                "   Theoretical speedup:  1000.000\n" +
                "  Largest intermediate:  1.000e+04 elements\n" +
                "--------------------------------------------------------------------------\n" +
                "scaling                  current                                remaining\n" +
                "--------------------------------------------------------------------------\n" +
                "   5               abcd,ea->bcde                      fb,gc,hd,bcde->efgh\n" +
                "   5               bcde,fb->cdef                         gc,hd,cdef->efgh\n" +
                "   5               cdef,gc->defg                            hd,defg->efgh\n" +
                "   5               defg,hd->efgh                               efgh->efgh";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void matrix_powerTest()
        {
            // >>> from numpy.linalg import matrix_power
            // >>> i = np.array([[0, 1], [-1, 0]]) # matrix equiv. of the imaginary unit
            // >>> matrix_power(i, 3) # should = -i
            // array([[ 0, -1],
            //        [ 1,  0]])
            // >>> matrix_power(i, 0)
            // array([[1, 0],
            //        [0, 1]])
            // >>> matrix_power(i, -3) # should = 1/(-i) = i, but w/ f.p. elements
            // array([[ 0.,  1.],
            //        [-1.,  0.]])
            // 
            
            #if TODO
            var given=  from numpy.linalg import matrix_power;
             given=  i = np.array({{0, 1}, {-1, 0}}) # matrix equiv. of the imaginary unit;
             given=  matrix_power(i, 3) # should = -i;
            var expected=
                "array([[ 0, -1],\n" +
                "       [ 1,  0]])";
            Assert.AreEqual(expected, given.repr);
             given=  matrix_power(i, 0);
             expected=
                "array([[1, 0],\n" +
                "       [0, 1]])";
            Assert.AreEqual(expected, given.repr);
             given=  matrix_power(i, -3) # should = 1/(-i) = i, but w/ f.p. elements;
             expected=
                "array([[ 0.,  1.],\n" +
                "       [-1.,  0.]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Somewhat more sophisticated example
            
            // >>> q = np.zeros((4, 4))
            // >>> q[0:2, 0:2] = -i
            // >>> q[2:4, 2:4] = i
            // >>> q # one of the three quaternion units not equal to 1
            // array([[ 0., -1.,  0.,  0.],
            //        [ 1.,  0.,  0.,  0.],
            //        [ 0.,  0.,  0.,  1.],
            //        [ 0.,  0., -1.,  0.]])
            // >>> matrix_power(q, 2) # = -np.eye(4)
            // array([[-1.,  0.,  0.,  0.],
            //        [ 0., -1.,  0.,  0.],
            //        [ 0.,  0., -1.,  0.],
            //        [ 0.,  0.,  0., -1.]])
            // 
            
            #if TODO
             given=  q = np.zeros((4, 4));
             given=  q[0:2, 0:2] = -i;
             given=  q[2:4, 2:4] = i;
             given=  q # one of the three quaternion units not equal to 1;
             expected=
                "array([[ 0., -1.,  0.,  0.],\n" +
                "       [ 1.,  0.,  0.,  0.],\n" +
                "       [ 0.,  0.,  0.,  1.],\n" +
                "       [ 0.,  0., -1.,  0.]])";
            Assert.AreEqual(expected, given.repr);
             given=  matrix_power(q, 2) # = -np.eye(4);
             expected=
                "array([[-1.,  0.,  0.,  0.],\n" +
                "       [ 0., -1.,  0.,  0.],\n" +
                "       [ 0.,  0., -1.,  0.],\n" +
                "       [ 0.,  0.,  0., -1.]])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void kronTest()
        {
            // >>> np.kron([1,10,100], [5,6,7])
            // array([  5,   6,   7,  50,  60,  70, 500, 600, 700])
            // >>> np.kron([5,6,7], [1,10,100])
            // array([  5,  50, 500,   6,  60, 600,   7,  70, 700])
            // 
            
            #if TODO
            var given=  np.kron({1,10,100}, {5,6,7});
            var expected=
                "array([  5,   6,   7,  50,  60,  70, 500, 600, 700])";
            Assert.AreEqual(expected, given.repr);
             given=  np.kron({5,6,7}, {1,10,100});
             expected=
                "array([  5,  50, 500,   6,  60, 600,   7,  70, 700])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> np.kron(np.eye(2), np.ones((2,2)))
            // array([[ 1.,  1.,  0.,  0.],
            //        [ 1.,  1.,  0.,  0.],
            //        [ 0.,  0.,  1.,  1.],
            //        [ 0.,  0.,  1.,  1.]])
            // 
            
            #if TODO
             given=  np.kron(np.eye(2), np.ones((2,2)));
             expected=
                "array([[ 1.,  1.,  0.,  0.],\n" +
                "       [ 1.,  1.,  0.,  0.],\n" +
                "       [ 0.,  0.,  1.,  1.],\n" +
                "       [ 0.,  0.,  1.,  1.]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> a = np.arange(100).reshape((2,5,2,5))
            // >>> b = np.arange(24).reshape((2,3,4))
            // >>> c = np.kron(a,b)
            // >>> c.shape
            // (2, 10, 6, 20)
            // >>> I = (1,3,0,2)
            // >>> J = (0,2,1)
            // >>> J1 = (0,) + J             # extend to ndim=4
            // >>> S1 = (1,) + b.shape
            // >>> K = tuple(np.array(I) * np.array(S1) + np.array(J1))
            // >>> c[K] == a[I]*b[J]
            // True
            // 
            
            #if TODO
             given=  a = np.arange(100).reshape((2,5,2,5));
             given=  b = np.arange(24).reshape((2,3,4));
             given=  c = np.kron(a,b);
             given=  c.shape;
             expected=
                "(2, 10, 6, 20)";
            Assert.AreEqual(expected, given.repr);
             given=  I = (1,3,0,2);
             given=  J = (0,2,1);
             given=  J1 = (0,) + J             # extend to ndim=4;
             given=  S1 = (1,) + b.shape;
             given=  K = tuple(np.array(I) * np.array(S1) + np.array(J1));
             given=  c[K] == a[I]*b[J];
             expected=
                "True";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void qrTest()
        {
            // >>> a = np.random.randn(9, 6)
            // >>> q, r = np.linalg.qr(a)
            // >>> np.allclose(a, np.dot(q, r))  # a does equal qr
            // True
            // >>> r2 = np.linalg.qr(a, mode='r')
            // >>> r3 = np.linalg.qr(a, mode='economic')
            // >>> np.allclose(r, r2)  # mode='r' returns the same r as mode='full'
            // True
            // >>> # But only triu parts are guaranteed equal when mode='economic'
            // >>> np.allclose(r, np.triu(r3[:6,:6], k=0))
            // True
            // 
            
            #if TODO
            var given=  a = np.random.randn(9, 6);
             given=  q, r = np.linalg.qr(a);
             given=  np.allclose(a, np.dot(q, r))  # a does equal qr;
            var expected=
                "True";
            Assert.AreEqual(expected, given.repr);
             given=  r2 = np.linalg.qr(a, mode='r');
             given=  r3 = np.linalg.qr(a, mode='economic');
             given=  np.allclose(r, r2)  # mode='r' returns the same r as mode='full';
             expected=
                "True";
            Assert.AreEqual(expected, given.repr);
             given=  # But only triu parts are guaranteed equal when mode='economic';
             given=  np.allclose(r, np.triu(r3{:6,:6}, k=0));
             expected=
                "True";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Example illustrating a common use of qr: solving of least squares
            // problems
            
            // What are the least-squares-best m and y0 in y = y0 + mx for
            // the following data: {(0,1), (1,0), (1,2), (2,1)}. (Graph the points
            // and you’ll see that it should be y0 = 0, m = 1.)  The answer is provided
            // by solving the over-determined matrix equation Ax = b, where:
            
            // A = array([[0, 1], [1, 1], [1, 1], [2, 1]])
            // x = array([[y0], [m]])
            // b = array([[1], [0], [2], [1]])
            // 
            
            #if TODO
             expected=
                "A = array([[0, 1], [1, 1], [1, 1], [2, 1]])\n" +
                "x = array([[y0], [m]])\n" +
                "b = array([[1], [0], [2], [1]])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // If A = qr such that q is orthonormal (which is always possible via
            // Gram-Schmidt), then x = inv(r) * (q.T) * b.  (In numpy practice,
            // however, we simply use lstsq.)
            
            // >>> A = np.array([[0, 1], [1, 1], [1, 1], [2, 1]])
            // >>> A
            // array([[0, 1],
            //        [1, 1],
            //        [1, 1],
            //        [2, 1]])
            // >>> b = np.array([1, 0, 2, 1])
            // >>> q, r = LA.qr(A)
            // >>> p = np.dot(q.T, b)
            // >>> np.dot(LA.inv(r), p)
            // array([  1.1e-16,   1.0e+00])
            // 
            
            #if TODO
             given=  A = np.array({{0, 1}, {1, 1}, {1, 1}, {2, 1}});
             given=  A;
             expected=
                "array([[0, 1],\n" +
                "       [1, 1],\n" +
                "       [1, 1],\n" +
                "       [2, 1]])";
            Assert.AreEqual(expected, given.repr);
             given=  b = np.array({1, 0, 2, 1});
             given=  q, r = LA.qr(A);
             given=  p = np.dot(q.T, b);
             given=  np.dot(LA.inv(r), p);
             expected=
                "array([  1.1e-16,   1.0e+00])";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void condTest()
        {
            // >>> from numpy import linalg as LA
            // >>> a = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])
            // >>> a
            // array([[ 1,  0, -1],
            //        [ 0,  1,  0],
            //        [ 1,  0,  1]])
            // >>> LA.cond(a)
            // 1.4142135623730951
            // >>> LA.cond(a, 'fro')
            // 3.1622776601683795
            // >>> LA.cond(a, np.inf)
            // 2.0
            // >>> LA.cond(a, -np.inf)
            // 1.0
            // >>> LA.cond(a, 1)
            // 2.0
            // >>> LA.cond(a, -1)
            // 1.0
            // >>> LA.cond(a, 2)
            // 1.4142135623730951
            // >>> LA.cond(a, -2)
            // 0.70710678118654746
            // >>> min(LA.svd(a, compute_uv=0))*min(LA.svd(LA.inv(a), compute_uv=0))
            // 0.70710678118654746
            // 
            
            #if TODO
            var given=  from numpy import linalg as LA;
             given=  a = np.array({{1, 0, -1}, {0, 1, 0}, {1, 0, 1}});
             given=  a;
            var expected=
                "array([[ 1,  0, -1],\n" +
                "       [ 0,  1,  0],\n" +
                "       [ 1,  0,  1]])";
            Assert.AreEqual(expected, given.repr);
             given=  LA.cond(a);
             expected=
                "1.4142135623730951";
            Assert.AreEqual(expected, given.repr);
             given=  LA.cond(a, 'fro');
             expected=
                "3.1622776601683795";
            Assert.AreEqual(expected, given.repr);
             given=  LA.cond(a, np.inf);
             expected=
                "2.0";
            Assert.AreEqual(expected, given.repr);
             given=  LA.cond(a, -np.inf);
             expected=
                "1.0";
            Assert.AreEqual(expected, given.repr);
             given=  LA.cond(a, 1);
             expected=
                "2.0";
            Assert.AreEqual(expected, given.repr);
             given=  LA.cond(a, -1);
             expected=
                "1.0";
            Assert.AreEqual(expected, given.repr);
             given=  LA.cond(a, 2);
             expected=
                "1.4142135623730951";
            Assert.AreEqual(expected, given.repr);
             given=  LA.cond(a, -2);
             expected=
                "0.70710678118654746";
            Assert.AreEqual(expected, given.repr);
             given=  min(LA.svd(a, compute_uv=0))*min(LA.svd(LA.inv(a), compute_uv=0));
             expected=
                "0.70710678118654746";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void matrix_rankTest()
        {
            // >>> from numpy.linalg import matrix_rank
            // >>> matrix_rank(np.eye(4)) # Full rank matrix
            // 4
            // >>> I=np.eye(4); I[-1,-1] = 0. # rank deficient matrix
            // >>> matrix_rank(I)
            // 3
            // >>> matrix_rank(np.ones((4,))) # 1 dimension - rank 1 unless all 0
            // 1
            // >>> matrix_rank(np.zeros((4,)))
            // 0
            // 
            
            #if TODO
            var given=  from numpy.linalg import matrix_rank;
             given=  matrix_rank(np.eye(4)) # Full rank matrix;
            var expected=
                "4";
            Assert.AreEqual(expected, given.repr);
             given=  I=np.eye(4); I{-1,-1} = 0. # rank deficient matrix;
             given=  matrix_rank(I);
             expected=
                "3";
            Assert.AreEqual(expected, given.repr);
             given=  matrix_rank(np.ones((4,))) # 1 dimension - rank 1 unless all 0;
             expected=
                "1";
            Assert.AreEqual(expected, given.repr);
             given=  matrix_rank(np.zeros((4,)));
             expected=
                "0";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void slogdetTest()
        {
            // The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:
            
            // >>> a = np.array([[1, 2], [3, 4]])
            // >>> (sign, logdet) = np.linalg.slogdet(a)
            // >>> (sign, logdet)
            // (-1, 0.69314718055994529)
            // >>> sign * np.exp(logdet)
            // -2.0
            // 
            
            #if TODO
            var given=  a = np.array({{1, 2}, {3, 4}});
             given=  (sign, logdet) = np.linalg.slogdet(a);
             given=  (sign, logdet);
            var expected=
                "(-1, 0.69314718055994529)";
            Assert.AreEqual(expected, given.repr);
             given=  sign * np.exp(logdet);
             expected=
                "-2.0";
            Assert.AreEqual(expected, given.repr);
            #endif
            // Computing log-determinants for a stack of matrices:
            
            // >>> a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
            // >>> a.shape
            // (3, 2, 2)
            // >>> sign, logdet = np.linalg.slogdet(a)
            // >>> (sign, logdet)
            // (array([-1., -1., -1.]), array([ 0.69314718,  1.09861229,  2.07944154]))
            // >>> sign * np.exp(logdet)
            // array([-2., -3., -8.])
            // 
            
            #if TODO
             given=  a = np.array({ {{1, 2}, {3, 4}}, {{1, 2}, {2, 1}}, {{1, 3}, {3, 1}} });
             given=  a.shape;
             expected=
                "(3, 2, 2)";
            Assert.AreEqual(expected, given.repr);
             given=  sign, logdet = np.linalg.slogdet(a);
             given=  (sign, logdet);
             expected=
                "(array([-1., -1., -1.]), array([ 0.69314718,  1.09861229,  2.07944154]))";
            Assert.AreEqual(expected, given.repr);
             given=  sign * np.exp(logdet);
             expected=
                "array([-2., -3., -8.])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // This routine succeeds where ordinary det does not:
            
            // >>> np.linalg.det(np.eye(500) * 0.1)
            // 0.0
            // >>> np.linalg.slogdet(np.eye(500) * 0.1)
            // (1, -1151.2925464970228)
            // 
            
            #if TODO
             given=  np.linalg.det(np.eye(500) * 0.1);
             expected=
                "0.0";
            Assert.AreEqual(expected, given.repr);
             given=  np.linalg.slogdet(np.eye(500) * 0.1);
             expected=
                "(1, -1151.2925464970228)";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void traceTest()
        {
            // >>> np.trace(np.eye(3))
            // 3.0
            // >>> a = np.arange(8).reshape((2,2,2))
            // >>> np.trace(a)
            // array([6, 8])
            // 
            
            #if TODO
            var given=  np.trace(np.eye(3));
            var expected=
                "3.0";
            Assert.AreEqual(expected, given.repr);
             given=  a = np.arange(8).reshape((2,2,2));
             given=  np.trace(a);
             expected=
                "array([6, 8])";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> a = np.arange(24).reshape((2,2,2,3))
            // >>> np.trace(a).shape
            // (2, 3)
            // 
            
            #if TODO
             given=  a = np.arange(24).reshape((2,2,2,3));
             given=  np.trace(a).shape;
             expected=
                "(2, 3)";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void tensorsolveTest()
        {
            // >>> a = np.eye(2*3*4)
            // >>> a.shape = (2*3, 4, 2, 3, 4)
            // >>> b = np.random.randn(2*3, 4)
            // >>> x = np.linalg.tensorsolve(a, b)
            // >>> x.shape
            // (2, 3, 4)
            // >>> np.allclose(np.tensordot(a, x, axes=3), b)
            // True
            // 
            
            #if TODO
            var given=  a = np.eye(2*3*4);
             given=  a.shape = (2*3, 4, 2, 3, 4);
             given=  b = np.random.randn(2*3, 4);
             given=  x = np.linalg.tensorsolve(a, b);
             given=  x.shape;
            var expected=
                "(2, 3, 4)";
            Assert.AreEqual(expected, given.repr);
             given=  np.allclose(np.tensordot(a, x, axes=3), b);
             expected=
                "True";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void tensorinvTest()
        {
            // >>> a = np.eye(4*6)
            // >>> a.shape = (4, 6, 8, 3)
            // >>> ainv = np.linalg.tensorinv(a, ind=2)
            // >>> ainv.shape
            // (8, 3, 4, 6)
            // >>> b = np.random.randn(4, 6)
            // >>> np.allclose(np.tensordot(ainv, b), np.linalg.tensorsolve(a, b))
            // True
            // 
            
            #if TODO
            var given=  a = np.eye(4*6);
             given=  a.shape = (4, 6, 8, 3);
             given=  ainv = np.linalg.tensorinv(a, ind=2);
             given=  ainv.shape;
            var expected=
                "(8, 3, 4, 6)";
            Assert.AreEqual(expected, given.repr);
             given=  b = np.random.randn(4, 6);
             given=  np.allclose(np.tensordot(ainv, b), np.linalg.tensorsolve(a, b));
             expected=
                "True";
            Assert.AreEqual(expected, given.repr);
            #endif
            // >>> a = np.eye(4*6)
            // >>> a.shape = (24, 8, 3)
            // >>> ainv = np.linalg.tensorinv(a, ind=1)
            // >>> ainv.shape
            // (8, 3, 24)
            // >>> b = np.random.randn(24)
            // >>> np.allclose(np.tensordot(ainv, b, 1), np.linalg.tensorsolve(a, b))
            // True
            // 
            
            #if TODO
             given=  a = np.eye(4*6);
             given=  a.shape = (24, 8, 3);
             given=  ainv = np.linalg.tensorinv(a, ind=1);
             given=  ainv.shape;
             expected=
                "(8, 3, 24)";
            Assert.AreEqual(expected, given.repr);
             given=  b = np.random.randn(24);
             given=  np.allclose(np.tensordot(ainv, b, 1), np.linalg.tensorsolve(a, b));
             expected=
                "True";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
        
        [TestMethod]
        public void LinAlgErrorTest()
        {
            // >>> from numpy import linalg as LA
            // >>> LA.inv(np.zeros((2,2)))
            // Traceback (most recent call last):
            //   File "<stdin>", line 1, in <module>
            //   File "...linalg.py", line 350,
            //     in inv return wrap(solve(a, identity(a.shape[0], dtype=a.dtype)))
            //   File "...linalg.py", line 249,
            //     in solve
            //     raise LinAlgError('Singular matrix')
            // numpy.linalg.LinAlgError: Singular matrix
            // 
            
            #if TODO
            var given=  from numpy import linalg as LA;
             given=  LA.inv(np.zeros((2,2)));
            var expected=
                "Traceback (most recent call last):\n" +
                "  File "<stdin>", line 1, in <module>\n" +
                "  File "...linalg.py", line 350,\n" +
                "    in inv return wrap(solve(a, identity(a.shape[0], dtype=a.dtype)))\n" +
                "  File "...linalg.py", line 249,\n" +
                "    in solve\n" +
                "    raise LinAlgError('Singular matrix')\n" +
                "numpy.linalg.LinAlgError: Singular matrix";
            Assert.AreEqual(expected, given.repr);
            #endif
        }
        
    }
}
