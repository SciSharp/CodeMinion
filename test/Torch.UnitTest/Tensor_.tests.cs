// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Python.Runtime;
using Numpy;
using Numpy.Models;

using Microsoft.VisualStudio.TestTools.UnitTesting;
using Assert = NUnit.Framework.Assert;

namespace Torch.UnitTest
{
    [TestClass]
    public class Tensor_Test : BaseTestCase
    {

        [TestMethod]
        public void new_tensorTest()
        {
            // >>> tensor = torch.ones((2,), dtype=torch.int8)
            // >>> data = [[0, 1], [2, 3]]
            // >>> tensor.new_tensor(data)
            // tensor([[ 0,  1],
            //         [ 2,  3]], dtype=torch.int8)
            // 

            var tensor = torch.ones(new Shape(2), dtype: torch.int8);
            var data = new int[,] { { 0, 1 }, { 2, 3 } };
            var given = tensor.new_tensor(data);
            var expected =
                "tensor([[0, 1],\n" +
                "        [2, 3]], dtype=torch.int8)";
            Assert.AreEqual(expected, given.repr);
        }


        [TestMethod]
        public void new_fullTest()
        {
            // >>> tensor = torch.ones((2,), dtype=torch.float64)
            // >>> tensor.new_full((3, 4), 3.141592)
            // tensor([[ 3.1416,  3.1416,  3.1416,  3.1416],
            //         [ 3.1416,  3.1416,  3.1416,  3.1416],
            //         [ 3.1416,  3.1416,  3.1416,  3.1416]], dtype=torch.float64)
            // 

            torch.set_default_dtype(torch.float64);
            var tensor = torch.ones(new Shape(2), dtype: torch.float64);
            var given = tensor.new_full(new Shape(3, 4), 3.141592);
            var expected =
                "tensor([[3.1416, 3.1416, 3.1416, 3.1416],\n" +
                "        [3.1416, 3.1416, 3.1416, 3.1416],\n" +
                "        [3.1416, 3.1416, 3.1416, 3.1416]])";
            Assert.AreEqual(expected, given.repr);
        }


        [TestMethod]
        public void new_emptyTest()
        {
            // >>> tensor = torch.ones(())
            // >>> tensor.new_empty((2, 3))
            // tensor([[ 5.8182e-18,  4.5765e-41, -1.0545e+30],
            //         [ 3.0949e-41,  4.4842e-44,  0.0000e+00]])
            // 

#if TODO
            var given=  tensor = torch.ones(());
             given=  tensor.new_empty((2, 3));
            var expected=
                "tensor([[ 5.8182e-18,  4.5765e-41, -1.0545e+30],\n" +
                "        [ 3.0949e-41,  4.4842e-44,  0.0000e+00]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void new_onesTest()
        {
            // >>> tensor = torch.tensor((), dtype=torch.int32)
            // >>> tensor.new_ones((2, 3))
            // tensor([[ 1,  1,  1],
            //         [ 1,  1,  1]], dtype=torch.int32)
            // 

            var tensor = torch.tensor(new int[] { }, dtype: torch.int32);
            var given = tensor.new_ones(new Shape(2, 3));
            var expected =
                "tensor([[1, 1, 1],\n" +
                "        [1, 1, 1]], dtype=torch.int32)";
            Assert.AreEqual(expected, given.repr);
        }


        [TestMethod]
        public void new_zerosTest()
        {
            // >>> tensor = torch.tensor((), dtype=torch.float64)
            // >>> tensor.new_zeros((2, 3))
            // tensor([[ 0.,  0.,  0.],
            //         [ 0.,  0.,  0.]], dtype=torch.float64)
            // 

#if TODO
            var given=  tensor = torch.tensor((), dtype=torch.float64);
             given=  tensor.new_zeros((2, 3));
            var expected=
                "tensor([[ 0.,  0.,  0.],\n" +
                "        [ 0.,  0.,  0.]], dtype=torch.float64)";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void element_sizeTest()
        {
            // >>> torch.tensor([]).element_size()
            // 4
            // >>> torch.tensor([], dtype=torch.uint8).element_size()
            // 1

            Assert.AreEqual(4, torch.tensor(new int[] { }).element_size());
            Assert.AreEqual(1, torch.tensor(new int[] { }, dtype: torch.uint8).element_size());
        }


        [TestMethod]
        public void expandTest()
        {
            // >>> x = torch.tensor([[1], [2], [3]])
            // >>> x.size()
            // torch.Size([3, 1])
            // >>> x.expand(3, 4)
            // tensor([[ 1,  1,  1,  1],
            //         [ 2,  2,  2,  2],
            //         [ 3,  3,  3,  3]])
            // >>> x.expand(-1, 4)   # -1 means not changing the size of that dimension
            // tensor([[ 1,  1,  1,  1],
            //         [ 2,  2,  2,  2],
            //         [ 3,  3,  3,  3]])
            // 

            var x = torch.tensor(new long[,] { { 1 }, { 2 }, { 3 } });
            Assert.AreEqual(new Shape(3,1), x.size());
            var given = x.expand(3, 4);
            var expected =
               "tensor([[1, 1, 1, 1],\n" +
               "        [2, 2, 2, 2],\n" +
               "        [3, 3, 3, 3]])";
            Assert.AreEqual(expected, given.repr);
            given = x.expand(-1, 4);   // -1 means not changing the size of that dimension;
             expected =
                "tensor([[1, 1, 1, 1],\n" +
                "        [2, 2, 2, 2],\n" +
                "        [3, 3, 3, 3]])";
            Assert.AreEqual(expected, given.repr);
        }


        [TestMethod]
        public void get_device_nrTest()
        {
            // >>> x = torch.randn(3, 4, 5, device='cuda:0')
            // >>> x.get_device()
            // 0
            // >>> x.cpu().get_device()  # RuntimeError: get_device is not implemented for type torch.FloatTensor
            // 

#if TODO
            var given=  x = torch.randn(3, 4, 5, device='cuda:0');
             given=  x.get_device();
            var expected=
                "0";
            Assert.AreEqual(expected, given.repr);
             given=  x.cpu().get_device()  # RuntimeError: get_device is not implemented for type torch.FloatTensor;
#endif
        }


        [TestMethod]
        public void index_add_Test()
        {
            // >>> x = torch.ones(5, 3)
            // >>> t = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float)
            // >>> index = torch.tensor([0, 4, 2])
            // >>> x.index_add_(0, index, t)
            // tensor([[  2.,   3.,   4.],
            //         [  1.,   1.,   1.],
            //         [  8.,   9.,  10.],
            //         [  1.,   1.,   1.],
            //         [  5.,   6.,   7.]])
            // 

#if TODO
            var given=  x = torch.ones(5, 3);
             given=  t = torch.tensor({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, dtype=torch.float);
             given=  index = torch.tensor({0, 4, 2});
             given=  x.index_add_(0, index, t);
            var expected=
                "tensor([[  2.,   3.,   4.],\n" +
                "        [  1.,   1.,   1.],\n" +
                "        [  8.,   9.,  10.],\n" +
                "        [  1.,   1.,   1.],\n" +
                "        [  5.,   6.,   7.]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void index_copy_Test()
        {
            // >>> x = torch.zeros(5, 3)
            // >>> t = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float)
            // >>> index = torch.tensor([0, 4, 2])
            // >>> x.index_copy_(0, index, t)
            // tensor([[ 1.,  2.,  3.],
            //         [ 0.,  0.,  0.],
            //         [ 7.,  8.,  9.],
            //         [ 0.,  0.,  0.],
            //         [ 4.,  5.,  6.]])
            // 

#if TODO
            var given=  x = torch.zeros(5, 3);
             given=  t = torch.tensor({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, dtype=torch.float);
             given=  index = torch.tensor({0, 4, 2});
             given=  x.index_copy_(0, index, t);
            var expected=
                "tensor([[ 1.,  2.,  3.],\n" +
                "        [ 0.,  0.,  0.],\n" +
                "        [ 7.,  8.,  9.],\n" +
                "        [ 0.,  0.,  0.],\n" +
                "        [ 4.,  5.,  6.]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void index_fill_Test()
        {
            // >>> x = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=torch.float)
            // >>> index = torch.tensor([0, 2])
            // >>> x.index_fill_(1, index, -1)
            // tensor([[-1.,  2., -1.],
            //         [-1.,  5., -1.],
            //         [-1.,  8., -1.]])
            // 

#if TODO
            var given=  x = torch.tensor({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, dtype=torch.float);
             given=  index = torch.tensor({0, 2});
             given=  x.index_fill_(1, index, -1);
            var expected=
                "tensor([[-1.,  2., -1.],\n" +
                "        [-1.,  5., -1.],\n" +
                "        [-1.,  8., -1.]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void is_leafTest()
        {
            // >>> a = torch.rand(10, requires_grad=True)
            // >>> a.is_leaf
            // True
            // >>> b = torch.rand(10, requires_grad=True).cuda()
            // >>> b.is_leaf
            // False
            // # b was created by the operation that cast a cpu Tensor into a cuda Tensor
            // >>> c = torch.rand(10, requires_grad=True) + 2
            // >>> c.is_leaf
            // False
            // # c was created by the addition operation
            // >>> d = torch.rand(10).cuda()
            // >>> d.is_leaf
            // True
            // # d does not require gradients and so has no operation creating it (that is tracked by the autograd engine)
            // >>> e = torch.rand(10).cuda().requires_grad_()
            // >>> e.is_leaf
            // True
            // # e requires gradients and has no operations creating it
            // >>> f = torch.rand(10, requires_grad=True, device="cuda")
            // >>> f.is_leaf
            // True
            // # f requires grad, has no operation creating it
            // 

#if TODO
            var given=  a = torch.rand(10, requires_grad=True);
             given=  a.is_leaf;
            var expected=
                "True";
            Assert.AreEqual(expected, given.repr);
             given=  b = torch.rand(10, requires_grad=True).cuda();
             given=  b.is_leaf;
             expected=
                "False";
            Assert.AreEqual(expected, given.repr);
            // b was created by the operation that cast a cpu Tensor into a cuda Tensor
             given=  c = torch.rand(10, requires_grad=True) + 2;
             given=  c.is_leaf;
             expected=
                "False";
            Assert.AreEqual(expected, given.repr);
            // c was created by the addition operation
             given=  d = torch.rand(10).cuda();
             given=  d.is_leaf;
             expected=
                "True";
            Assert.AreEqual(expected, given.repr);
            // d does not require gradients and so has no operation creating it (that is tracked by the autograd engine)
             given=  e = torch.rand(10).cuda().requires_grad_();
             given=  e.is_leaf;
             expected=
                "True";
            Assert.AreEqual(expected, given.repr);
            // e requires gradients and has no operations creating it
             given=  f = torch.rand(10, requires_grad=True, device="cuda");
             given=  f.is_leaf;
             expected=
                "True";
            Assert.AreEqual(expected, given.repr);
            // f requires grad, has no operation creating it
#endif
        }


        [TestMethod]
        public void itemTest()
        {
            // >>> x = torch.tensor([1.0])
            // >>> x.item()
            // 1.0
            // 

#if TODO
            var given=  x = torch.tensor({1.0});
             given=  x.item();
            var expected=
                "1.0";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void map_Test()
        {
            // def callable(a, b) -> number
            // 

#if TODO
            var expected=
                "def callable(a, b) -> number";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void permuteTest()
        {
            // >>> x = torch.randn(2, 3, 5)
            // >>> x.size()
            // torch.Size([2, 3, 5])
            // >>> x.permute(2, 0, 1).size()
            // torch.Size([5, 2, 3])
            // 

#if TODO
            var given=  x = torch.randn(2, 3, 5);
             given=  x.size();
            var expected=
                "torch.Size([2, 3, 5])";
            Assert.AreEqual(expected, given.repr);
             given=  x.permute(2, 0, 1).size();
             expected=
                "torch.Size([5, 2, 3])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void put_Test()
        {
            // >>> src = torch.tensor([[4, 3, 5],
            //                         [6, 7, 8]])
            // >>> src.put_(torch.tensor([1, 3]), torch.tensor([9, 10]))
            // tensor([[  4,   9,   5],
            //         [ 10,   7,   8]])
            // 

#if TODO
            var given=  src = torch.tensor({{4, 3, 5},;
            var expected=
                "                        [6, 7, 8]])";
            Assert.AreEqual(expected, given.repr);
             given=  src.put_(torch.tensor({1, 3}), torch.tensor({9, 10}));
             expected=
                "tensor([[  4,   9,   5],\n" +
                "        [ 10,   7,   8]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void register_hookTest()
        {
            // hook(grad) -> Tensor or None
            // 

#if TODO
            var expected=
                "hook(grad) -> Tensor or None";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> v = torch.tensor([0., 0., 0.], requires_grad=True)
            // >>> h = v.register_hook(lambda grad: grad * 2)  # double the gradient
            // >>> v.backward(torch.tensor([1., 2., 3.]))
            // >>> v.grad
            // 
            //  2
            //  4
            //  6
            // [torch.FloatTensor of size (3,)]
            // 
            // >>> h.remove()  # removes the hook
            // 

#if TODO
            var given=  v = torch.tensor({0., 0., 0.}, requires_grad=True);
             given=  h = v.register_hook(lambda grad: grad * 2)  # double the gradient;
             given=  v.backward(torch.tensor({1., 2., 3.}));
             given=  v.grad;
             expected=
                "\n" +
                " 2\n" +
                " 4\n" +
                " 6\n" +
                "[torch.FloatTensor of size (3,)]\n" +
                "";
            Assert.AreEqual(expected, given.repr);
             given=  h.remove()  # removes the hook;
#endif
        }


        [TestMethod]
        public void repeatTest()
        {
            // >>> x = torch.tensor([1, 2, 3])
            // >>> x.repeat(4, 2)
            // tensor([[ 1,  2,  3,  1,  2,  3],
            //         [ 1,  2,  3,  1,  2,  3],
            //         [ 1,  2,  3,  1,  2,  3],
            //         [ 1,  2,  3,  1,  2,  3]])
            // >>> x.repeat(4, 2, 1).size()
            // torch.Size([4, 2, 3])
            // 

#if TODO
            var given=  x = torch.tensor({1, 2, 3});
             given=  x.repeat(4, 2);
            var expected=
                "tensor([[ 1,  2,  3,  1,  2,  3],\n" +
                "        [ 1,  2,  3,  1,  2,  3],\n" +
                "        [ 1,  2,  3,  1,  2,  3],\n" +
                "        [ 1,  2,  3,  1,  2,  3]])";
            Assert.AreEqual(expected, given.repr);
             given=  x.repeat(4, 2, 1).size();
             expected=
                "torch.Size([4, 2, 3])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void requires_grad_Test()
        {
            // >>> # Let's say we want to preprocess some saved weights and use
            // >>> # the result as new weights.
            // >>> saved_weights = [0.1, 0.2, 0.3, 0.25]
            // >>> loaded_weights = torch.tensor(saved_weights)
            // >>> weights = preprocess(loaded_weights)  # some function
            // >>> weights
            // tensor([-0.5503,  0.4926, -2.1158, -0.8303])
            // 
            // >>> # Now, start to record operations done to weights
            // >>> weights.requires_grad_()
            // >>> out = weights.pow(2).sum()
            // >>> out.backward()
            // >>> weights.grad
            // tensor([-1.1007,  0.9853, -4.2316, -1.6606])
            // 

#if TODO
            var given=  # Let's say we want to preprocess some saved weights and use;
             given=  # the result as new weights.;
             given=  saved_weights = [0.1, 0.2, 0.3, 0.25];
             given=  loaded_weights = torch.tensor(saved_weights);
             given=  weights = preprocess(loaded_weights)  # some function;
             given=  weights;
            var expected=
                "tensor([-0.5503,  0.4926, -2.1158, -0.8303])\n" +
                "";
            Assert.AreEqual(expected, given.repr);
             given=  # Now, start to record operations done to weights;
             given=  weights.requires_grad_();
             given=  out = weights.pow(2).sum();
             given=  out.backward();
             given=  weights.grad;
             expected=
                "tensor([-1.1007,  0.9853, -4.2316, -1.6606])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void resize_Test()
        {
            // >>> x = torch.tensor([[1, 2], [3, 4], [5, 6]])
            // >>> x.resize_(2, 2)
            // tensor([[ 1,  2],
            //         [ 3,  4]])
            // 

#if TODO
            var given=  x = torch.tensor({{1, 2}, {3, 4}, {5, 6}});
             given=  x.resize_(2, 2);
            var expected=
                "tensor([[ 1,  2],\n" +
                "        [ 3,  4]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void scatter_Test()
        {
            // self[index[i][j][k]][j][k] = src[i][j][k]  # if dim == 0
            // self[i][index[i][j][k]][k] = src[i][j][k]  # if dim == 1
            // self[i][j][index[i][j][k]] = src[i][j][k]  # if dim == 2
            // 

#if TODO
            var expected=
                "self[index[i][j][k]][j][k] = src[i][j][k]  # if dim == 0\n" +
                "self[i][index[i][j][k]][k] = src[i][j][k]  # if dim == 1\n" +
                "self[i][j][index[i][j][k]] = src[i][j][k]  # if dim == 2";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> x = torch.rand(2, 5)
            // >>> x
            // tensor([[ 0.3992,  0.2908,  0.9044,  0.4850,  0.6004],
            //         [ 0.5735,  0.9006,  0.6797,  0.4152,  0.1732]])
            // >>> torch.zeros(3, 5).scatter_(0, torch.tensor([[0, 1, 2, 0, 0], [2, 0, 0, 1, 2]]), x)
            // tensor([[ 0.3992,  0.9006,  0.6797,  0.4850,  0.6004],
            //         [ 0.0000,  0.2908,  0.0000,  0.4152,  0.0000],
            //         [ 0.5735,  0.0000,  0.9044,  0.0000,  0.1732]])
            // 
            // >>> z = torch.zeros(2, 4).scatter_(1, torch.tensor([[2], [3]]), 1.23)
            // >>> z
            // tensor([[ 0.0000,  0.0000,  1.2300,  0.0000],
            //         [ 0.0000,  0.0000,  0.0000,  1.2300]])
            // 

#if TODO
            var given=  x = torch.rand(2, 5);
             given=  x;
             expected=
                "tensor([[ 0.3992,  0.2908,  0.9044,  0.4850,  0.6004],\n" +
                "        [ 0.5735,  0.9006,  0.6797,  0.4152,  0.1732]])";
            Assert.AreEqual(expected, given.repr);
             given=  torch.zeros(3, 5).scatter_(0, torch.tensor({{0, 1, 2, 0, 0}, {2, 0, 0, 1, 2}}), x);
             expected=
                "tensor([[ 0.3992,  0.9006,  0.6797,  0.4850,  0.6004],\n" +
                "        [ 0.0000,  0.2908,  0.0000,  0.4152,  0.0000],\n" +
                "        [ 0.5735,  0.0000,  0.9044,  0.0000,  0.1732]])\n" +
                "";
            Assert.AreEqual(expected, given.repr);
             given=  z = torch.zeros(2, 4).scatter_(1, torch.tensor({{2}, {3}}), 1.23);
             given=  z;
             expected=
                "tensor([[ 0.0000,  0.0000,  1.2300,  0.0000],\n" +
                "        [ 0.0000,  0.0000,  0.0000,  1.2300]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void scatter_add_Test()
        {
            // self[index[i][j][k]][j][k] += other[i][j][k]  # if dim == 0
            // self[i][index[i][j][k]][k] += other[i][j][k]  # if dim == 1
            // self[i][j][index[i][j][k]] += other[i][j][k]  # if dim == 2
            // 

#if TODO
            var expected=
                "self[index[i][j][k]][j][k] += other[i][j][k]  # if dim == 0\n" +
                "self[i][index[i][j][k]][k] += other[i][j][k]  # if dim == 1\n" +
                "self[i][j][index[i][j][k]] += other[i][j][k]  # if dim == 2";
            Assert.AreEqual(expected, given.repr);
#endif
            // >>> x = torch.rand(2, 5)
            // >>> x
            // tensor([[0.7404, 0.0427, 0.6480, 0.3806, 0.8328],
            //         [0.7953, 0.2009, 0.9154, 0.6782, 0.9620]])
            // >>> torch.ones(3, 5).scatter_add_(0, torch.tensor([[0, 1, 2, 0, 0], [2, 0, 0, 1, 2]]), x)
            // tensor([[1.7404, 1.2009, 1.9154, 1.3806, 1.8328],
            //         [1.0000, 1.0427, 1.0000, 1.6782, 1.0000],
            //         [1.7953, 1.0000, 1.6480, 1.0000, 1.9620]])
            // 

#if TODO
            var given=  x = torch.rand(2, 5);
             given=  x;
             expected=
                "tensor([[0.7404, 0.0427, 0.6480, 0.3806, 0.8328],\n" +
                "        [0.7953, 0.2009, 0.9154, 0.6782, 0.9620]])";
            Assert.AreEqual(expected, given.repr);
             given=  torch.ones(3, 5).scatter_add_(0, torch.tensor({{0, 1, 2, 0, 0}, {2, 0, 0, 1, 2}}), x);
             expected=
                "tensor([[1.7404, 1.2009, 1.9154, 1.3806, 1.8328],\n" +
                "        [1.0000, 1.0427, 1.0000, 1.6782, 1.0000],\n" +
                "        [1.7953, 1.0000, 1.6480, 1.0000, 1.9620]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void sizeTest()
        {
            // >>> torch.empty(3, 4, 5).size()
            // torch.Size([3, 4, 5])
            // 

#if TODO
            var given=  torch.empty(3, 4, 5).size();
            var expected=
                "torch.Size([3, 4, 5])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void sparse_maskTest()
        {
            // >>> nnz = 5
            // >>> dims = [5, 5, 2, 2]
            // >>> I = torch.cat([torch.randint(0, dims[0], size=(nnz,)),
            //                    torch.randint(0, dims[1], size=(nnz,))], 0).reshape(2, nnz)
            // >>> V = torch.randn(nnz, dims[2], dims[3])
            // >>> size = torch.Size(dims)
            // >>> S = torch.sparse_coo_tensor(I, V, size).coalesce()
            // >>> D = torch.randn(dims)
            // >>> D.sparse_mask(S)
            // tensor(indices=tensor([[0, 0, 0, 2],
            //                        [0, 1, 4, 3]]),
            //        values=tensor([[[ 1.6550,  0.2397],
            //                        [-0.1611, -0.0779]],
            // 
            //                       [[ 0.2326, -1.0558],
            //                        [ 1.4711,  1.9678]],
            // 
            //                       [[-0.5138, -0.0411],
            //                        [ 1.9417,  0.5158]],
            // 
            //                       [[ 0.0793,  0.0036],
            //                        [-0.2569, -0.1055]]]),
            //        size=(5, 5, 2, 2), nnz=4, layout=torch.sparse_coo)
            // 

#if TODO
            var given=  nnz = 5;
             given=  dims = [5, 5, 2, 2];
             given=  I = torch.cat({torch.randint(0, dims{0}, size=(nnz,)),;
            var expected=
                "                   torch.randint(0, dims[1], size=(nnz,))], 0).reshape(2, nnz)";
            Assert.AreEqual(expected, given.repr);
             given=  V = torch.randn(nnz, dims{2}, dims{3});
             given=  size = torch.Size(dims);
             given=  S = torch.sparse_coo_tensor(I, V, size).coalesce();
             given=  D = torch.randn(dims);
             given=  D.sparse_mask(S);
             expected=
                "tensor(indices=tensor([[0, 0, 0, 2],\n" +
                "                       [0, 1, 4, 3]]),\n" +
                "       values=tensor([[[ 1.6550,  0.2397],\n" +
                "                       [-0.1611, -0.0779]],\n" +
                "\n" +
                "                      [[ 0.2326, -1.0558],\n" +
                "                       [ 1.4711,  1.9678]],\n" +
                "\n" +
                "                      [[-0.5138, -0.0411],\n" +
                "                       [ 1.9417,  0.5158]],\n" +
                "\n" +
                "                      [[ 0.0793,  0.0036],\n" +
                "                       [-0.2569, -0.1055]]]),\n" +
                "       size=(5, 5, 2, 2), nnz=4, layout=torch.sparse_coo)";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void storage_offsetTest()
        {
            // >>> x = torch.tensor([1, 2, 3, 4, 5])
            // >>> x.storage_offset()
            // 0
            // >>> x[3:].storage_offset()
            // 3
            // 

#if TODO
            var given=  x = torch.tensor({1, 2, 3, 4, 5});
             given=  x.storage_offset();
            var expected=
                "0";
            Assert.AreEqual(expected, given.repr);
             given=  x[3:].storage_offset();
             expected=
                "3";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void strideTest()
        {
            // >>> x = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])
            // >>> x.stride()
            // (5, 1)
            // >>>x.stride(0)
            // 5
            // >>> x.stride(-1)
            // 1
            // 

#if TODO
            var given=  x = torch.tensor({{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}});
             given=  x.stride();
            var expected=
                "(5, 1)";
            Assert.AreEqual(expected, given.repr);
             given= x.stride(0);
             expected=
                "5";
            Assert.AreEqual(expected, given.repr);
             given=  x.stride(-1);
             expected=
                "1";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void toTest()
        {
            // >>> tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu
            // >>> tensor.to(torch.float64)
            // tensor([[-0.5044,  0.0005],
            //         [ 0.3310, -0.0584]], dtype=torch.float64)
            // 
            // >>> cuda0 = torch.device('cuda:0')
            // >>> tensor.to(cuda0)
            // tensor([[-0.5044,  0.0005],
            //         [ 0.3310, -0.0584]], device='cuda:0')
            // 
            // >>> tensor.to(cuda0, dtype=torch.float64)
            // tensor([[-0.5044,  0.0005],
            //         [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')
            // 
            // >>> other = torch.randn((), dtype=torch.float64, device=cuda0)
            // >>> tensor.to(other, non_blocking=True)
            // tensor([[-0.5044,  0.0005],
            //         [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')
            // 

#if TODO
            var given=  tensor = torch.randn(2, 2)  # Initially dtype=float32, device=cpu;
             given=  tensor.to(torch.float64);
            var expected=
                "tensor([[-0.5044,  0.0005],\n" +
                "        [ 0.3310, -0.0584]], dtype=torch.float64)\n" +
                "";
            Assert.AreEqual(expected, given.repr);
             given=  cuda0 = torch.device('cuda:0');
             given=  tensor.to(cuda0);
             expected=
                "tensor([[-0.5044,  0.0005],\n" +
                "        [ 0.3310, -0.0584]], device='cuda:0')\n" +
                "";
            Assert.AreEqual(expected, given.repr);
             given=  tensor.to(cuda0, dtype=torch.float64);
             expected=
                "tensor([[-0.5044,  0.0005],\n" +
                "        [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')\n" +
                "";
            Assert.AreEqual(expected, given.repr);
             given=  other = torch.randn((), dtype=torch.float64, device=cuda0);
             given=  tensor.to(other, non_blocking=True);
             expected=
                "tensor([[-0.5044,  0.0005],\n" +
                "        [ 0.3310, -0.0584]], dtype=torch.float64, device='cuda:0')";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void tolistTest()
        {
            // >>> a = torch.randn(2, 2)
            // >>> a.tolist()
            // [[0.012766935862600803, 0.5415473580360413],
            //  [-0.08909505605697632, 0.7729271650314331]]
            // >>> a[0,0].tolist()
            // 0.012766935862600803
            // 

#if TODO
            var given=  a = torch.randn(2, 2);
             given=  a.tolist();
            var expected=
                "[[0.012766935862600803, 0.5415473580360413],\n" +
                " [-0.08909505605697632, 0.7729271650314331]]";
            Assert.AreEqual(expected, given.repr);
             given=  a[0,0].tolist();
             expected=
                "0.012766935862600803";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void to_sparseTest()
        {
            // >>> d = torch.tensor([[0, 0, 0], [9, 0, 10], [0, 0, 0]])
            // >>> d
            // tensor([[ 0,  0,  0],
            //         [ 9,  0, 10],
            //         [ 0,  0,  0]])
            // >>> d.to_sparse()
            // tensor(indices=tensor([[1, 1],
            //                        [0, 2]]),
            //        values=tensor([ 9, 10]),
            //        size=(3, 3), nnz=2, layout=torch.sparse_coo)
            // >>> d.to_sparse(1)
            // tensor(indices=tensor([[1]]),
            //        values=tensor([[ 9,  0, 10]]),
            //        size=(3, 3), nnz=1, layout=torch.sparse_coo)
            // 

#if TODO
            var given=  d = torch.tensor({{0, 0, 0}, {9, 0, 10}, {0, 0, 0}});
             given=  d;
            var expected=
                "tensor([[ 0,  0,  0],\n" +
                "        [ 9,  0, 10],\n" +
                "        [ 0,  0,  0]])";
            Assert.AreEqual(expected, given.repr);
             given=  d.to_sparse();
             expected=
                "tensor(indices=tensor([[1, 1],\n" +
                "                       [0, 2]]),\n" +
                "       values=tensor([ 9, 10]),\n" +
                "       size=(3, 3), nnz=2, layout=torch.sparse_coo)";
            Assert.AreEqual(expected, given.repr);
             given=  d.to_sparse(1);
             expected=
                "tensor(indices=tensor([[1]]),\n" +
                "       values=tensor([[ 9,  0, 10]]),\n" +
                "       size=(3, 3), nnz=1, layout=torch.sparse_coo)";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void unfoldTest()
        {
            // >>> x = torch.arange(1., 8)
            // >>> x
            // tensor([ 1.,  2.,  3.,  4.,  5.,  6.,  7.])
            // >>> x.unfold(0, 2, 1)
            // tensor([[ 1.,  2.],
            //         [ 2.,  3.],
            //         [ 3.,  4.],
            //         [ 4.,  5.],
            //         [ 5.,  6.],
            //         [ 6.,  7.]])
            // >>> x.unfold(0, 2, 2)
            // tensor([[ 1.,  2.],
            //         [ 3.,  4.],
            //         [ 5.,  6.]])
            // 

#if TODO
            var given=  x = torch.arange(1., 8);
             given=  x;
            var expected=
                "tensor([ 1.,  2.,  3.,  4.,  5.,  6.,  7.])";
            Assert.AreEqual(expected, given.repr);
             given=  x.unfold(0, 2, 1);
             expected=
                "tensor([[ 1.,  2.],\n" +
                "        [ 2.,  3.],\n" +
                "        [ 3.,  4.],\n" +
                "        [ 4.,  5.],\n" +
                "        [ 5.,  6.],\n" +
                "        [ 6.,  7.]])";
            Assert.AreEqual(expected, given.repr);
             given=  x.unfold(0, 2, 2);
             expected=
                "tensor([[ 1.,  2.],\n" +
                "        [ 3.,  4.],\n" +
                "        [ 5.,  6.]])";
            Assert.AreEqual(expected, given.repr);
#endif
        }


        [TestMethod]
        public void viewTest()
        {
            // >>> x = torch.randn(4, 4)
            // >>> x.size()
            // torch.Size([4, 4])
            // >>> y = x.view(16)
            // >>> y.size()
            // torch.Size([16])
            // >>> z = x.view(-1, 8)  # the size -1 is inferred from other dimensions
            // >>> z.size()
            // torch.Size([2, 8])
            // 
            // >>> a = torch.randn(1, 2, 3, 4)
            // >>> a.size()
            // torch.Size([1, 2, 3, 4])
            // >>> b = a.transpose(1, 2)  # Swaps 2nd and 3rd dimension
            // >>> b.size()
            // torch.Size([1, 3, 2, 4])
            // >>> c = a.view(1, 3, 2, 4)  # Does not change tensor layout in memory
            // >>> c.size()
            // torch.Size([1, 3, 2, 4])
            // >>> torch.equal(b, c)
            // False
            // 

#if TODO
            var given=  x = torch.randn(4, 4);
             given=  x.size();
            var expected=
                "torch.Size([4, 4])";
            Assert.AreEqual(expected, given.repr);
             given=  y = x.view(16);
             given=  y.size();
             expected=
                "torch.Size([16])";
            Assert.AreEqual(expected, given.repr);
             given=  z = x.view(-1, 8)  # the size -1 is inferred from other dimensions;
             given=  z.size();
             expected=
                "torch.Size([2, 8])\n" +
                "";
            Assert.AreEqual(expected, given.repr);
             given=  a = torch.randn(1, 2, 3, 4);
             given=  a.size();
             expected=
                "torch.Size([1, 2, 3, 4])";
            Assert.AreEqual(expected, given.repr);
             given=  b = a.transpose(1, 2)  # Swaps 2nd and 3rd dimension;
             given=  b.size();
             expected=
                "torch.Size([1, 3, 2, 4])";
            Assert.AreEqual(expected, given.repr);
             given=  c = a.view(1, 3, 2, 4)  # Does not change tensor layout in memory;
             given=  c.size();
             expected=
                "torch.Size([1, 3, 2, 4])";
            Assert.AreEqual(expected, given.repr);
             given=  torch.equal(b, c);
             expected=
                "False";
            Assert.AreEqual(expected, given.repr);
#endif
        }

    }
}
