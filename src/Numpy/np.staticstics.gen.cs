// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Python.Runtime;
using Python.Included;
using Numpy.Models;

namespace Numpy
{
    public static partial class np
    {
        
        /// <summary>
        /// Return the minimum of an array or minimum along an axis.
        /// 
        /// Notes
        /// 
        /// NaN values are propagated, that is if at least one item is NaN, the
        /// corresponding min value will be NaN as well. To ignore NaN values
        /// (MATLAB behavior), please use nanmin.
        /// 
        /// Don’t use amin for element-wise comparison of 2 arrays; when
        /// a.shape[0] is 2, minimum(a[0], a[1]) is faster than
        /// amin(a, axis=0).
        /// </summary>
        /// <param name="a">
        /// Input data.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which to operate.  By default, flattened input is
        /// used.
        /// 
        /// If this is a tuple of ints, the minimum is selected over multiple axes,
        /// instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result.  Must
        /// be of the same shape and buffer length as the expected output.
        /// See doc.ufuncs (Section “Output arguments”) for more details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the amin method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <param name="initial">
        /// The maximum value of an output element. Must be present to allow
        /// computation on empty slice. See reduce for details.
        /// </param>
        /// <returns>
        /// Minimum of a. If axis is None, the result is a scalar value.
        /// If axis is given, the result is an array of dimension
        /// a.ndim - 1.
        /// </returns>
        public static NDarray amin(NDarray a, int[] axis = null, NDarray @out = null, bool? keepdims = null, ValueType initial = null)
            => NumPy.Instance.amin(a, axis:axis, @out:@out, keepdims:keepdims, initial:initial);
        
        /// <summary>
        /// Return the maximum of an array or maximum along an axis.
        /// 
        /// Notes
        /// 
        /// NaN values are propagated, that is if at least one item is NaN, the
        /// corresponding max value will be NaN as well. To ignore NaN values
        /// (MATLAB behavior), please use nanmax.
        /// 
        /// Don’t use amax for element-wise comparison of 2 arrays; when
        /// a.shape[0] is 2, maximum(a[0], a[1]) is faster than
        /// amax(a, axis=0).
        /// </summary>
        /// <param name="a">
        /// Input data.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which to operate.  By default, flattened input is
        /// used.
        /// 
        /// If this is a tuple of ints, the maximum is selected over multiple axes,
        /// instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result.  Must
        /// be of the same shape and buffer length as the expected output.
        /// See doc.ufuncs (Section “Output arguments”) for more details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the amax method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <param name="initial">
        /// The minimum value of an output element. Must be present to allow
        /// computation on empty slice. See reduce for details.
        /// </param>
        /// <returns>
        /// Maximum of a. If axis is None, the result is a scalar value.
        /// If axis is given, the result is an array of dimension
        /// a.ndim - 1.
        /// </returns>
        public static NDarray amax(NDarray a, int[] axis = null, NDarray @out = null, bool? keepdims = null, ValueType initial = null)
            => NumPy.Instance.amax(a, axis:axis, @out:@out, keepdims:keepdims, initial:initial);
        
        /// <summary>
        /// Return minimum of an array or minimum along an axis, ignoring any NaNs.
        /// When all-NaN slices are encountered a RuntimeWarning is raised and
        /// Nan is returned for that slice.
        /// 
        /// Notes
        /// 
        /// NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
        /// (IEEE 754). This means that Not a Number is not equivalent to infinity.
        /// Positive infinity is treated as a very large number and negative
        /// infinity is treated as a very small (i.e. negative) number.
        /// 
        /// If the input has a integer type the function is equivalent to np.min.
        /// </summary>
        /// <param name="a">
        /// Array containing numbers whose minimum is desired. If a is not an
        /// array, a conversion is attempted.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the minimum is computed. The default is to compute
        /// the minimum of the flattened array.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None; if provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.  See
        /// doc.ufuncs for details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// 
        /// If the value is anything but the default, then
        /// keepdims will be passed through to the min method
        /// of sub-classes of ndarray.  If the sub-classes methods
        /// does not implement keepdims any exceptions will be raised.
        /// </param>
        /// <returns>
        /// An array with the same shape as a, with the specified axis
        /// removed.  If a is a 0-d array, or if axis is None, an ndarray
        /// scalar is returned.  The same dtype as a is returned.
        /// </returns>
        public static NDarray nanmin(NDarray a, int[] axis = null, NDarray @out = null, bool? keepdims = null)
            => NumPy.Instance.nanmin(a, axis:axis, @out:@out, keepdims:keepdims);
        
        /// <summary>
        /// Return the maximum of an array or maximum along an axis, ignoring any
        /// NaNs.  When all-NaN slices are encountered a RuntimeWarning is
        /// raised and NaN is returned for that slice.
        /// 
        /// Notes
        /// 
        /// NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
        /// (IEEE 754). This means that Not a Number is not equivalent to infinity.
        /// Positive infinity is treated as a very large number and negative
        /// infinity is treated as a very small (i.e. negative) number.
        /// 
        /// If the input has a integer type the function is equivalent to np.max.
        /// </summary>
        /// <param name="a">
        /// Array containing numbers whose maximum is desired. If a is not an
        /// array, a conversion is attempted.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the maximum is computed. The default is to compute
        /// the maximum of the flattened array.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None; if provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.  See
        /// doc.ufuncs for details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// 
        /// If the value is anything but the default, then
        /// keepdims will be passed through to the max method
        /// of sub-classes of ndarray.  If the sub-classes methods
        /// does not implement keepdims any exceptions will be raised.
        /// </param>
        /// <returns>
        /// An array with the same shape as a, with the specified axis removed.
        /// If a is a 0-d array, or if axis is None, an ndarray scalar is
        /// returned.  The same dtype as a is returned.
        /// </returns>
        public static NDarray nanmax(NDarray a, int[] axis = null, NDarray @out = null, bool? keepdims = null)
            => NumPy.Instance.nanmax(a, axis:axis, @out:@out, keepdims:keepdims);
        
        /// <summary>
        /// Range of values (maximum - minimum) along an axis.
        /// 
        /// The name of the function comes from the acronym for ‘peak to peak’.
        /// </summary>
        /// <param name="a">
        /// Input values.
        /// </param>
        /// <param name="axis">
        /// Axis along which to find the peaks.  By default, flatten the
        /// array.  axis may be negative, in
        /// which case it counts from the last to the first axis.
        /// 
        /// If this is a tuple of ints, a reduction is performed on multiple
        /// axes, instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type of the output values will be cast if necessary.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the ptp method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <returns>
        /// A new array holding the result, unless out was
        /// specified, in which case a reference to out is returned.
        /// </returns>
        public static NDarray ptp(NDarray a, int[] axis = null, NDarray @out = null, bool? keepdims = null)
            => NumPy.Instance.ptp(a, axis:axis, @out:@out, keepdims:keepdims);
        
        /// <summary>
        /// Compute the q-th percentile of the data along the specified axis.
        /// 
        /// Returns the q-th percentile(s) of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the q-th percentile of
        /// V is the value q/100 of the way from the minimum to the
        /// maximum in a sorted copy of V. The values and distances of
        /// the two nearest neighbors as well as the interpolation parameter
        /// will determine the percentile if the normalized ranking does not
        /// match the location of q exactly. This function is the same as
        /// the median if q=50, the same as the minimum if q=0 and the
        /// same as the maximum if q=100.
        /// </summary>
        /// <param name="a">
        /// Input array or object that can be converted to an array.
        /// </param>
        /// <param name="q">
        /// Percentile or sequence of percentiles to compute, which must be between
        /// 0 and 100 inclusive.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the percentiles are computed. The
        /// default is to compute the percentile(s) along a flattened
        /// version of the array.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired percentile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left in
        /// the result as dimensions with size one. With this option, the
        /// result will broadcast correctly against the original array a.
        /// </param>
        /// <returns>
        /// If q is a single percentile and axis=None, then the result
        /// is a scalar. If multiple percentiles are given, first axis of
        /// the result corresponds to the percentiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public static NDarray<double> percentile(NDarray a, NDarray<float> q, int[] axis, NDarray @out = null, bool? overwrite_input = false, string interpolation = "linear", bool? keepdims = false)
            => NumPy.Instance.percentile(a, q, axis:axis, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation, keepdims:keepdims);
        
        /// <summary>
        /// Compute the q-th percentile of the data along the specified axis.
        /// 
        /// Returns the q-th percentile(s) of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the q-th percentile of
        /// V is the value q/100 of the way from the minimum to the
        /// maximum in a sorted copy of V. The values and distances of
        /// the two nearest neighbors as well as the interpolation parameter
        /// will determine the percentile if the normalized ranking does not
        /// match the location of q exactly. This function is the same as
        /// the median if q=50, the same as the minimum if q=0 and the
        /// same as the maximum if q=100.
        /// </summary>
        /// <param name="a">
        /// Input array or object that can be converted to an array.
        /// </param>
        /// <param name="q">
        /// Percentile or sequence of percentiles to compute, which must be between
        /// 0 and 100 inclusive.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired percentile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <returns>
        /// If q is a single percentile and axis=None, then the result
        /// is a scalar. If multiple percentiles are given, first axis of
        /// the result corresponds to the percentiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public static double percentile(NDarray a, NDarray<float> q, NDarray @out = null, bool? overwrite_input = false, string interpolation = "linear")
            => NumPy.Instance.percentile(a, q, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation);
        
        /// <summary>
        /// Compute the qth percentile of the data along the specified axis,
        /// while ignoring nan values.
        /// 
        /// Returns the qth percentile(s) of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the q-th percentile of
        /// V is the value q/100 of the way from the minimum to the
        /// maximum in a sorted copy of V. The values and distances of
        /// the two nearest neighbors as well as the interpolation parameter
        /// will determine the percentile if the normalized ranking does not
        /// match the location of q exactly. This function is the same as
        /// the median if q=50, the same as the minimum if q=0 and the
        /// same as the maximum if q=100.
        /// </summary>
        /// <param name="a">
        /// Input array or object that can be converted to an array, containing
        /// nan values to be ignored.
        /// </param>
        /// <param name="q">
        /// Percentile or sequence of percentiles to compute, which must be between
        /// 0 and 100 inclusive.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the percentiles are computed. The
        /// default is to compute the percentile(s) along a flattened
        /// version of the array.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired percentile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left in
        /// the result as dimensions with size one. With this option, the
        /// result will broadcast correctly against the original array a.
        /// 
        /// If this is anything but the default value it will be passed
        /// through (in the special case of an empty array) to the
        /// mean function of the underlying array.  If the array is
        /// a sub-class and mean does not have the kwarg keepdims this
        /// will raise a RuntimeError.
        /// </param>
        /// <returns>
        /// If q is a single percentile and axis=None, then the result
        /// is a scalar. If multiple percentiles are given, first axis of
        /// the result corresponds to the percentiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public static NDarray<double> nanpercentile(NDarray a, NDarray<float> q, int[] axis, NDarray @out = null, bool? overwrite_input = false, string interpolation = "linear", bool? keepdims = null)
            => NumPy.Instance.nanpercentile(a, q, axis:axis, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation, keepdims:keepdims);
        
        /// <summary>
        /// Compute the qth percentile of the data along the specified axis,
        /// while ignoring nan values.
        /// 
        /// Returns the qth percentile(s) of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the q-th percentile of
        /// V is the value q/100 of the way from the minimum to the
        /// maximum in a sorted copy of V. The values and distances of
        /// the two nearest neighbors as well as the interpolation parameter
        /// will determine the percentile if the normalized ranking does not
        /// match the location of q exactly. This function is the same as
        /// the median if q=50, the same as the minimum if q=0 and the
        /// same as the maximum if q=100.
        /// </summary>
        /// <param name="a">
        /// Input array or object that can be converted to an array, containing
        /// nan values to be ignored.
        /// </param>
        /// <param name="q">
        /// Percentile or sequence of percentiles to compute, which must be between
        /// 0 and 100 inclusive.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired percentile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <returns>
        /// If q is a single percentile and axis=None, then the result
        /// is a scalar. If multiple percentiles are given, first axis of
        /// the result corresponds to the percentiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public static double nanpercentile(NDarray a, NDarray<float> q, NDarray @out = null, bool? overwrite_input = false, string interpolation = "linear")
            => NumPy.Instance.nanpercentile(a, q, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation);
        
        /// <summary>
        /// Compute the q-th quantile of the data along the specified axis.
        /// ..versionadded:: 1.15.0
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the q-th quantile of
        /// V is the value q of the way from the minimum to the
        /// maximum in a sorted copy of V. The values and distances of
        /// the two nearest neighbors as well as the interpolation parameter
        /// will determine the quantile if the normalized ranking does not
        /// match the location of q exactly. This function is the same as
        /// the median if q=0.5, the same as the minimum if q=0.0 and the
        /// same as the maximum if q=1.0.
        /// </summary>
        /// <param name="a">
        /// Input array or object that can be converted to an array.
        /// </param>
        /// <param name="q">
        /// Quantile or sequence of quantiles to compute, which must be between
        /// 0 and 1 inclusive.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the quantiles are computed. The
        /// default is to compute the quantile(s) along a flattened
        /// version of the array.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired quantile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left in
        /// the result as dimensions with size one. With this option, the
        /// result will broadcast correctly against the original array a.
        /// </param>
        /// <returns>
        /// If q is a single quantile and axis=None, then the result
        /// is a scalar. If multiple quantiles are given, first axis of
        /// the result corresponds to the quantiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public static NDarray<double> quantile(NDarray a, NDarray<float> q, int[] axis, NDarray @out = null, bool? overwrite_input = false, string interpolation = "linear", bool? keepdims = false)
            => NumPy.Instance.quantile(a, q, axis:axis, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation, keepdims:keepdims);
        
        /// <summary>
        /// Compute the q-th quantile of the data along the specified axis.
        /// ..versionadded:: 1.15.0
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the q-th quantile of
        /// V is the value q of the way from the minimum to the
        /// maximum in a sorted copy of V. The values and distances of
        /// the two nearest neighbors as well as the interpolation parameter
        /// will determine the quantile if the normalized ranking does not
        /// match the location of q exactly. This function is the same as
        /// the median if q=0.5, the same as the minimum if q=0.0 and the
        /// same as the maximum if q=1.0.
        /// </summary>
        /// <param name="a">
        /// Input array or object that can be converted to an array.
        /// </param>
        /// <param name="q">
        /// Quantile or sequence of quantiles to compute, which must be between
        /// 0 and 1 inclusive.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired quantile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <returns>
        /// If q is a single quantile and axis=None, then the result
        /// is a scalar. If multiple quantiles are given, first axis of
        /// the result corresponds to the quantiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public static double quantile(NDarray a, NDarray<float> q, NDarray @out = null, bool? overwrite_input = false, string interpolation = "linear")
            => NumPy.Instance.quantile(a, q, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation);
        
        /// <summary>
        /// Compute the qth quantile of the data along the specified axis,
        /// while ignoring nan values.
        /// Returns the qth quantile(s) of the array elements.
        /// .. versionadded:: 1.15.0
        /// </summary>
        /// <param name="a">
        /// Input array or object that can be converted to an array, containing
        /// nan values to be ignored
        /// </param>
        /// <param name="q">
        /// Quantile or sequence of quantiles to compute, which must be between
        /// 0 and 1 inclusive.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the quantiles are computed. The
        /// default is to compute the quantile(s) along a flattened
        /// version of the array.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired quantile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left in
        /// the result as dimensions with size one. With this option, the
        /// result will broadcast correctly against the original array a.
        /// 
        /// If this is anything but the default value it will be passed
        /// through (in the special case of an empty array) to the
        /// mean function of the underlying array.  If the array is
        /// a sub-class and mean does not have the kwarg keepdims this
        /// will raise a RuntimeError.
        /// </param>
        /// <returns>
        /// If q is a single percentile and axis=None, then the result
        /// is a scalar. If multiple quantiles are given, first axis of
        /// the result corresponds to the quantiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public static NDarray<double> nanquantile(NDarray a, NDarray<float> q, int[] axis, NDarray @out = null, bool? overwrite_input = false, string interpolation = "linear", bool? keepdims = null)
            => NumPy.Instance.nanquantile(a, q, axis:axis, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation, keepdims:keepdims);
        
        /// <summary>
        /// Compute the qth quantile of the data along the specified axis,
        /// while ignoring nan values.
        /// Returns the qth quantile(s) of the array elements.
        /// .. versionadded:: 1.15.0
        /// </summary>
        /// <param name="a">
        /// Input array or object that can be converted to an array, containing
        /// nan values to be ignored
        /// </param>
        /// <param name="q">
        /// Quantile or sequence of quantiles to compute, which must be between
        /// 0 and 1 inclusive.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired quantile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <returns>
        /// If q is a single percentile and axis=None, then the result
        /// is a scalar. If multiple quantiles are given, first axis of
        /// the result corresponds to the quantiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public static double nanquantile(NDarray a, NDarray<float> q, NDarray @out = null, bool? overwrite_input = false, string interpolation = "linear")
            => NumPy.Instance.nanquantile(a, q, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation);
        
        /// <summary>
        /// Compute the median along the specified axis.
        /// 
        /// Returns the median of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the median of V is the
        /// middle value of a sorted copy of V, V_sorted - i
        /// e., V_sorted[(N-1)/2], when N is odd, and the average of the
        /// two middle values of V_sorted when N is even.
        /// </summary>
        /// <param name="a">
        /// Input array or object that can be converted to an array.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the medians are computed. The default
        /// is to compute the median along a flattened version of the array.
        /// A sequence of axes is supported since version 1.9.0.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow use of memory of input array a for
        /// calculations. The input array will be modified by the call to
        /// median. This will save memory when you do not need to preserve
        /// the contents of the input array. Treat the input as undefined,
        /// but it will probably be fully or partially sorted. Default is
        /// False. If overwrite_input is True and a is not already an
        /// ndarray, an error will be raised.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original arr.
        /// </param>
        /// <returns>
        /// A new array holding the result. If the input contains integers
        /// or floats smaller than float64, then the output data-type is
        /// np.float64.  Otherwise, the data-type of the output is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public static NDarray<double> median(NDarray a, int[] axis, NDarray @out = null, bool? overwrite_input = false, bool? keepdims = false)
            => NumPy.Instance.median(a, axis:axis, @out:@out, overwrite_input:overwrite_input, keepdims:keepdims);
        
        /// <summary>
        /// Compute the median along the specified axis.
        /// 
        /// Returns the median of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the median of V is the
        /// middle value of a sorted copy of V, V_sorted - i
        /// e., V_sorted[(N-1)/2], when N is odd, and the average of the
        /// two middle values of V_sorted when N is even.
        /// </summary>
        /// <param name="a">
        /// Input array or object that can be converted to an array.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow use of memory of input array a for
        /// calculations. The input array will be modified by the call to
        /// median. This will save memory when you do not need to preserve
        /// the contents of the input array. Treat the input as undefined,
        /// but it will probably be fully or partially sorted. Default is
        /// False. If overwrite_input is True and a is not already an
        /// ndarray, an error will be raised.
        /// </param>
        /// <returns>
        /// A new array holding the result. If the input contains integers
        /// or floats smaller than float64, then the output data-type is
        /// np.float64.  Otherwise, the data-type of the output is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public static double median(NDarray a, NDarray @out = null, bool? overwrite_input = false)
            => NumPy.Instance.median(a, @out:@out, overwrite_input:overwrite_input);
        
        /// <summary>
        /// Compute the weighted average along the specified axis.
        /// </summary>
        /// <param name="a">
        /// Array containing data to be averaged. If a is not an array, a
        /// conversion is attempted.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which to average a.  The default,
        /// axis=None, will average over all of the elements of the input array.
        /// If axis is negative it counts from the last to the first axis.
        /// 
        /// If axis is a tuple of ints, averaging is performed on all of the axes
        /// specified in the tuple instead of a single axis or all the axes as
        /// before.
        /// </param>
        /// <param name="weights">
        /// An array of weights associated with the values in a. Each value in
        /// a contributes to the average according to its associated weight.
        /// The weights array can either be 1-D (in which case its length must be
        /// the size of a along the given axis) or of the same shape as a.
        /// If weights=None, then all data in a are assumed to have a
        /// weight equal to one.
        /// </param>
        /// <param name="returned">
        /// Default is False. If True, the tuple (average, sum_of_weights)
        /// is returned, otherwise only the average is returned.
        /// If weights=None, sum_of_weights is equivalent to the number of
        /// elements over which the average is taken.
        /// </param>
        /// <returns>
        /// Return the average along the specified axis. When returned is True,
        /// return a tuple with the average as the first element and the sum
        /// of the weights as the second element. sum_of_weights is of the
        /// same type as retval. The result dtype follows a genereal pattern.
        /// If weights is None, the result dtype will be that of a , or float64
        /// if a is integral. Otherwise, if weights is not None and a is non-
        /// integral, the result type will be the type of lowest precision capable of
        /// representing values of both a and weights. If a happens to be
        /// integral, the previous rules still applies but the result dtype will
        /// at least be float64.
        /// </returns>
        public static NDarray<double> average(NDarray a, int[] axis, NDarray weights = null, bool? returned = false)
            => NumPy.Instance.average(a, axis:axis, weights:weights, returned:returned);
        
        /// <summary>
        /// Compute the weighted average along the specified axis.
        /// </summary>
        /// <param name="a">
        /// Array containing data to be averaged. If a is not an array, a
        /// conversion is attempted.
        /// </param>
        /// <param name="weights">
        /// An array of weights associated with the values in a. Each value in
        /// a contributes to the average according to its associated weight.
        /// The weights array can either be 1-D (in which case its length must be
        /// the size of a along the given axis) or of the same shape as a.
        /// If weights=None, then all data in a are assumed to have a
        /// weight equal to one.
        /// </param>
        /// <param name="returned">
        /// Default is False. If True, the tuple (average, sum_of_weights)
        /// is returned, otherwise only the average is returned.
        /// If weights=None, sum_of_weights is equivalent to the number of
        /// elements over which the average is taken.
        /// </param>
        /// <returns>
        /// Return the average along the specified axis. When returned is True,
        /// return a tuple with the average as the first element and the sum
        /// of the weights as the second element. sum_of_weights is of the
        /// same type as retval. The result dtype follows a genereal pattern.
        /// If weights is None, the result dtype will be that of a , or float64
        /// if a is integral. Otherwise, if weights is not None and a is non-
        /// integral, the result type will be the type of lowest precision capable of
        /// representing values of both a and weights. If a happens to be
        /// integral, the previous rules still applies but the result dtype will
        /// at least be float64.
        /// </returns>
        public static double average(NDarray a, NDarray weights = null, bool? returned = false)
            => NumPy.Instance.average(a, weights:weights, returned:returned);
        
        /// <summary>
        /// Compute the arithmetic mean along the specified axis.
        /// 
        /// Returns the average of the array elements.  The average is taken over
        /// the flattened array by default, otherwise over the specified axis.
        /// float64 intermediate and return values are used for integer inputs.
        /// 
        /// Notes
        /// 
        /// The arithmetic mean is the sum of the elements along the axis divided
        /// by the number of elements.
        /// 
        /// Note that for floating-point input, the mean is computed using the
        /// same precision the input has.  Depending on the input data, this can
        /// cause the results to be inaccurate, especially for float32 (see
        /// example below).  Specifying a higher-precision accumulator using the
        /// dtype keyword can alleviate this issue.
        /// 
        /// By default, float16 results are computed using float32 intermediates
        /// for extra precision.
        /// </summary>
        /// <param name="a">
        /// Array containing numbers whose mean is desired. If a is not an
        /// array, a conversion is attempted.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the means are computed. The default is to
        /// compute the mean of the flattened array.
        /// 
        /// If this is a tuple of ints, a mean is performed over multiple axes,
        /// instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the mean.  For integer inputs, the default
        /// is float64; for floating point inputs, it is the same as the
        /// input dtype.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None; if provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.
        /// See doc.ufuncs for details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the mean method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <returns>
        /// If out=None, returns a new array containing the mean values,
        /// otherwise a reference to the output array is returned.
        /// </returns>
        public static NDarray<double> mean(NDarray a, int[] axis, Dtype dtype = null, NDarray @out = null, bool? keepdims = null)
            => NumPy.Instance.mean(a, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims);
        
        /// <summary>
        /// Compute the arithmetic mean along the specified axis.
        /// 
        /// Returns the average of the array elements.  The average is taken over
        /// the flattened array by default, otherwise over the specified axis.
        /// float64 intermediate and return values are used for integer inputs.
        /// 
        /// Notes
        /// 
        /// The arithmetic mean is the sum of the elements along the axis divided
        /// by the number of elements.
        /// 
        /// Note that for floating-point input, the mean is computed using the
        /// same precision the input has.  Depending on the input data, this can
        /// cause the results to be inaccurate, especially for float32 (see
        /// example below).  Specifying a higher-precision accumulator using the
        /// dtype keyword can alleviate this issue.
        /// 
        /// By default, float16 results are computed using float32 intermediates
        /// for extra precision.
        /// </summary>
        /// <param name="a">
        /// Array containing numbers whose mean is desired. If a is not an
        /// array, a conversion is attempted.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the mean.  For integer inputs, the default
        /// is float64; for floating point inputs, it is the same as the
        /// input dtype.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None; if provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.
        /// See doc.ufuncs for details.
        /// </param>
        /// <returns>
        /// If out=None, returns a new array containing the mean values,
        /// otherwise a reference to the output array is returned.
        /// </returns>
        public static double mean(NDarray a, Dtype dtype = null, NDarray @out = null)
            => NumPy.Instance.mean(a, dtype:dtype, @out:@out);
        
        /// <summary>
        /// Compute the standard deviation along the specified axis.
        /// 
        /// Returns the standard deviation, a measure of the spread of a distribution,
        /// of the array elements. The standard deviation is computed for the
        /// flattened array by default, otherwise over the specified axis.
        /// 
        /// Notes
        /// 
        /// The standard deviation is the square root of the average of the squared
        /// deviations from the mean, i.e., std = sqrt(mean(abs(x - x.mean())**2)).
        /// 
        /// The average squared deviation is normally calculated as
        /// x.sum() / N, where N = len(x).  If, however, ddof is specified,
        /// the divisor N - ddof is used instead. In standard statistical
        /// practice, ddof=1 provides an unbiased estimator of the variance
        /// of the infinite population. ddof=0 provides a maximum likelihood
        /// estimate of the variance for normally distributed variables. The
        /// standard deviation computed in this function is the square root of
        /// the estimated variance, so even with ddof=1, it will not be an
        /// unbiased estimate of the standard deviation per se.
        /// 
        /// Note that, for complex numbers, std takes the absolute
        /// value before squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the std is computed using the same
        /// precision the input has. Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example below).
        /// Specifying a higher-accuracy accumulator using the dtype keyword can
        /// alleviate this issue.
        /// </summary>
        /// <param name="a">
        /// Calculate the standard deviation of these values.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the standard deviation is computed. The
        /// default is to compute the standard deviation of the flattened array.
        /// 
        /// If this is a tuple of ints, a standard deviation is performed over
        /// multiple axes, instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the standard deviation. For arrays of
        /// integer type the default is float64, for arrays of float types it is
        /// the same as the array type.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output but the type (of the calculated
        /// values) will be cast if necessary.
        /// </param>
        /// <param name="ddof">
        /// Means Delta Degrees of Freedom.  The divisor used in calculations
        /// is N - ddof, where N represents the number of elements.
        /// By default ddof is zero.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the std method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <returns>
        /// If out is None, return a new array containing the standard deviation,
        /// otherwise return a reference to the output array.
        /// </returns>
        public static NDarray<double> std(NDarray a, int[] axis, Dtype dtype = null, NDarray @out = null, int? ddof = 0, bool? keepdims = null)
            => NumPy.Instance.std(a, axis:axis, dtype:dtype, @out:@out, ddof:ddof, keepdims:keepdims);
        
        /// <summary>
        /// Compute the standard deviation along the specified axis.
        /// 
        /// Returns the standard deviation, a measure of the spread of a distribution,
        /// of the array elements. The standard deviation is computed for the
        /// flattened array by default, otherwise over the specified axis.
        /// 
        /// Notes
        /// 
        /// The standard deviation is the square root of the average of the squared
        /// deviations from the mean, i.e., std = sqrt(mean(abs(x - x.mean())**2)).
        /// 
        /// The average squared deviation is normally calculated as
        /// x.sum() / N, where N = len(x).  If, however, ddof is specified,
        /// the divisor N - ddof is used instead. In standard statistical
        /// practice, ddof=1 provides an unbiased estimator of the variance
        /// of the infinite population. ddof=0 provides a maximum likelihood
        /// estimate of the variance for normally distributed variables. The
        /// standard deviation computed in this function is the square root of
        /// the estimated variance, so even with ddof=1, it will not be an
        /// unbiased estimate of the standard deviation per se.
        /// 
        /// Note that, for complex numbers, std takes the absolute
        /// value before squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the std is computed using the same
        /// precision the input has. Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example below).
        /// Specifying a higher-accuracy accumulator using the dtype keyword can
        /// alleviate this issue.
        /// </summary>
        /// <param name="a">
        /// Calculate the standard deviation of these values.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the standard deviation. For arrays of
        /// integer type the default is float64, for arrays of float types it is
        /// the same as the array type.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output but the type (of the calculated
        /// values) will be cast if necessary.
        /// </param>
        /// <param name="ddof">
        /// Means Delta Degrees of Freedom.  The divisor used in calculations
        /// is N - ddof, where N represents the number of elements.
        /// By default ddof is zero.
        /// </param>
        /// <returns>
        /// If out is None, return a new array containing the standard deviation,
        /// otherwise return a reference to the output array.
        /// </returns>
        public static double std(NDarray a, Dtype dtype = null, NDarray @out = null, int? ddof = 0)
            => NumPy.Instance.std(a, dtype:dtype, @out:@out, ddof:ddof);
        
        /// <summary>
        /// Compute the variance along the specified axis.
        /// 
        /// Returns the variance of the array elements, a measure of the spread of a
        /// distribution.  The variance is computed for the flattened array by
        /// default, otherwise over the specified axis.
        /// 
        /// Notes
        /// 
        /// The variance is the average of the squared deviations from the mean,
        /// i.e.,  var = mean(abs(x - x.mean())**2).
        /// 
        /// The mean is normally calculated as x.sum() / N, where N = len(x).
        /// If, however, ddof is specified, the divisor N - ddof is used
        /// instead.  In standard statistical practice, ddof=1 provides an
        /// unbiased estimator of the variance of a hypothetical infinite population.
        /// ddof=0 provides a maximum likelihood estimate of the variance for
        /// normally distributed variables.
        /// 
        /// Note that for complex numbers, the absolute value is taken before
        /// squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the variance is computed using the same
        /// precision the input has.  Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example
        /// below).  Specifying a higher-accuracy accumulator using the dtype
        /// keyword can alleviate this issue.
        /// </summary>
        /// <param name="a">
        /// Array containing numbers whose variance is desired.  If a is not an
        /// array, a conversion is attempted.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the variance is computed.  The default is to
        /// compute the variance of the flattened array.
        /// 
        /// If this is a tuple of ints, a variance is performed over multiple axes,
        /// instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the variance.  For arrays of integer type
        /// the default is float32; for arrays of float types it is the same as
        /// the array type.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  It must have
        /// the same shape as the expected output, but the type is cast if
        /// necessary.
        /// </param>
        /// <param name="ddof">
        /// “Delta Degrees of Freedom”: the divisor used in the calculation is
        /// N - ddof, where N represents the number of elements. By
        /// default ddof is zero.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the var method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <returns>
        /// If out=None, returns a new array containing the variance;
        /// otherwise, a reference to the output array is returned.
        /// </returns>
        public static NDarray<double> @var(NDarray a, int[] axis, Dtype dtype = null, NDarray @out = null, int? ddof = 0, bool? keepdims = null)
            => NumPy.Instance.@var(a, axis:axis, dtype:dtype, @out:@out, ddof:ddof, keepdims:keepdims);
        
        /// <summary>
        /// Compute the variance along the specified axis.
        /// 
        /// Returns the variance of the array elements, a measure of the spread of a
        /// distribution.  The variance is computed for the flattened array by
        /// default, otherwise over the specified axis.
        /// 
        /// Notes
        /// 
        /// The variance is the average of the squared deviations from the mean,
        /// i.e.,  var = mean(abs(x - x.mean())**2).
        /// 
        /// The mean is normally calculated as x.sum() / N, where N = len(x).
        /// If, however, ddof is specified, the divisor N - ddof is used
        /// instead.  In standard statistical practice, ddof=1 provides an
        /// unbiased estimator of the variance of a hypothetical infinite population.
        /// ddof=0 provides a maximum likelihood estimate of the variance for
        /// normally distributed variables.
        /// 
        /// Note that for complex numbers, the absolute value is taken before
        /// squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the variance is computed using the same
        /// precision the input has.  Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example
        /// below).  Specifying a higher-accuracy accumulator using the dtype
        /// keyword can alleviate this issue.
        /// </summary>
        /// <param name="a">
        /// Array containing numbers whose variance is desired.  If a is not an
        /// array, a conversion is attempted.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the variance.  For arrays of integer type
        /// the default is float32; for arrays of float types it is the same as
        /// the array type.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  It must have
        /// the same shape as the expected output, but the type is cast if
        /// necessary.
        /// </param>
        /// <param name="ddof">
        /// “Delta Degrees of Freedom”: the divisor used in the calculation is
        /// N - ddof, where N represents the number of elements. By
        /// default ddof is zero.
        /// </param>
        /// <returns>
        /// If out=None, returns a new array containing the variance;
        /// otherwise, a reference to the output array is returned.
        /// </returns>
        public static double @var(NDarray a, Dtype dtype = null, NDarray @out = null, int? ddof = 0)
            => NumPy.Instance.@var(a, dtype:dtype, @out:@out, ddof:ddof);
        
        /// <summary>
        /// Compute the median along the specified axis, while ignoring NaNs.
        /// 
        /// Returns the median of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the median of V is the
        /// middle value of a sorted copy of V, V_sorted - i.e.,
        /// V_sorted[(N-1)/2], when N is odd and the average of the two
        /// middle values of V_sorted when N is even.
        /// </summary>
        /// <param name="a">
        /// Input array or object that can be converted to an array.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the medians are computed. The default
        /// is to compute the median along a flattened version of the array.
        /// A sequence of axes is supported since version 1.9.0.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow use of memory of input array a for
        /// calculations. The input array will be modified by the call to
        /// median. This will save memory when you do not need to preserve
        /// the contents of the input array. Treat the input as undefined,
        /// but it will probably be fully or partially sorted. Default is
        /// False. If overwrite_input is True and a is not already an
        /// ndarray, an error will be raised.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// 
        /// If this is anything but the default value it will be passed
        /// through (in the special case of an empty array) to the
        /// mean function of the underlying array.  If the array is
        /// a sub-class and mean does not have the kwarg keepdims this
        /// will raise a RuntimeError.
        /// </param>
        /// <returns>
        /// A new array holding the result. If the input contains integers
        /// or floats smaller than float64, then the output data-type is
        /// np.float64.  Otherwise, the data-type of the output is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public static NDarray<double> nanmedian(NDarray a, int[] axis, NDarray @out = null, bool? overwrite_input = false, bool? keepdims = null)
            => NumPy.Instance.nanmedian(a, axis:axis, @out:@out, overwrite_input:overwrite_input, keepdims:keepdims);
        
        /// <summary>
        /// Compute the median along the specified axis, while ignoring NaNs.
        /// 
        /// Returns the median of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the median of V is the
        /// middle value of a sorted copy of V, V_sorted - i.e.,
        /// V_sorted[(N-1)/2], when N is odd and the average of the two
        /// middle values of V_sorted when N is even.
        /// </summary>
        /// <param name="a">
        /// Input array or object that can be converted to an array.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow use of memory of input array a for
        /// calculations. The input array will be modified by the call to
        /// median. This will save memory when you do not need to preserve
        /// the contents of the input array. Treat the input as undefined,
        /// but it will probably be fully or partially sorted. Default is
        /// False. If overwrite_input is True and a is not already an
        /// ndarray, an error will be raised.
        /// </param>
        /// <returns>
        /// A new array holding the result. If the input contains integers
        /// or floats smaller than float64, then the output data-type is
        /// np.float64.  Otherwise, the data-type of the output is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public static double nanmedian(NDarray a, NDarray @out = null, bool? overwrite_input = false)
            => NumPy.Instance.nanmedian(a, @out:@out, overwrite_input:overwrite_input);
        
        /// <summary>
        /// Compute the arithmetic mean along the specified axis, ignoring NaNs.
        /// 
        /// Returns the average of the array elements.  The average is taken over
        /// the flattened array by default, otherwise over the specified axis.
        /// float64 intermediate and return values are used for integer inputs.
        /// 
        /// For all-NaN slices, NaN is returned and a RuntimeWarning is raised.
        /// 
        /// Notes
        /// 
        /// The arithmetic mean is the sum of the non-NaN elements along the axis
        /// divided by the number of non-NaN elements.
        /// 
        /// Note that for floating-point input, the mean is computed using the same
        /// precision the input has.  Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32.  Specifying a
        /// higher-precision accumulator using the dtype keyword can alleviate
        /// this issue.
        /// </summary>
        /// <param name="a">
        /// Array containing numbers whose mean is desired. If a is not an
        /// array, a conversion is attempted.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the means are computed. The default is to compute
        /// the mean of the flattened array.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the mean.  For integer inputs, the default
        /// is float64; for inexact inputs, it is the same as the input
        /// dtype.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None; if provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.  See
        /// doc.ufuncs for details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// 
        /// If the value is anything but the default, then
        /// keepdims will be passed through to the mean or sum methods
        /// of sub-classes of ndarray.  If the sub-classes methods
        /// does not implement keepdims any exceptions will be raised.
        /// </param>
        /// <returns>
        /// If out=None, returns a new array containing the mean values,
        /// otherwise a reference to the output array is returned. Nan is
        /// returned for slices that contain only NaNs.
        /// </returns>
        public static NDarray<double> nanmean(NDarray a, int[] axis, Dtype dtype = null, NDarray @out = null, bool? keepdims = null)
            => NumPy.Instance.nanmean(a, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims);
        
        /// <summary>
        /// Compute the arithmetic mean along the specified axis, ignoring NaNs.
        /// 
        /// Returns the average of the array elements.  The average is taken over
        /// the flattened array by default, otherwise over the specified axis.
        /// float64 intermediate and return values are used for integer inputs.
        /// 
        /// For all-NaN slices, NaN is returned and a RuntimeWarning is raised.
        /// 
        /// Notes
        /// 
        /// The arithmetic mean is the sum of the non-NaN elements along the axis
        /// divided by the number of non-NaN elements.
        /// 
        /// Note that for floating-point input, the mean is computed using the same
        /// precision the input has.  Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32.  Specifying a
        /// higher-precision accumulator using the dtype keyword can alleviate
        /// this issue.
        /// </summary>
        /// <param name="a">
        /// Array containing numbers whose mean is desired. If a is not an
        /// array, a conversion is attempted.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the mean.  For integer inputs, the default
        /// is float64; for inexact inputs, it is the same as the input
        /// dtype.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None; if provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.  See
        /// doc.ufuncs for details.
        /// </param>
        /// <returns>
        /// If out=None, returns a new array containing the mean values,
        /// otherwise a reference to the output array is returned. Nan is
        /// returned for slices that contain only NaNs.
        /// </returns>
        public static double nanmean(NDarray a, Dtype dtype = null, NDarray @out = null)
            => NumPy.Instance.nanmean(a, dtype:dtype, @out:@out);
        
        /// <summary>
        /// Compute the standard deviation along the specified axis, while
        /// ignoring NaNs.
        /// 
        /// Returns the standard deviation, a measure of the spread of a
        /// distribution, of the non-NaN array elements. The standard deviation is
        /// computed for the flattened array by default, otherwise over the
        /// specified axis.
        /// 
        /// For all-NaN slices or slices with zero degrees of freedom, NaN is
        /// returned and a RuntimeWarning is raised.
        /// 
        /// Notes
        /// 
        /// The standard deviation is the square root of the average of the squared
        /// deviations from the mean: std = sqrt(mean(abs(x - x.mean())**2)).
        /// 
        /// The average squared deviation is normally calculated as
        /// x.sum() / N, where N = len(x).  If, however, ddof is
        /// specified, the divisor N - ddof is used instead. In standard
        /// statistical practice, ddof=1 provides an unbiased estimator of the
        /// variance of the infinite population. ddof=0 provides a maximum
        /// likelihood estimate of the variance for normally distributed variables.
        /// The standard deviation computed in this function is the square root of
        /// the estimated variance, so even with ddof=1, it will not be an
        /// unbiased estimate of the standard deviation per se.
        /// 
        /// Note that, for complex numbers, std takes the absolute value before
        /// squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the std is computed using the same
        /// precision the input has. Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example
        /// below).  Specifying a higher-accuracy accumulator using the dtype
        /// keyword can alleviate this issue.
        /// </summary>
        /// <param name="a">
        /// Calculate the standard deviation of the non-NaN values.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the standard deviation is computed. The default is
        /// to compute the standard deviation of the flattened array.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the standard deviation. For arrays of
        /// integer type the default is float64, for arrays of float types it
        /// is the same as the array type.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output but the type (of the
        /// calculated values) will be cast if necessary.
        /// </param>
        /// <param name="ddof">
        /// Means Delta Degrees of Freedom.  The divisor used in calculations
        /// is N - ddof, where N represents the number of non-NaN
        /// elements.  By default ddof is zero.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// 
        /// If this value is anything but the default it is passed through
        /// as-is to the relevant functions of the sub-classes.  If these
        /// functions do not have a keepdims kwarg, a RuntimeError will
        /// be raised.
        /// </param>
        /// <returns>
        /// If out is None, return a new array containing the standard
        /// deviation, otherwise return a reference to the output array. If
        /// ddof is &gt;= the number of non-NaN elements in a slice or the slice
        /// contains only NaNs, then the result for that slice is NaN.
        /// </returns>
        public static NDarray<double> nanstd(NDarray a, int[] axis, Dtype dtype = null, NDarray @out = null, int? ddof = 0, bool? keepdims = null)
            => NumPy.Instance.nanstd(a, axis:axis, dtype:dtype, @out:@out, ddof:ddof, keepdims:keepdims);
        
        /// <summary>
        /// Compute the standard deviation along the specified axis, while
        /// ignoring NaNs.
        /// 
        /// Returns the standard deviation, a measure of the spread of a
        /// distribution, of the non-NaN array elements. The standard deviation is
        /// computed for the flattened array by default, otherwise over the
        /// specified axis.
        /// 
        /// For all-NaN slices or slices with zero degrees of freedom, NaN is
        /// returned and a RuntimeWarning is raised.
        /// 
        /// Notes
        /// 
        /// The standard deviation is the square root of the average of the squared
        /// deviations from the mean: std = sqrt(mean(abs(x - x.mean())**2)).
        /// 
        /// The average squared deviation is normally calculated as
        /// x.sum() / N, where N = len(x).  If, however, ddof is
        /// specified, the divisor N - ddof is used instead. In standard
        /// statistical practice, ddof=1 provides an unbiased estimator of the
        /// variance of the infinite population. ddof=0 provides a maximum
        /// likelihood estimate of the variance for normally distributed variables.
        /// The standard deviation computed in this function is the square root of
        /// the estimated variance, so even with ddof=1, it will not be an
        /// unbiased estimate of the standard deviation per se.
        /// 
        /// Note that, for complex numbers, std takes the absolute value before
        /// squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the std is computed using the same
        /// precision the input has. Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example
        /// below).  Specifying a higher-accuracy accumulator using the dtype
        /// keyword can alleviate this issue.
        /// </summary>
        /// <param name="a">
        /// Calculate the standard deviation of the non-NaN values.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the standard deviation. For arrays of
        /// integer type the default is float64, for arrays of float types it
        /// is the same as the array type.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output but the type (of the
        /// calculated values) will be cast if necessary.
        /// </param>
        /// <param name="ddof">
        /// Means Delta Degrees of Freedom.  The divisor used in calculations
        /// is N - ddof, where N represents the number of non-NaN
        /// elements.  By default ddof is zero.
        /// </param>
        /// <returns>
        /// If out is None, return a new array containing the standard
        /// deviation, otherwise return a reference to the output array. If
        /// ddof is &gt;= the number of non-NaN elements in a slice or the slice
        /// contains only NaNs, then the result for that slice is NaN.
        /// </returns>
        public static double nanstd(NDarray a, Dtype dtype = null, NDarray @out = null, int? ddof = 0)
            => NumPy.Instance.nanstd(a, dtype:dtype, @out:@out, ddof:ddof);
        
        /// <summary>
        /// Compute the variance along the specified axis, while ignoring NaNs.
        /// 
        /// Returns the variance of the array elements, a measure of the spread of
        /// a distribution.  The variance is computed for the flattened array by
        /// default, otherwise over the specified axis.
        /// 
        /// For all-NaN slices or slices with zero degrees of freedom, NaN is
        /// returned and a RuntimeWarning is raised.
        /// 
        /// Notes
        /// 
        /// The variance is the average of the squared deviations from the mean,
        /// i.e.,  var = mean(abs(x - x.mean())**2).
        /// 
        /// The mean is normally calculated as x.sum() / N, where N = len(x).
        /// If, however, ddof is specified, the divisor N - ddof is used
        /// instead.  In standard statistical practice, ddof=1 provides an
        /// unbiased estimator of the variance of a hypothetical infinite
        /// population.  ddof=0 provides a maximum likelihood estimate of the
        /// variance for normally distributed variables.
        /// 
        /// Note that for complex numbers, the absolute value is taken before
        /// squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the variance is computed using the same
        /// precision the input has.  Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example
        /// below).  Specifying a higher-accuracy accumulator using the dtype
        /// keyword can alleviate this issue.
        /// 
        /// For this function to work on sub-classes of ndarray, they must define
        /// sum with the kwarg keepdims
        /// </summary>
        /// <param name="a">
        /// Array containing numbers whose variance is desired.  If a is not an
        /// array, a conversion is attempted.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the variance is computed.  The default is to compute
        /// the variance of the flattened array.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the variance.  For arrays of integer type
        /// the default is float32; for arrays of float types it is the same as
        /// the array type.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  It must have
        /// the same shape as the expected output, but the type is cast if
        /// necessary.
        /// </param>
        /// <param name="ddof">
        /// “Delta Degrees of Freedom”: the divisor used in the calculation is
        /// N - ddof, where N represents the number of non-NaN
        /// elements. By default ddof is zero.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// </param>
        /// <returns>
        /// If out is None, return a new array containing the variance,
        /// otherwise return a reference to the output array. If ddof is &gt;= the
        /// number of non-NaN elements in a slice or the slice contains only
        /// NaNs, then the result for that slice is NaN.
        /// </returns>
        public static NDarray<double> nanvar(NDarray a, int[] axis, Dtype dtype = null, NDarray @out = null, int? ddof = 0, bool? keepdims = null)
            => NumPy.Instance.nanvar(a, axis:axis, dtype:dtype, @out:@out, ddof:ddof, keepdims:keepdims);
        
        /// <summary>
        /// Compute the variance along the specified axis, while ignoring NaNs.
        /// 
        /// Returns the variance of the array elements, a measure of the spread of
        /// a distribution.  The variance is computed for the flattened array by
        /// default, otherwise over the specified axis.
        /// 
        /// For all-NaN slices or slices with zero degrees of freedom, NaN is
        /// returned and a RuntimeWarning is raised.
        /// 
        /// Notes
        /// 
        /// The variance is the average of the squared deviations from the mean,
        /// i.e.,  var = mean(abs(x - x.mean())**2).
        /// 
        /// The mean is normally calculated as x.sum() / N, where N = len(x).
        /// If, however, ddof is specified, the divisor N - ddof is used
        /// instead.  In standard statistical practice, ddof=1 provides an
        /// unbiased estimator of the variance of a hypothetical infinite
        /// population.  ddof=0 provides a maximum likelihood estimate of the
        /// variance for normally distributed variables.
        /// 
        /// Note that for complex numbers, the absolute value is taken before
        /// squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the variance is computed using the same
        /// precision the input has.  Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example
        /// below).  Specifying a higher-accuracy accumulator using the dtype
        /// keyword can alleviate this issue.
        /// 
        /// For this function to work on sub-classes of ndarray, they must define
        /// sum with the kwarg keepdims
        /// </summary>
        /// <param name="a">
        /// Array containing numbers whose variance is desired.  If a is not an
        /// array, a conversion is attempted.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the variance.  For arrays of integer type
        /// the default is float32; for arrays of float types it is the same as
        /// the array type.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  It must have
        /// the same shape as the expected output, but the type is cast if
        /// necessary.
        /// </param>
        /// <param name="ddof">
        /// “Delta Degrees of Freedom”: the divisor used in the calculation is
        /// N - ddof, where N represents the number of non-NaN
        /// elements. By default ddof is zero.
        /// </param>
        /// <returns>
        /// If out is None, return a new array containing the variance,
        /// otherwise return a reference to the output array. If ddof is &gt;= the
        /// number of non-NaN elements in a slice or the slice contains only
        /// NaNs, then the result for that slice is NaN.
        /// </returns>
        public static double nanvar(NDarray a, Dtype dtype = null, NDarray @out = null, int? ddof = 0)
            => NumPy.Instance.nanvar(a, dtype:dtype, @out:@out, ddof:ddof);
        
        /// <summary>
        /// Return Pearson product-moment correlation coefficients.
        /// 
        /// Please refer to the documentation for cov for more detail.  The
        /// relationship between the correlation coefficient matrix, R, and the
        /// covariance matrix, C, is
        /// 
        /// The values of R are between -1 and 1, inclusive.
        /// 
        /// Notes
        /// 
        /// Due to floating point rounding the resulting array may not be Hermitian,
        /// the diagonal elements may not be 1, and the elements may not satisfy the
        /// inequality abs(a) &lt;= 1. The real and imaginary parts are clipped to the
        /// interval [-1,  1] in an attempt to improve on that situation but is not
        /// much help in the complex case.
        /// 
        /// This function accepts but discards arguments bias and ddof.  This is
        /// for backwards compatibility with previous versions of this function.  These
        /// arguments had no effect on the return values of the function and can be
        /// safely ignored in this and previous versions of numpy.
        /// </summary>
        /// <param name="x">
        /// A 1-D or 2-D array containing multiple variables and observations.
        /// Each row of x represents a variable, and each column a single
        /// observation of all those variables. Also see rowvar below.
        /// </param>
        /// <param name="y">
        /// An additional set of variables and observations. y has the same
        /// shape as x.
        /// </param>
        /// <param name="rowvar">
        /// If rowvar is True (default), then each row represents a
        /// variable, with observations in the columns. Otherwise, the relationship
        /// is transposed: each column represents a variable, while the rows
        /// contain observations.
        /// </param>
        /// <returns>
        /// The correlation coefficient matrix of the variables.
        /// </returns>
        public static NDarray corrcoef(NDarray x, NDarray y = null, bool? rowvar = true)
            => NumPy.Instance.corrcoef(x, y:y, rowvar:rowvar);
        
        /// <summary>
        /// Cross-correlation of two 1-dimensional sequences.
        /// 
        /// This function computes the correlation as generally defined in signal
        /// processing texts:
        /// 
        /// with a and v sequences being zero-padded where necessary and conj being
        /// the conjugate.
        /// 
        /// Notes
        /// 
        /// The definition of correlation above is not unique and sometimes correlation
        /// may be defined differently. Another common definition is:
        /// 
        /// which is related to c_{av}[k] by c'_{av}[k] = c_{av}[-k].
        /// </summary>
        /// <param name="v">
        /// Input sequences.
        /// </param>
        /// <param name="a">
        /// Input sequences.
        /// </param>
        /// <param name="mode">
        /// Refer to the convolve docstring.  Note that the default
        /// is ‘valid’, unlike convolve, which uses ‘full’.
        /// </param>
        /// <returns>
        /// Discrete cross-correlation of a and v.
        /// </returns>
        public static NDarray correlate(NDarray v, NDarray a, string mode = "valid")
            => NumPy.Instance.correlate(v, a, mode:mode);
        
        /// <summary>
        /// Estimate a covariance matrix, given data and weights.
        /// 
        /// Covariance indicates the level to which two variables vary together.
        /// If we examine N-dimensional samples, ,
        /// then the covariance matrix element  is the covariance of
        ///  and . The element  is the variance
        /// of .
        /// 
        /// See the notes for an outline of the algorithm.
        /// 
        /// Notes
        /// 
        /// Assume that the observations are in the columns of the observation
        /// array m and let f = fweights and a = aweights for brevity. The
        /// steps to compute the weighted covariance are as follows:
        /// 
        /// Note that when a == 1, the normalization factor
        /// v1 / (v1**2 - ddof * v2) goes over to 1 / (np.sum(f) - ddof)
        /// as it should.
        /// </summary>
        /// <param name="m">
        /// A 1-D or 2-D array containing multiple variables and observations.
        /// Each row of m represents a variable, and each column a single
        /// observation of all those variables. Also see rowvar below.
        /// </param>
        /// <param name="y">
        /// An additional set of variables and observations. y has the same form
        /// as that of m.
        /// </param>
        /// <param name="rowvar">
        /// If rowvar is True (default), then each row represents a
        /// variable, with observations in the columns. Otherwise, the relationship
        /// is transposed: each column represents a variable, while the rows
        /// contain observations.
        /// </param>
        /// <param name="bias">
        /// Default normalization (False) is by (N - 1), where N is the
        /// number of observations given (unbiased estimate). If bias is True,
        /// then normalization is by N. These values can be overridden by using
        /// the keyword ddof in numpy versions &gt;= 1.5.
        /// </param>
        /// <param name="ddof">
        /// If not None the default value implied by bias is overridden.
        /// Note that ddof=1 will return the unbiased estimate, even if both
        /// fweights and aweights are specified, and ddof=0 will return
        /// the simple average. See the notes for the details. The default value
        /// is None.
        /// </param>
        /// <param name="fweights">
        /// 1-D array of integer frequency weights; the number of times each
        /// observation vector should be repeated.
        /// </param>
        /// <param name="aweights">
        /// 1-D array of observation vector weights. These relative weights are
        /// typically large for observations considered “important” and smaller for
        /// observations considered less “important”. If ddof=0 the array of
        /// weights can be used to assign probabilities to observation vectors.
        /// </param>
        /// <returns>
        /// The covariance matrix of the variables.
        /// </returns>
        public static NDarray cov(NDarray m, NDarray y = null, bool? rowvar = true, bool? bias = false, int? ddof = null, NDarray fweights = null, NDarray aweights = null)
            => NumPy.Instance.cov(m, y:y, rowvar:rowvar, bias:bias, ddof:ddof, fweights:fweights, aweights:aweights);
        
        /// <summary>
        /// Compute the histogram of a set of data.
        /// 
        /// Notes
        /// 
        /// All but the last (righthand-most) bin is half-open.  In other words,
        /// if bins is:
        /// 
        /// then the first bin is [1, 2) (including 1, but excluding 2) and
        /// the second [2, 3).  The last bin, however, is [3, 4], which
        /// includes 4.
        /// </summary>
        /// <param name="a">
        /// Input data. The histogram is computed over the flattened array.
        /// </param>
        /// <param name="bins">
        /// If bins is an int, it defines the number of equal-width
        /// bins in the given range (10, by default). If bins is a
        /// sequence, it defines a monotonically increasing array of bin edges,
        /// including the rightmost edge, allowing for non-uniform bin widths.
        /// 
        /// If bins is a string, it defines the method used to calculate the
        /// optimal bin width, as defined by histogram_bin_edges.
        /// </param>
        /// <param name="range">
        /// The lower and upper range of the bins.  If not provided, range
        /// is simply (a.min(), a.max()).  Values outside the range are
        /// ignored. The first element of the range must be less than or
        /// equal to the second. range affects the automatic bin
        /// computation as well. While bin width is computed to be optimal
        /// based on the actual data within range, the bin count will fill
        /// the entire range including portions containing no data.
        /// </param>
        /// <param name="normed">
        /// This is equivalent to the density argument, but produces incorrect
        /// results for unequal bin widths. It should not be used.
        /// </param>
        /// <param name="weights">
        /// An array of weights, of the same shape as a.  Each value in
        /// a only contributes its associated weight towards the bin count
        /// (instead of 1). If density is True, the weights are
        /// normalized, so that the integral of the density over the range
        /// remains 1.
        /// </param>
        /// <param name="density">
        /// If False, the result will contain the number of samples in
        /// each bin. If True, the result is the value of the
        /// probability density function at the bin, normalized such that
        /// the integral over the range is 1. Note that the sum of the
        /// histogram values will not be equal to 1 unless bins of unity
        /// width are chosen; it is not a probability mass function.
        /// 
        /// Overrides the normed keyword if given.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// hist
        /// The values of the histogram. See density and weights for a
        /// description of the possible semantics.
        /// bin_edges
        /// Return the bin edges (length(hist)+1).
        /// </returns>
        public static (NDarray, NDarray) histogram(NDarray a, int? bins = null, (float, float)? range = null, bool? normed = null, NDarray weights = null, bool? density = null)
            => NumPy.Instance.histogram(a, bins:bins, range:range, normed:normed, weights:weights, density:density);
        
        /// <summary>
        /// Compute the histogram of a set of data.
        /// 
        /// Notes
        /// 
        /// All but the last (righthand-most) bin is half-open.  In other words,
        /// if bins is:
        /// 
        /// then the first bin is [1, 2) (including 1, but excluding 2) and
        /// the second [2, 3).  The last bin, however, is [3, 4], which
        /// includes 4.
        /// </summary>
        /// <param name="a">
        /// Input data. The histogram is computed over the flattened array.
        /// </param>
        /// <param name="bins">
        /// If bins is an int, it defines the number of equal-width
        /// bins in the given range (10, by default). If bins is a
        /// sequence, it defines a monotonically increasing array of bin edges,
        /// including the rightmost edge, allowing for non-uniform bin widths.
        /// 
        /// If bins is a string, it defines the method used to calculate the
        /// optimal bin width, as defined by histogram_bin_edges.
        /// </param>
        /// <param name="range">
        /// The lower and upper range of the bins.  If not provided, range
        /// is simply (a.min(), a.max()).  Values outside the range are
        /// ignored. The first element of the range must be less than or
        /// equal to the second. range affects the automatic bin
        /// computation as well. While bin width is computed to be optimal
        /// based on the actual data within range, the bin count will fill
        /// the entire range including portions containing no data.
        /// </param>
        /// <param name="normed">
        /// This is equivalent to the density argument, but produces incorrect
        /// results for unequal bin widths. It should not be used.
        /// </param>
        /// <param name="weights">
        /// An array of weights, of the same shape as a.  Each value in
        /// a only contributes its associated weight towards the bin count
        /// (instead of 1). If density is True, the weights are
        /// normalized, so that the integral of the density over the range
        /// remains 1.
        /// </param>
        /// <param name="density">
        /// If False, the result will contain the number of samples in
        /// each bin. If True, the result is the value of the
        /// probability density function at the bin, normalized such that
        /// the integral over the range is 1. Note that the sum of the
        /// histogram values will not be equal to 1 unless bins of unity
        /// width are chosen; it is not a probability mass function.
        /// 
        /// Overrides the normed keyword if given.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// hist
        /// The values of the histogram. See density and weights for a
        /// description of the possible semantics.
        /// bin_edges
        /// Return the bin edges (length(hist)+1).
        /// </returns>
        public static (NDarray, NDarray) histogram(NDarray a, NDarray bins = null, (float, float)? range = null, bool? normed = null, NDarray weights = null, bool? density = null)
            => NumPy.Instance.histogram(a, bins:bins, range:range, normed:normed, weights:weights, density:density);
        
        /// <summary>
        /// Compute the histogram of a set of data.
        /// 
        /// Notes
        /// 
        /// All but the last (righthand-most) bin is half-open.  In other words,
        /// if bins is:
        /// 
        /// then the first bin is [1, 2) (including 1, but excluding 2) and
        /// the second [2, 3).  The last bin, however, is [3, 4], which
        /// includes 4.
        /// </summary>
        /// <param name="a">
        /// Input data. The histogram is computed over the flattened array.
        /// </param>
        /// <param name="bins">
        /// If bins is an int, it defines the number of equal-width
        /// bins in the given range (10, by default). If bins is a
        /// sequence, it defines a monotonically increasing array of bin edges,
        /// including the rightmost edge, allowing for non-uniform bin widths.
        /// 
        /// If bins is a string, it defines the method used to calculate the
        /// optimal bin width, as defined by histogram_bin_edges.
        /// </param>
        /// <param name="range">
        /// The lower and upper range of the bins.  If not provided, range
        /// is simply (a.min(), a.max()).  Values outside the range are
        /// ignored. The first element of the range must be less than or
        /// equal to the second. range affects the automatic bin
        /// computation as well. While bin width is computed to be optimal
        /// based on the actual data within range, the bin count will fill
        /// the entire range including portions containing no data.
        /// </param>
        /// <param name="normed">
        /// This is equivalent to the density argument, but produces incorrect
        /// results for unequal bin widths. It should not be used.
        /// </param>
        /// <param name="weights">
        /// An array of weights, of the same shape as a.  Each value in
        /// a only contributes its associated weight towards the bin count
        /// (instead of 1). If density is True, the weights are
        /// normalized, so that the integral of the density over the range
        /// remains 1.
        /// </param>
        /// <param name="density">
        /// If False, the result will contain the number of samples in
        /// each bin. If True, the result is the value of the
        /// probability density function at the bin, normalized such that
        /// the integral over the range is 1. Note that the sum of the
        /// histogram values will not be equal to 1 unless bins of unity
        /// width are chosen; it is not a probability mass function.
        /// 
        /// Overrides the normed keyword if given.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// hist
        /// The values of the histogram. See density and weights for a
        /// description of the possible semantics.
        /// bin_edges
        /// Return the bin edges (length(hist)+1).
        /// </returns>
        public static (NDarray, NDarray) histogram(NDarray a, List<string> bins = null, (float, float)? range = null, bool? normed = null, NDarray weights = null, bool? density = null)
            => NumPy.Instance.histogram(a, bins:bins, range:range, normed:normed, weights:weights, density:density);
        
        /// <summary>
        /// Compute the bi-dimensional histogram of two data samples.
        /// 
        /// Notes
        /// 
        /// When normed is True, then the returned histogram is the sample
        /// density, defined such that the sum over bins of the product
        /// bin_value * bin_area is 1.
        /// 
        /// Please note that the histogram does not follow the Cartesian convention
        /// where x values are on the abscissa and y values on the ordinate
        /// axis.  Rather, x is histogrammed along the first dimension of the
        /// array (vertical), and y along the second dimension of the array
        /// (horizontal).  This ensures compatibility with histogramdd.
        /// </summary>
        /// <param name="x">
        /// An array containing the x coordinates of the points to be
        /// histogrammed.
        /// </param>
        /// <param name="y">
        /// An array containing the y coordinates of the points to be
        /// histogrammed.
        /// </param>
        /// <param name="bins">
        /// The bin specification:
        /// </param>
        /// <param name="range">
        /// The leftmost and rightmost edges of the bins along each dimension
        /// (if not specified explicitly in the bins parameters):
        /// [[xmin, xmax], [ymin, ymax]]. All values outside of this range
        /// will be considered outliers and not tallied in the histogram.
        /// </param>
        /// <param name="density">
        /// If False, the default, returns the number of samples in each bin.
        /// If True, returns the probability density function at the bin,
        /// bin_count / sample_count / bin_area.
        /// </param>
        /// <param name="normed">
        /// An alias for the density argument that behaves identically. To avoid
        /// confusion with the broken normed argument to histogram, density
        /// should be preferred.
        /// </param>
        /// <param name="weights">
        /// An array of values w_i weighing each sample (x_i, y_i).
        /// Weights are normalized to 1 if normed is True. If normed is
        /// False, the values of the returned histogram are equal to the sum of
        /// the weights belonging to the samples falling into each bin.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// H
        /// The bi-dimensional histogram of samples x and y. Values in x
        /// are histogrammed along the first dimension and values in y are
        /// histogrammed along the second dimension.
        /// xedges
        /// The bin edges along the first dimension.
        /// yedges
        /// The bin edges along the second dimension.
        /// </returns>
        public static (NDarray, NDarray, NDarray) histogram2d(NDarray x, NDarray y, int? bins = null, (float, float)? range = null, bool? density = null, bool? normed = null, NDarray weights = null)
            => NumPy.Instance.histogram2d(x, y, bins:bins, range:range, density:density, normed:normed, weights:weights);
        
        /// <summary>
        /// Compute the bi-dimensional histogram of two data samples.
        /// 
        /// Notes
        /// 
        /// When normed is True, then the returned histogram is the sample
        /// density, defined such that the sum over bins of the product
        /// bin_value * bin_area is 1.
        /// 
        /// Please note that the histogram does not follow the Cartesian convention
        /// where x values are on the abscissa and y values on the ordinate
        /// axis.  Rather, x is histogrammed along the first dimension of the
        /// array (vertical), and y along the second dimension of the array
        /// (horizontal).  This ensures compatibility with histogramdd.
        /// </summary>
        /// <param name="x">
        /// An array containing the x coordinates of the points to be
        /// histogrammed.
        /// </param>
        /// <param name="y">
        /// An array containing the y coordinates of the points to be
        /// histogrammed.
        /// </param>
        /// <param name="bins">
        /// The bin specification:
        /// </param>
        /// <param name="range">
        /// The leftmost and rightmost edges of the bins along each dimension
        /// (if not specified explicitly in the bins parameters):
        /// [[xmin, xmax], [ymin, ymax]]. All values outside of this range
        /// will be considered outliers and not tallied in the histogram.
        /// </param>
        /// <param name="density">
        /// If False, the default, returns the number of samples in each bin.
        /// If True, returns the probability density function at the bin,
        /// bin_count / sample_count / bin_area.
        /// </param>
        /// <param name="normed">
        /// An alias for the density argument that behaves identically. To avoid
        /// confusion with the broken normed argument to histogram, density
        /// should be preferred.
        /// </param>
        /// <param name="weights">
        /// An array of values w_i weighing each sample (x_i, y_i).
        /// Weights are normalized to 1 if normed is True. If normed is
        /// False, the values of the returned histogram are equal to the sum of
        /// the weights belonging to the samples falling into each bin.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// H
        /// The bi-dimensional histogram of samples x and y. Values in x
        /// are histogrammed along the first dimension and values in y are
        /// histogrammed along the second dimension.
        /// xedges
        /// The bin edges along the first dimension.
        /// yedges
        /// The bin edges along the second dimension.
        /// </returns>
        public static (NDarray, NDarray, NDarray) histogram2d(NDarray x, NDarray y, NDarray bins = null, (float, float)? range = null, bool? density = null, bool? normed = null, NDarray weights = null)
            => NumPy.Instance.histogram2d(x, y, bins:bins, range:range, density:density, normed:normed, weights:weights);
        
        /// <summary>
        /// Compute the bi-dimensional histogram of two data samples.
        /// 
        /// Notes
        /// 
        /// When normed is True, then the returned histogram is the sample
        /// density, defined such that the sum over bins of the product
        /// bin_value * bin_area is 1.
        /// 
        /// Please note that the histogram does not follow the Cartesian convention
        /// where x values are on the abscissa and y values on the ordinate
        /// axis.  Rather, x is histogrammed along the first dimension of the
        /// array (vertical), and y along the second dimension of the array
        /// (horizontal).  This ensures compatibility with histogramdd.
        /// </summary>
        /// <param name="x">
        /// An array containing the x coordinates of the points to be
        /// histogrammed.
        /// </param>
        /// <param name="y">
        /// An array containing the y coordinates of the points to be
        /// histogrammed.
        /// </param>
        /// <param name="bins">
        /// The bin specification:
        /// </param>
        /// <param name="range">
        /// The leftmost and rightmost edges of the bins along each dimension
        /// (if not specified explicitly in the bins parameters):
        /// [[xmin, xmax], [ymin, ymax]]. All values outside of this range
        /// will be considered outliers and not tallied in the histogram.
        /// </param>
        /// <param name="density">
        /// If False, the default, returns the number of samples in each bin.
        /// If True, returns the probability density function at the bin,
        /// bin_count / sample_count / bin_area.
        /// </param>
        /// <param name="normed">
        /// An alias for the density argument that behaves identically. To avoid
        /// confusion with the broken normed argument to histogram, density
        /// should be preferred.
        /// </param>
        /// <param name="weights">
        /// An array of values w_i weighing each sample (x_i, y_i).
        /// Weights are normalized to 1 if normed is True. If normed is
        /// False, the values of the returned histogram are equal to the sum of
        /// the weights belonging to the samples falling into each bin.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// H
        /// The bi-dimensional histogram of samples x and y. Values in x
        /// are histogrammed along the first dimension and values in y are
        /// histogrammed along the second dimension.
        /// xedges
        /// The bin edges along the first dimension.
        /// yedges
        /// The bin edges along the second dimension.
        /// </returns>
        public static (NDarray, NDarray, NDarray) histogram2d(NDarray x, NDarray y, List<string> bins = null, (float, float)? range = null, bool? density = null, bool? normed = null, NDarray weights = null)
            => NumPy.Instance.histogram2d(x, y, bins:bins, range:range, density:density, normed:normed, weights:weights);
        
        /// <summary>
        /// Compute the multidimensional histogram of some data.
        /// </summary>
        /// <param name="sample">
        /// The data to be histogrammed.
        /// 
        /// Note the unusual interpretation of sample when an array_like:
        /// 
        /// The first form should be preferred.
        /// </param>
        /// <param name="bins">
        /// The bin specification:
        /// </param>
        /// <param name="range">
        /// A sequence of length D, each an optional (lower, upper) tuple giving
        /// the outer bin edges to be used if the edges are not given explicitly in
        /// bins.
        /// An entry of None in the sequence results in the minimum and maximum
        /// values being used for the corresponding dimension.
        /// The default, None, is equivalent to passing a tuple of D None values.
        /// </param>
        /// <param name="density">
        /// If False, the default, returns the number of samples in each bin.
        /// If True, returns the probability density function at the bin,
        /// bin_count / sample_count / bin_volume.
        /// </param>
        /// <param name="normed">
        /// An alias for the density argument that behaves identically. To avoid
        /// confusion with the broken normed argument to histogram, density
        /// should be preferred.
        /// </param>
        /// <param name="weights">
        /// An array of values w_i weighing each sample (x_i, y_i, z_i, …).
        /// Weights are normalized to 1 if normed is True. If normed is False,
        /// the values of the returned histogram are equal to the sum of the
        /// weights belonging to the samples falling into each bin.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// H
        /// The multidimensional histogram of sample x. See normed and weights
        /// for the different possible semantics.
        /// edges
        /// A list of D arrays describing the bin edges for each dimension.
        /// </returns>
        public static (NDarray, NDarray) histogramdd(NDarray sample, int? bins = null, (float, float)? range = null, bool? density = null, bool? normed = null, NDarray weights = null)
            => NumPy.Instance.histogramdd(sample, bins:bins, range:range, density:density, normed:normed, weights:weights);
        
        /// <summary>
        /// Compute the multidimensional histogram of some data.
        /// </summary>
        /// <param name="sample">
        /// The data to be histogrammed.
        /// 
        /// Note the unusual interpretation of sample when an array_like:
        /// 
        /// The first form should be preferred.
        /// </param>
        /// <param name="bins">
        /// The bin specification:
        /// </param>
        /// <param name="range">
        /// A sequence of length D, each an optional (lower, upper) tuple giving
        /// the outer bin edges to be used if the edges are not given explicitly in
        /// bins.
        /// An entry of None in the sequence results in the minimum and maximum
        /// values being used for the corresponding dimension.
        /// The default, None, is equivalent to passing a tuple of D None values.
        /// </param>
        /// <param name="density">
        /// If False, the default, returns the number of samples in each bin.
        /// If True, returns the probability density function at the bin,
        /// bin_count / sample_count / bin_volume.
        /// </param>
        /// <param name="normed">
        /// An alias for the density argument that behaves identically. To avoid
        /// confusion with the broken normed argument to histogram, density
        /// should be preferred.
        /// </param>
        /// <param name="weights">
        /// An array of values w_i weighing each sample (x_i, y_i, z_i, …).
        /// Weights are normalized to 1 if normed is True. If normed is False,
        /// the values of the returned histogram are equal to the sum of the
        /// weights belonging to the samples falling into each bin.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// H
        /// The multidimensional histogram of sample x. See normed and weights
        /// for the different possible semantics.
        /// edges
        /// A list of D arrays describing the bin edges for each dimension.
        /// </returns>
        public static (NDarray, NDarray) histogramdd(NDarray sample, NDarray bins = null, (float, float)? range = null, bool? density = null, bool? normed = null, NDarray weights = null)
            => NumPy.Instance.histogramdd(sample, bins:bins, range:range, density:density, normed:normed, weights:weights);
        
        /// <summary>
        /// Compute the multidimensional histogram of some data.
        /// </summary>
        /// <param name="sample">
        /// The data to be histogrammed.
        /// 
        /// Note the unusual interpretation of sample when an array_like:
        /// 
        /// The first form should be preferred.
        /// </param>
        /// <param name="bins">
        /// The bin specification:
        /// </param>
        /// <param name="range">
        /// A sequence of length D, each an optional (lower, upper) tuple giving
        /// the outer bin edges to be used if the edges are not given explicitly in
        /// bins.
        /// An entry of None in the sequence results in the minimum and maximum
        /// values being used for the corresponding dimension.
        /// The default, None, is equivalent to passing a tuple of D None values.
        /// </param>
        /// <param name="density">
        /// If False, the default, returns the number of samples in each bin.
        /// If True, returns the probability density function at the bin,
        /// bin_count / sample_count / bin_volume.
        /// </param>
        /// <param name="normed">
        /// An alias for the density argument that behaves identically. To avoid
        /// confusion with the broken normed argument to histogram, density
        /// should be preferred.
        /// </param>
        /// <param name="weights">
        /// An array of values w_i weighing each sample (x_i, y_i, z_i, …).
        /// Weights are normalized to 1 if normed is True. If normed is False,
        /// the values of the returned histogram are equal to the sum of the
        /// weights belonging to the samples falling into each bin.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// H
        /// The multidimensional histogram of sample x. See normed and weights
        /// for the different possible semantics.
        /// edges
        /// A list of D arrays describing the bin edges for each dimension.
        /// </returns>
        public static (NDarray, NDarray) histogramdd(NDarray sample, List<string> bins = null, (float, float)? range = null, bool? density = null, bool? normed = null, NDarray weights = null)
            => NumPy.Instance.histogramdd(sample, bins:bins, range:range, density:density, normed:normed, weights:weights);
        
        /// <summary>
        /// Count number of occurrences of each value in array of non-negative ints.
        /// 
        /// The number of bins (of size 1) is one larger than the largest value in
        /// x. If minlength is specified, there will be at least this number
        /// of bins in the output array (though it will be longer if necessary,
        /// depending on the contents of x).
        /// Each bin gives the number of occurrences of its index value in x.
        /// If weights is specified the input array is weighted by it, i.e. if a
        /// value n is found at position i, out[n] += weight[i] instead
        /// of out[n] += 1.
        /// </summary>
        /// <param name="x">
        /// Input array.
        /// </param>
        /// <param name="weights">
        /// Weights, array of the same shape as x.
        /// </param>
        /// <param name="minlength">
        /// A minimum number of bins for the output array.
        /// </param>
        /// <returns>
        /// The result of binning the input array.
        /// The length of out is equal to np.amax(x)+1.
        /// </returns>
        public static NDarray bincount(NDarray x, NDarray weights = null, int? minlength = 0)
            => NumPy.Instance.bincount(x, weights:weights, minlength:minlength);
        
        /// <summary>
        /// Function to calculate only the edges of the bins used by the histogram function.
        /// 
        /// Notes
        /// 
        /// The methods to estimate the optimal number of bins are well founded
        /// in literature, and are inspired by the choices R provides for
        /// histogram visualisation. Note that having the number of bins
        /// proportional to  is asymptotically optimal, which is
        /// why it appears in most estimators. These are simply plug-in methods
        /// that give good starting points for number of bins. In the equations
        /// below,  is the binwidth and  is the number of
        /// bins. All estimators that compute bin counts are recast to bin width
        /// using the ptp of the data. The final bin count is obtained from
        /// np.round(np.ceil(range / h)).
        /// </summary>
        /// <param name="a">
        /// Input data. The histogram is computed over the flattened array.
        /// </param>
        /// <param name="bins">
        /// If bins is an int, it defines the number of equal-width
        /// bins in the given range (10, by default). If bins is a
        /// sequence, it defines the bin edges, including the rightmost
        /// edge, allowing for non-uniform bin widths.
        /// 
        /// If bins is a string from the list below, histogram_bin_edges will use
        /// the method chosen to calculate the optimal bin width and
        /// consequently the number of bins (see Notes for more detail on
        /// the estimators) from the data that falls within the requested
        /// range. While the bin width will be optimal for the actual data
        /// in the range, the number of bins will be computed to fill the
        /// entire range, including the empty portions. For visualisation,
        /// using the ‘auto’ option is suggested. Weighted data is not
        /// supported for automated bin size selection.
        /// </param>
        /// <param name="range">
        /// The lower and upper range of the bins.  If not provided, range
        /// is simply (a.min(), a.max()).  Values outside the range are
        /// ignored. The first element of the range must be less than or
        /// equal to the second. range affects the automatic bin
        /// computation as well. While bin width is computed to be optimal
        /// based on the actual data within range, the bin count will fill
        /// the entire range including portions containing no data.
        /// </param>
        /// <param name="weights">
        /// An array of weights, of the same shape as a.  Each value in
        /// a only contributes its associated weight towards the bin count
        /// (instead of 1). This is currently not used by any of the bin estimators,
        /// but may be in the future.
        /// </param>
        /// <returns>
        /// The edges to pass into histogram
        /// </returns>
        public static NDarray<float> histogram_bin_edges(NDarray a, int? bins = null, (float, float)? range = null, NDarray weights = null)
            => NumPy.Instance.histogram_bin_edges(a, bins:bins, range:range, weights:weights);
        
        /// <summary>
        /// Function to calculate only the edges of the bins used by the histogram function.
        /// 
        /// Notes
        /// 
        /// The methods to estimate the optimal number of bins are well founded
        /// in literature, and are inspired by the choices R provides for
        /// histogram visualisation. Note that having the number of bins
        /// proportional to  is asymptotically optimal, which is
        /// why it appears in most estimators. These are simply plug-in methods
        /// that give good starting points for number of bins. In the equations
        /// below,  is the binwidth and  is the number of
        /// bins. All estimators that compute bin counts are recast to bin width
        /// using the ptp of the data. The final bin count is obtained from
        /// np.round(np.ceil(range / h)).
        /// </summary>
        /// <param name="a">
        /// Input data. The histogram is computed over the flattened array.
        /// </param>
        /// <param name="bins">
        /// If bins is an int, it defines the number of equal-width
        /// bins in the given range (10, by default). If bins is a
        /// sequence, it defines the bin edges, including the rightmost
        /// edge, allowing for non-uniform bin widths.
        /// 
        /// If bins is a string from the list below, histogram_bin_edges will use
        /// the method chosen to calculate the optimal bin width and
        /// consequently the number of bins (see Notes for more detail on
        /// the estimators) from the data that falls within the requested
        /// range. While the bin width will be optimal for the actual data
        /// in the range, the number of bins will be computed to fill the
        /// entire range, including the empty portions. For visualisation,
        /// using the ‘auto’ option is suggested. Weighted data is not
        /// supported for automated bin size selection.
        /// </param>
        /// <param name="range">
        /// The lower and upper range of the bins.  If not provided, range
        /// is simply (a.min(), a.max()).  Values outside the range are
        /// ignored. The first element of the range must be less than or
        /// equal to the second. range affects the automatic bin
        /// computation as well. While bin width is computed to be optimal
        /// based on the actual data within range, the bin count will fill
        /// the entire range including portions containing no data.
        /// </param>
        /// <param name="weights">
        /// An array of weights, of the same shape as a.  Each value in
        /// a only contributes its associated weight towards the bin count
        /// (instead of 1). This is currently not used by any of the bin estimators,
        /// but may be in the future.
        /// </param>
        /// <returns>
        /// The edges to pass into histogram
        /// </returns>
        public static NDarray<float> histogram_bin_edges(NDarray a, NDarray bins = null, (float, float)? range = null, NDarray weights = null)
            => NumPy.Instance.histogram_bin_edges(a, bins:bins, range:range, weights:weights);
        
        /// <summary>
        /// Function to calculate only the edges of the bins used by the histogram function.
        /// 
        /// Notes
        /// 
        /// The methods to estimate the optimal number of bins are well founded
        /// in literature, and are inspired by the choices R provides for
        /// histogram visualisation. Note that having the number of bins
        /// proportional to  is asymptotically optimal, which is
        /// why it appears in most estimators. These are simply plug-in methods
        /// that give good starting points for number of bins. In the equations
        /// below,  is the binwidth and  is the number of
        /// bins. All estimators that compute bin counts are recast to bin width
        /// using the ptp of the data. The final bin count is obtained from
        /// np.round(np.ceil(range / h)).
        /// </summary>
        /// <param name="a">
        /// Input data. The histogram is computed over the flattened array.
        /// </param>
        /// <param name="bins">
        /// If bins is an int, it defines the number of equal-width
        /// bins in the given range (10, by default). If bins is a
        /// sequence, it defines the bin edges, including the rightmost
        /// edge, allowing for non-uniform bin widths.
        /// 
        /// If bins is a string from the list below, histogram_bin_edges will use
        /// the method chosen to calculate the optimal bin width and
        /// consequently the number of bins (see Notes for more detail on
        /// the estimators) from the data that falls within the requested
        /// range. While the bin width will be optimal for the actual data
        /// in the range, the number of bins will be computed to fill the
        /// entire range, including the empty portions. For visualisation,
        /// using the ‘auto’ option is suggested. Weighted data is not
        /// supported for automated bin size selection.
        /// </param>
        /// <param name="range">
        /// The lower and upper range of the bins.  If not provided, range
        /// is simply (a.min(), a.max()).  Values outside the range are
        /// ignored. The first element of the range must be less than or
        /// equal to the second. range affects the automatic bin
        /// computation as well. While bin width is computed to be optimal
        /// based on the actual data within range, the bin count will fill
        /// the entire range including portions containing no data.
        /// </param>
        /// <param name="weights">
        /// An array of weights, of the same shape as a.  Each value in
        /// a only contributes its associated weight towards the bin count
        /// (instead of 1). This is currently not used by any of the bin estimators,
        /// but may be in the future.
        /// </param>
        /// <returns>
        /// The edges to pass into histogram
        /// </returns>
        public static NDarray<float> histogram_bin_edges(NDarray a, List<string> bins = null, (float, float)? range = null, NDarray weights = null)
            => NumPy.Instance.histogram_bin_edges(a, bins:bins, range:range, weights:weights);
        
        /// <summary>
        /// Return the indices of the bins to which each value in input array belongs.
        /// 
        /// If values in x are beyond the bounds of bins, 0 or len(bins) is
        /// returned as appropriate.
        /// 
        /// Notes
        /// 
        /// If values in x are such that they fall outside the bin range,
        /// attempting to index bins with the indices that digitize returns
        /// will result in an IndexError.
        /// 
        /// np.digitize is  implemented in terms of np.searchsorted. This means
        /// that a binary search is used to bin the values, which scales much better
        /// for larger number of bins than the previous linear search. It also removes
        /// the requirement for the input array to be 1-dimensional.
        /// 
        /// For monotonically _increasing_ bins, the following are equivalent:
        /// 
        /// Note that as the order of the arguments are reversed, the side must be too.
        /// The searchsorted call is marginally faster, as it does not do any
        /// monotonicity checks. Perhaps more importantly, it supports all dtypes.
        /// </summary>
        /// <param name="x">
        /// Input array to be binned. Prior to NumPy 1.10.0, this array had to
        /// be 1-dimensional, but can now have any shape.
        /// </param>
        /// <param name="bins">
        /// Array of bins. It has to be 1-dimensional and monotonic.
        /// </param>
        /// <param name="right">
        /// Indicating whether the intervals include the right or the left bin
        /// edge. Default behavior is (right==False) indicating that the interval
        /// does not include the right edge. The left bin end is open in this
        /// case, i.e., bins[i-1] &lt;= x &lt; bins[i] is the default behavior for
        /// monotonically increasing bins.
        /// </param>
        /// <returns>
        /// Output array of indices, of same shape as x.
        /// </returns>
        public static NDarray digitize(NDarray x, NDarray bins, bool? right = false)
            => NumPy.Instance.digitize(x, bins, right:right);
        
        
    }
}
