// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Python.Runtime;
using Python.Included;
using Numpy.Models;

namespace Numpy
{
    public static partial class np
    {
        
        /// <summary>
        /// Unwrap by changing deltas between values to 2*pi complement.
        /// 
        /// Unwrap radian phase p by changing absolute jumps greater than
        /// discont to their 2*pi complement along the given axis.
        /// 
        /// Notes
        /// 
        /// If the discontinuity in p is smaller than pi, but larger than
        /// discont, no unwrapping is done because taking the 2*pi complement
        /// would only make the discontinuity larger.
        /// </summary>
        /// <param name="p">
        /// Input array.
        /// </param>
        /// <param name="discont">
        /// Maximum discontinuity between values, default is pi.
        /// </param>
        /// <param name="axis">
        /// Axis along which unwrap will operate, default is the last axis.
        /// </param>
        /// <returns>
        /// Output array.
        /// </returns>
        public static NDarray unwrap(NDarray p, float? discont = null, int? axis = null)
            => NumPy.Instance.unwrap(p, discont:discont, axis:axis);
        
        /// <summary>
        /// Evenly round to the given number of decimals.
        /// 
        /// Notes
        /// 
        /// For values exactly halfway between rounded decimal values, NumPy
        /// rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,
        /// -0.5 and 0.5 round to 0.0, etc. Results may also be surprising due
        /// to the inexact representation of decimal fractions in the IEEE
        /// floating point standard [1] and errors introduced when scaling
        /// by powers of ten.
        /// 
        /// References
        /// </summary>
        /// <param name="a">
        /// Input data.
        /// </param>
        /// <param name="decimals">
        /// Number of decimal places to round to (default: 0).  If
        /// decimals is negative, it specifies the number of positions to
        /// the left of the decimal point.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output, but the type of the output
        /// values will be cast if necessary. See doc.ufuncs (Section
        /// “Output arguments”) for details.
        /// </param>
        /// <returns>
        /// An array of the same type as a, containing the rounded values.
        /// Unless out was specified, a new array is created.  A reference to
        /// the result is returned.
        /// 
        /// The real and imaginary parts of complex numbers are rounded
        /// separately.  The result of rounding a float is a float.
        /// </returns>
        public static NDarray around(NDarray a, int? decimals = null, NDarray @out = null)
            => NumPy.Instance.around(a, decimals:decimals, @out:@out);
        
        /// <summary>
        /// Round to nearest integer towards zero.
        /// 
        /// Round an array of floats element-wise to nearest integer towards zero.
        /// The rounded values are returned as floats.
        /// </summary>
        /// <param name="x">
        /// An array of floats to be rounded
        /// </param>
        /// <param name="y">
        /// Output array
        /// </param>
        /// <returns>
        /// The array of rounded numbers
        /// </returns>
        public static NDarray fix(NDarray x, NDarray y = null)
            => NumPy.Instance.fix(x, y:y);
        
        /// <summary>
        /// Return the product of array elements over a given axis.
        /// 
        /// Notes
        /// 
        /// Arithmetic is modular when using integer types, and no error is
        /// raised on overflow.  That means that, on a 32-bit platform:
        /// 
        /// The product of an empty array is the neutral element 1:
        /// </summary>
        /// <param name="a">
        /// Input data.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which a product is performed.  The default,
        /// axis=None, will calculate the product of all the elements in the
        /// input array. If axis is negative it counts from the last to the
        /// first axis.
        /// 
        /// If axis is a tuple of ints, a product is performed on all of the
        /// axes specified in the tuple instead of a single axis or all the
        /// axes as before.
        /// </param>
        /// <param name="dtype">
        /// The type of the returned array, as well as of the accumulator in
        /// which the elements are multiplied.  The dtype of a is used by
        /// default unless a has an integer dtype of less precision than the
        /// default platform integer.  In that case, if a is signed then the
        /// platform integer is used while if a is unsigned then an unsigned
        /// integer of the same precision as the platform integer is used.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output, but the type of the output
        /// values will be cast if necessary.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left in the
        /// result as dimensions with size one. With this option, the result
        /// will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the prod method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <param name="initial">
        /// The starting value for this product. See reduce for details.
        /// </param>
        /// <returns>
        /// An array shaped as a but with the specified axis removed.
        /// Returns a reference to out if specified.
        /// </returns>
        public static NDarray prod(NDarray a, int[] axis = null, Dtype dtype = null, NDarray @out = null, bool? keepdims = null, ValueType initial = null)
            => NumPy.Instance.prod(a, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims, initial:initial);
        
        /// <summary>
        /// Sum of array elements over a given axis.
        /// 
        /// Notes
        /// 
        /// Arithmetic is modular when using integer types, and no error is
        /// raised on overflow.
        /// 
        /// The sum of an empty array is the neutral element 0:
        /// </summary>
        /// <param name="a">
        /// Elements to sum.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which a sum is performed.  The default,
        /// axis=None, will sum all of the elements of the input array.  If
        /// axis is negative it counts from the last to the first axis.
        /// 
        /// If axis is a tuple of ints, a sum is performed on all of the axes
        /// specified in the tuple instead of a single axis or all the axes as
        /// before.
        /// </param>
        /// <param name="dtype">
        /// The type of the returned array and of the accumulator in which the
        /// elements are summed.  The dtype of a is used by default unless a
        /// has an integer dtype of less precision than the default platform
        /// integer.  In that case, if a is signed then the platform integer
        /// is used while if a is unsigned then an unsigned integer of the
        /// same precision as the platform integer is used.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output, but the type of the output
        /// values will be cast if necessary.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the sum method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <param name="initial">
        /// Starting value for the sum. See reduce for details.
        /// </param>
        /// <returns>
        /// An array with the same shape as a, with the specified
        /// axis removed.   If a is a 0-d array, or if axis is None, a scalar
        /// is returned.  If an output array is specified, a reference to
        /// out is returned.
        /// </returns>
        public static NDarray sum(NDarray a, int[] axis = null, Dtype dtype = null, NDarray @out = null, bool? keepdims = null, ValueType initial = null)
            => NumPy.Instance.sum(a, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims, initial:initial);
        
        /// <summary>
        /// Return the product of array elements over a given axis treating Not a
        /// Numbers (NaNs) as ones.
        /// 
        /// One is returned for slices that are all-NaN or empty.
        /// </summary>
        /// <param name="a">
        /// Array containing numbers whose product is desired. If a is not an
        /// array, a conversion is attempted.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the product is computed. The default is to compute
        /// the product of the flattened array.
        /// </param>
        /// <param name="dtype">
        /// The type of the returned array and of the accumulator in which the
        /// elements are summed.  By default, the dtype of a is used.  An
        /// exception is when a has an integer type with less precision than
        /// the platform (u)intp. In that case, the default will be either
        /// (u)int32 or (u)int64 depending on whether the platform is 32 or 64
        /// bits. For inexact inputs, dtype must be inexact.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None. If provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.  See
        /// doc.ufuncs for details. The casting of NaN to integer can yield
        /// unexpected results.
        /// </param>
        /// <param name="keepdims">
        /// If True, the axes which are reduced are left in the result as
        /// dimensions with size one. With this option, the result will
        /// broadcast correctly against the original arr.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which case it is returned.
        /// </returns>
        public static NDarray nanprod(NDarray a, int[] axis = null, Dtype dtype = null, NDarray @out = null, bool? keepdims = null)
            => NumPy.Instance.nanprod(a, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims);
        
        /// <summary>
        /// Return the sum of array elements over a given axis treating Not a
        /// Numbers (NaNs) as zero.
        /// 
        /// In NumPy versions &lt;= 1.9.0 Nan is returned for slices that are all-NaN or
        /// empty. In later versions zero is returned.
        /// 
        /// Notes
        /// 
        /// If both positive and negative infinity are present, the sum will be Not
        /// A Number (NaN).
        /// </summary>
        /// <param name="a">
        /// Array containing numbers whose sum is desired. If a is not an
        /// array, a conversion is attempted.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the sum is computed. The default is to compute the
        /// sum of the flattened array.
        /// </param>
        /// <param name="dtype">
        /// The type of the returned array and of the accumulator in which the
        /// elements are summed.  By default, the dtype of a is used.  An
        /// exception is when a has an integer type with less precision than
        /// the platform (u)intp. In that case, the default will be either
        /// (u)int32 or (u)int64 depending on whether the platform is 32 or 64
        /// bits. For inexact inputs, dtype must be inexact.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None. If provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.  See
        /// doc.ufuncs for details. The casting of NaN to integer can yield
        /// unexpected results.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// 
        /// If the value is anything but the default, then
        /// keepdims will be passed through to the mean or sum methods
        /// of sub-classes of ndarray.  If the sub-classes methods
        /// does not implement keepdims any exceptions will be raised.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which it is returned. The result has the same
        /// size as a, and the same shape as a if axis is not None
        /// or a is a 1-d array.
        /// </returns>
        public static NDarray nansum(NDarray a, int[] axis = null, Dtype dtype = null, NDarray @out = null, bool? keepdims = null)
            => NumPy.Instance.nansum(a, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims);
        
        /// <summary>
        /// Return the cumulative product of elements along a given axis.
        /// 
        /// Notes
        /// 
        /// Arithmetic is modular when using integer types, and no error is
        /// raised on overflow.
        /// </summary>
        /// <param name="a">
        /// Input array.
        /// </param>
        /// <param name="axis">
        /// Axis along which the cumulative product is computed.  By default
        /// the input is flattened.
        /// </param>
        /// <param name="dtype">
        /// Type of the returned array, as well as of the accumulator in which
        /// the elements are multiplied.  If dtype is not specified, it
        /// defaults to the dtype of a, unless a has an integer dtype with
        /// a precision less than that of the default platform integer.  In
        /// that case, the default platform integer is used instead.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output
        /// but the type of the resulting values will be cast if necessary.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which case a reference to out is returned.
        /// </returns>
        public static NDarray cumprod(NDarray a, int? axis = null, Dtype dtype = null, NDarray @out = null)
            => NumPy.Instance.cumprod(a, axis:axis, dtype:dtype, @out:@out);
        
        /// <summary>
        /// Return the cumulative sum of the elements along a given axis.
        /// 
        /// Notes
        /// 
        /// Arithmetic is modular when using integer types, and no error is
        /// raised on overflow.
        /// </summary>
        /// <param name="a">
        /// Input array.
        /// </param>
        /// <param name="axis">
        /// Axis along which the cumulative sum is computed. The default
        /// (None) is to compute the cumsum over the flattened array.
        /// </param>
        /// <param name="dtype">
        /// Type of the returned array and of the accumulator in which the
        /// elements are summed.  If dtype is not specified, it defaults
        /// to the dtype of a, unless a has an integer dtype with a
        /// precision less than that of the default platform integer.  In
        /// that case, the default platform integer is used.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output
        /// but the type will be cast if necessary. See doc.ufuncs
        /// (Section “Output arguments”) for more details.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which case a reference to out is returned. The
        /// result has the same size as a, and the same shape as a if
        /// axis is not None or a is a 1-d array.
        /// </returns>
        public static NDarray cumsum(NDarray a, int? axis = null, Dtype dtype = null, NDarray @out = null)
            => NumPy.Instance.cumsum(a, axis:axis, dtype:dtype, @out:@out);
        
        /// <summary>
        /// Return the cumulative product of array elements over a given axis treating Not a
        /// Numbers (NaNs) as one.  The cumulative product does not change when NaNs are
        /// encountered and leading NaNs are replaced by ones.
        /// 
        /// Ones are returned for slices that are all-NaN or empty.
        /// </summary>
        /// <param name="a">
        /// Input array.
        /// </param>
        /// <param name="axis">
        /// Axis along which the cumulative product is computed.  By default
        /// the input is flattened.
        /// </param>
        /// <param name="dtype">
        /// Type of the returned array, as well as of the accumulator in which
        /// the elements are multiplied.  If dtype is not specified, it
        /// defaults to the dtype of a, unless a has an integer dtype with
        /// a precision less than that of the default platform integer.  In
        /// that case, the default platform integer is used instead.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output
        /// but the type of the resulting values will be cast if necessary.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which case it is returned.
        /// </returns>
        public static NDarray nancumprod(NDarray a, int? axis = null, Dtype dtype = null, NDarray @out = null)
            => NumPy.Instance.nancumprod(a, axis:axis, dtype:dtype, @out:@out);
        
        /// <summary>
        /// Return the cumulative sum of array elements over a given axis treating Not a
        /// Numbers (NaNs) as zero.  The cumulative sum does not change when NaNs are
        /// encountered and leading NaNs are replaced by zeros.
        /// 
        /// Zeros are returned for slices that are all-NaN or empty.
        /// </summary>
        /// <param name="a">
        /// Input array.
        /// </param>
        /// <param name="axis">
        /// Axis along which the cumulative sum is computed. The default
        /// (None) is to compute the cumsum over the flattened array.
        /// </param>
        /// <param name="dtype">
        /// Type of the returned array and of the accumulator in which the
        /// elements are summed.  If dtype is not specified, it defaults
        /// to the dtype of a, unless a has an integer dtype with a
        /// precision less than that of the default platform integer.  In
        /// that case, the default platform integer is used.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output
        /// but the type will be cast if necessary. See doc.ufuncs
        /// (Section “Output arguments”) for more details.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which it is returned. The result has the same
        /// size as a, and the same shape as a if axis is not None
        /// or a is a 1-d array.
        /// </returns>
        public static NDarray nancumsum(NDarray a, int? axis = null, Dtype dtype = null, NDarray @out = null)
            => NumPy.Instance.nancumsum(a, axis:axis, dtype:dtype, @out:@out);
        
        /// <summary>
        /// Calculate the n-th discrete difference along the given axis.
        /// 
        /// The first difference is given by out[n] = a[n+1] - a[n] along
        /// the given axis, higher differences are calculated by using diff
        /// recursively.
        /// 
        /// Notes
        /// 
        /// Type is preserved for boolean arrays, so the result will contain
        /// False when consecutive elements are the same and True when they
        /// differ.
        /// 
        /// For unsigned integer arrays, the results will also be unsigned. This
        /// should not be surprising, as the result is consistent with
        /// calculating the difference directly:
        /// 
        /// If this is not desirable, then the array should be cast to a larger
        /// integer type first:
        /// </summary>
        /// <param name="a">
        /// Input array
        /// </param>
        /// <param name="n">
        /// The number of times values are differenced. If zero, the input
        /// is returned as-is.
        /// </param>
        /// <param name="axis">
        /// The axis along which the difference is taken, default is the
        /// last axis.
        /// </param>
        /// <param name="prepend">
        /// Values to prepend or append to “a” along axis prior to
        /// performing the difference.  Scalar values are expanded to
        /// arrays with length 1 in the direction of axis and the shape
        /// of the input array in along all other axes.  Otherwise the
        /// dimension and shape must match “a” except along axis.
        /// </param>
        /// <returns>
        /// The n-th differences. The shape of the output is the same as a
        /// except along axis where the dimension is smaller by n. The
        /// type of the output is the same as the type of the difference
        /// between any two elements of a. This is the same as the type of
        /// a in most cases. A notable exception is datetime64, which
        /// results in a timedelta64 output array.
        /// </returns>
        public static NDarray diff(NDarray a, int? n = null, int? axis = null, NDarray prepend = null, NDarray append = null)
            => NumPy.Instance.diff(a, n:n, axis:axis, prepend:prepend, append:append);
        
        /// <summary>
        /// The differences between consecutive elements of an array.
        /// 
        /// Notes
        /// 
        /// When applied to masked arrays, this function drops the mask information
        /// if the to_begin and/or to_end parameters are used.
        /// </summary>
        /// <param name="ary">
        /// If necessary, will be flattened before the differences are taken.
        /// </param>
        /// <param name="to_end">
        /// Number(s) to append at the end of the returned differences.
        /// </param>
        /// <param name="to_begin">
        /// Number(s) to prepend at the beginning of the returned differences.
        /// </param>
        /// <returns>
        /// The differences. Loosely, this is ary.flat[1:] - ary.flat[:-1].
        /// </returns>
        public static NDarray ediff1d(NDarray ary, NDarray to_end = null, NDarray to_begin = null)
            => NumPy.Instance.ediff1d(ary, to_end:to_end, to_begin:to_begin);
        
        /// <summary>
        /// Return the gradient of an N-dimensional array.
        /// 
        /// The gradient is computed using second order accurate central differences
        /// in the interior points and either first or second order accurate one-sides
        /// (forward or backwards) differences at the boundaries.
        /// The returned gradient hence has the same shape as the input array.
        /// 
        /// Notes
        /// 
        /// Assuming that  (i.e.,  has at least 3 continuous
        /// derivatives) and let  be a non-homogeneous stepsize, we
        /// minimize the “consistency error”  between the true gradient
        /// and its estimate from a linear combination of the neighboring grid-points:
        /// 
        /// By substituting  and 
        /// with their Taylor series expansion, this translates into solving
        /// the following the linear system:
        /// 
        /// The resulting approximation of  is the following:
        /// 
        /// It is worth noting that if 
        /// (i.e., data are evenly spaced)
        /// we find the standard second order approximation:
        /// 
        /// With a similar procedure the forward/backward approximations used for
        /// boundaries can be derived.
        /// 
        /// References
        /// </summary>
        /// <param name="f">
        /// An N-dimensional array containing samples of a scalar function.
        /// </param>
        /// <param name="varargs">
        /// Spacing between f values. Default unitary spacing for all dimensions.
        /// Spacing can be specified using:
        /// 
        /// If axis is given, the number of varargs must equal the number of axes.
        /// Default: 1.
        /// </param>
        /// <param name="edge_order">
        /// Gradient is calculated using N-th order accurate differences
        /// at the boundaries. Default: 1.
        /// </param>
        /// <param name="axis">
        /// Gradient is calculated only along the given axis or axes
        /// The default (axis = None) is to calculate the gradient for all the axes
        /// of the input array. axis may be negative, in which case it counts from
        /// the last to the first axis.
        /// </param>
        /// <returns>
        /// A set of ndarrays (or a single ndarray if there is only one dimension)
        /// corresponding to the derivatives of f with respect to each dimension.
        /// Each derivative has the same shape as f.
        /// </returns>
        public static NDarray gradient(NDarray f, NDarray varargs = null, int? edge_order = null, int[] axis = null)
            => NumPy.Instance.gradient(f, varargs:varargs, edge_order:edge_order, axis:axis);
        
        /// <summary>
        /// Return the cross product of two (arrays of) vectors.
        /// 
        /// The cross product of a and b in  is a vector perpendicular
        /// to both a and b.  If a and b are arrays of vectors, the vectors
        /// are defined by the last axis of a and b by default, and these axes
        /// can have dimensions 2 or 3.  Where the dimension of either a or b is
        /// 2, the third component of the input vector is assumed to be zero and the
        /// cross product calculated accordingly.  In cases where both input vectors
        /// have dimension 2, the z-component of the cross product is returned.
        /// 
        /// Notes
        /// 
        /// Supports full broadcasting of the inputs.
        /// </summary>
        /// <param name="a">
        /// Components of the first vector(s).
        /// </param>
        /// <param name="b">
        /// Components of the second vector(s).
        /// </param>
        /// <param name="axisa">
        /// Axis of a that defines the vector(s).  By default, the last axis.
        /// </param>
        /// <param name="axisb">
        /// Axis of b that defines the vector(s).  By default, the last axis.
        /// </param>
        /// <param name="axisc">
        /// Axis of c containing the cross product vector(s).  Ignored if
        /// both input vectors have dimension 2, as the return is scalar.
        /// By default, the last axis.
        /// </param>
        /// <param name="axis">
        /// If defined, the axis of a, b and c that defines the vector(s)
        /// and cross product(s).  Overrides axisa, axisb and axisc.
        /// </param>
        /// <returns>
        /// Vector cross product(s).
        /// </returns>
        public static NDarray cross(NDarray a, NDarray b, int? axisa = null, int? axisb = null, int? axisc = null, int? axis = null)
            => NumPy.Instance.cross(a, b, axisa:axisa, axisb:axisb, axisc:axisc, axis:axis);
        
        /// <summary>
        /// Integrate along the given axis using the composite trapezoidal rule.
        /// 
        /// Integrate y (x) along given axis.
        /// 
        /// Notes
        /// 
        /// Image [2] illustrates trapezoidal rule – y-axis locations of points
        /// will be taken from y array, by default x-axis distances between
        /// points will be 1.0, alternatively they can be provided with x array
        /// or with dx scalar.  Return value will be equal to combined area under
        /// the red lines.
        /// 
        /// References
        /// </summary>
        /// <param name="y">
        /// Input array to integrate.
        /// </param>
        /// <param name="x">
        /// The sample points corresponding to the y values. If x is None,
        /// the sample points are assumed to be evenly spaced dx apart. The
        /// default is None.
        /// </param>
        /// <param name="dx">
        /// The spacing between sample points when x is None. The default is 1.
        /// </param>
        /// <param name="axis">
        /// The axis along which to integrate.
        /// </param>
        /// <returns>
        /// Definite integral as approximated by trapezoidal rule.
        /// </returns>
        public static float trapz(NDarray y, NDarray x = null, ValueType dx = null, int? axis = null)
            => NumPy.Instance.trapz(y, x:x, dx:dx, axis:axis);
        
        /// <summary>
        /// Return the sinc function.
        /// 
        /// The sinc function is .
        /// 
        /// Notes
        /// 
        /// sinc(0) is the limit value 1.
        /// 
        /// The name sinc is short for “sine cardinal” or “sinus cardinalis”.
        /// 
        /// The sinc function is used in various signal processing applications,
        /// including in anti-aliasing, in the construction of a Lanczos resampling
        /// filter, and in interpolation.
        /// 
        /// For bandlimited interpolation of discrete-time signals, the ideal
        /// interpolation kernel is proportional to the sinc function.
        /// 
        /// References
        /// </summary>
        /// <param name="x">
        /// Array (possibly multi-dimensional) of values for which to to
        /// calculate sinc(x).
        /// </param>
        /// <returns>
        /// sinc(x), which has the same shape as the input.
        /// </returns>
        public static NDarray sinc(NDarray x)
            => NumPy.Instance.sinc(x);
        
        /// <summary>
        /// Return the angle of the complex argument.
        /// </summary>
        /// <param name="z">
        /// A complex number or sequence of complex numbers.
        /// </param>
        /// <param name="deg">
        /// Return angle in degrees if True, radians if False (default).
        /// </param>
        /// <returns>
        /// The counterclockwise angle from the positive real axis on
        /// the complex plane, with dtype as numpy.float64.
        /// </returns>
        public static NDarray angle(NDarray z, bool? deg = null)
            => NumPy.Instance.angle(z, deg:deg);
        
        /// <summary>
        /// Return the real part of the complex argument.
        /// </summary>
        /// <param name="val">
        /// Input array.
        /// </param>
        /// <returns>
        /// The real component of the complex argument. If val is real, the type
        /// of val is used for the output.  If val has complex elements, the
        /// returned type is float.
        /// </returns>
        public static NDarray real(NDarray val)
            => NumPy.Instance.real(val);
        
        /// <summary>
        /// Return the imaginary part of the complex argument.
        /// </summary>
        /// <param name="val">
        /// Input array.
        /// </param>
        /// <returns>
        /// The imaginary component of the complex argument. If val is real,
        /// the type of val is used for the output.  If val has complex
        /// elements, the returned type is float.
        /// </returns>
        public static NDarray imag(NDarray val)
            => NumPy.Instance.imag(val);
        
        /// <summary>
        /// Returns the discrete, linear convolution of two one-dimensional sequences.
        /// 
        /// The convolution operator is often seen in signal processing, where it
        /// models the effect of a linear time-invariant system on a signal [1].  In
        /// probability theory, the sum of two independent random variables is
        /// distributed according to the convolution of their individual
        /// distributions.
        /// 
        /// If v is longer than a, the arrays are swapped before computation.
        /// 
        /// Notes
        /// 
        /// The discrete convolution operation is defined as
        /// 
        /// It can be shown that a convolution  in time/space
        /// is equivalent to the multiplication  in the Fourier
        /// domain, after appropriate padding (padding is necessary to prevent
        /// circular convolution).  Since multiplication is more efficient (faster)
        /// than convolution, the function scipy.signal.fftconvolve exploits the
        /// FFT to calculate the convolution of large data-sets.
        /// 
        /// References
        /// </summary>
        /// <param name="a">
        /// First one-dimensional input array.
        /// </param>
        /// <param name="v">
        /// Second one-dimensional input array.
        /// </param>
        /// <returns>
        /// Discrete, linear convolution of a and v.
        /// </returns>
        public static NDarray convolve(NDarray a, NDarray v, string mode = null)
            => NumPy.Instance.convolve(a, v, mode:mode);
        
        /// <summary>
        /// Clip (limit) the values in an array.
        /// 
        /// Given an interval, values outside the interval are clipped to
        /// the interval edges.  For example, if an interval of [0, 1]
        /// is specified, values smaller than 0 become 0, and values larger
        /// than 1 become 1.
        /// </summary>
        /// <param name="a">
        /// Array containing elements to clip.
        /// </param>
        /// <param name="a_min">
        /// Minimum value. If None, clipping is not performed on lower
        /// interval edge. Not more than one of a_min and a_max may be
        /// None.
        /// </param>
        /// <param name="a_max">
        /// Maximum value. If None, clipping is not performed on upper
        /// interval edge. Not more than one of a_min and a_max may be
        /// None. If a_min or a_max are array_like, then the three
        /// arrays will be broadcasted to match their shapes.
        /// </param>
        /// <param name="@out">
        /// The results will be placed in this array. It may be the input
        /// array for in-place clipping.  out must be of the right shape
        /// to hold the output.  Its type is preserved.
        /// </param>
        /// <returns>
        /// An array with the elements of a, but where values
        /// &lt; a_min are replaced with a_min, and those &gt; a_max
        /// with a_max.
        /// </returns>
        public static NDarray clip(NDarray a, NDarray a_min, NDarray a_max, NDarray @out = null)
            => NumPy.Instance.clip(a, a_min, a_max, @out:@out);
        
        /// <summary>
        /// Replace NaN with zero and infinity with large finite numbers.
        /// 
        /// If x is inexact, NaN is replaced by zero, and infinity and -infinity
        /// replaced by the respectively largest and most negative finite floating
        /// point values representable by x.dtype.
        /// 
        /// For complex dtypes, the above is applied to each of the real and
        /// imaginary components of x separately.
        /// 
        /// If x is not inexact, then no replacements are made.
        /// 
        /// Notes
        /// 
        /// NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
        /// (IEEE 754). This means that Not a Number is not equivalent to infinity.
        /// </summary>
        /// <param name="x">
        /// Input data.
        /// </param>
        /// <param name="copy">
        /// Whether to create a copy of x (True) or to replace values
        /// in-place (False). The in-place operation only occurs if
        /// casting to an array does not require a copy.
        /// Default is True.
        /// </param>
        /// <returns>
        /// x, with the non-finite values replaced. If copy is False, this may
        /// be x itself.
        /// </returns>
        public static NDarray nan_to_num(NDarray x, bool? copy = null)
            => NumPy.Instance.nan_to_num(x, copy:copy);
        
        /// <summary>
        /// If complex input returns a real array if complex parts are close to zero.
        /// 
        /// “Close to zero” is defined as tol * (machine epsilon of the type for
        /// a).
        /// 
        /// Notes
        /// 
        /// Machine epsilon varies from machine to machine and between data types
        /// but Python floats on most platforms have a machine epsilon equal to
        /// 2.2204460492503131e-16.  You can use ‘np.finfo(float).eps’ to print
        /// out the machine epsilon for floats.
        /// </summary>
        /// <param name="a">
        /// Input array.
        /// </param>
        /// <param name="tol">
        /// Tolerance in machine epsilons for the complex part of the elements
        /// in the array.
        /// </param>
        /// <returns>
        /// If a is real, the type of a is used for the output.  If a
        /// has complex elements, the returned type is float.
        /// </returns>
        public static NDarray real_if_close(NDarray a, float tol)
            => NumPy.Instance.real_if_close(a, tol);
        
        /*
        /// <summary>
        /// One-dimensional linear interpolation.
        /// 
        /// Returns the one-dimensional piecewise linear interpolant to a function
        /// with given discrete data points (xp, fp), evaluated at x.
        /// 
        /// Notes
        /// 
        /// Does not check that the x-coordinate sequence xp is increasing.
        /// If xp is not increasing, the results are nonsense.
        /// A simple check for increasing is:
        /// </summary>
        /// <param name="x">
        /// The x-coordinates at which to evaluate the interpolated values.
        /// </param>
        /// <param name="xp">
        /// The x-coordinates of the data points, must be increasing if argument
        /// period is not specified. Otherwise, xp is internally sorted after
        /// normalizing the periodic boundaries with xp = xp % period.
        /// </param>
        /// <param name="fp">
        /// The y-coordinates of the data points, same length as xp.
        /// </param>
        /// <param name="left">
        /// Value to return for x &lt; xp[0], default is fp[0].
        /// </param>
        /// <param name="right">
        /// Value to return for x &gt; xp[-1], default is fp[-1].
        /// </param>
        /// <param name="period">
        /// A period for the x-coordinates. This parameter allows the proper
        /// interpolation of angular x-coordinates. Parameters left and right
        /// are ignored if period is specified.
        /// </param>
        /// <returns>
        /// The interpolated values, same shape as x.
        /// </returns>
        public static float or complex (corresponding to fp) or ndarray interp(NDarray x, 1-D sequence of floats xp, 1-D sequence of float or complex fp, optional float or complex corresponding to fp left = null, optional float or complex corresponding to fp right = null, None or float period = null)
            => NumPy.Instance.interp(x, xp, fp, left:left, right:right, period:period);
        */
        
        
    }
}
