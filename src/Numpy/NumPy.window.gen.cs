// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Python.Runtime;
using Numpy.Models;
using Python.Included;

namespace Numpy
{
    public partial class NumPy
    {
        
        /// <summary>
        /// Return the Bartlett window.
        /// 
        /// The Bartlett window is very similar to a triangular window, except
        /// that the end points are at zero.  It is often used in signal
        /// processing for tapering a signal, without generating too much
        /// ripple in the frequency domain.
        /// 
        /// Notes
        /// 
        /// The Bartlett window is defined as
        /// 
        /// Most references to the Bartlett window come from the signal
        /// processing literature, where it is used as one of many windowing
        /// functions for smoothing values.  Note that convolution with this
        /// window produces linear interpolation.  It is also known as an
        /// apodization (which means”removing the foot”, i.e. smoothing
        /// discontinuities at the beginning and end of the sampled signal) or
        /// tapering function. The fourier transform of the Bartlett is the product
        /// of two sinc functions.
        /// Note the excellent discussion in Kanasewich.
        /// 
        /// References
        /// </summary>
        /// <param name="M">
        /// Number of points in the output window. If zero or less, an
        /// empty array is returned.
        /// </param>
        /// <returns>
        /// The triangular window, with the maximum value normalized to one
        /// (the value one appears only if the number of samples is odd), with
        /// the first and last samples equal to zero.
        /// </returns>
        public NDarray bartlett(int M)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                M,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("bartlett", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Return the Blackman window.
        /// 
        /// The Blackman window is a taper formed by using the first three
        /// terms of a summation of cosines. It was designed to have close to the
        /// minimal leakage possible.  It is close to optimal, only slightly worse
        /// than a Kaiser window.
        /// 
        /// Notes
        /// 
        /// The Blackman window is defined as
        /// 
        /// Most references to the Blackman window come from the signal processing
        /// literature, where it is used as one of many windowing functions for
        /// smoothing values.  It is also known as an apodization (which means
        /// “removing the foot”, i.e. smoothing discontinuities at the beginning
        /// and end of the sampled signal) or tapering function. It is known as a
        /// “near optimal” tapering function, almost as good (by some measures)
        /// as the kaiser window.
        /// 
        /// References
        /// 
        /// Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,
        /// Dover Publications, New York.
        /// 
        /// Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.
        /// Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.
        /// </summary>
        /// <param name="M">
        /// Number of points in the output window. If zero or less, an empty
        /// array is returned.
        /// </param>
        /// <returns>
        /// The window, with the maximum value normalized to one (the value one
        /// appears only if the number of samples is odd).
        /// </returns>
        public NDarray blackman(int M)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                M,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("blackman", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Return the Hamming window.
        /// 
        /// The Hamming window is a taper formed by using a weighted cosine.
        /// 
        /// Notes
        /// 
        /// The Hamming window is defined as
        /// 
        /// The Hamming was named for R. W. Hamming, an associate of J. W. Tukey
        /// and is described in Blackman and Tukey. It was recommended for
        /// smoothing the truncated autocovariance function in the time domain.
        /// Most references to the Hamming window come from the signal processing
        /// literature, where it is used as one of many windowing functions for
        /// smoothing values.  It is also known as an apodization (which means
        /// “removing the foot”, i.e. smoothing discontinuities at the beginning
        /// and end of the sampled signal) or tapering function.
        /// 
        /// References
        /// </summary>
        /// <param name="M">
        /// Number of points in the output window. If zero or less, an
        /// empty array is returned.
        /// </param>
        /// <returns>
        /// The window, with the maximum value normalized to one (the value
        /// one appears only if the number of samples is odd).
        /// </returns>
        public NDarray hamming(int M)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                M,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("hamming", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Return the Hanning window.
        /// 
        /// The Hanning window is a taper formed by using a weighted cosine.
        /// 
        /// Notes
        /// 
        /// The Hanning window is defined as
        /// 
        /// The Hanning was named for Julius von Hann, an Austrian meteorologist.
        /// It is also known as the Cosine Bell. Some authors prefer that it be
        /// called a Hann window, to help avoid confusion with the very similar
        /// Hamming window.
        /// 
        /// Most references to the Hanning window come from the signal processing
        /// literature, where it is used as one of many windowing functions for
        /// smoothing values.  It is also known as an apodization (which means
        /// “removing the foot”, i.e. smoothing discontinuities at the beginning
        /// and end of the sampled signal) or tapering function.
        /// 
        /// References
        /// </summary>
        /// <param name="M">
        /// Number of points in the output window. If zero or less, an
        /// empty array is returned.
        /// </param>
        /// <returns>
        /// The window, with the maximum value normalized to one (the value
        /// one appears only if M is odd).
        /// </returns>
        public NDarray hanning(int M)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                M,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("hanning", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Return the Kaiser window.
        /// 
        /// The Kaiser window is a taper formed by using a Bessel function.
        /// 
        /// Notes
        /// 
        /// The Kaiser window is defined as
        /// 
        /// with
        /// 
        /// where  is the modified zeroth-order Bessel function.
        /// 
        /// The Kaiser was named for Jim Kaiser, who discovered a simple
        /// approximation to the DPSS window based on Bessel functions.  The Kaiser
        /// window is a very good approximation to the Digital Prolate Spheroidal
        /// Sequence, or Slepian window, which is the transform which maximizes the
        /// energy in the main lobe of the window relative to total energy.
        /// 
        /// The Kaiser can approximate many other windows by varying the beta
        /// parameter.
        /// 
        /// A beta value of 14 is probably a good starting point. Note that as beta
        /// gets large, the window narrows, and so the number of samples needs to be
        /// large enough to sample the increasingly narrow spike, otherwise NaNs will
        /// get returned.
        /// 
        /// Most references to the Kaiser window come from the signal processing
        /// literature, where it is used as one of many windowing functions for
        /// smoothing values.  It is also known as an apodization (which means
        /// “removing the foot”, i.e. smoothing discontinuities at the beginning
        /// and end of the sampled signal) or tapering function.
        /// 
        /// References
        /// </summary>
        /// <param name="M">
        /// Number of points in the output window. If zero or less, an
        /// empty array is returned.
        /// </param>
        /// <param name="beta">
        /// Shape parameter for window.
        /// </param>
        /// <returns>
        /// The window, with the maximum value normalized to one (the value
        /// one appears only if the number of samples is odd).
        /// </returns>
        public NDarray kaiser(int M, float beta)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                M,
                beta,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("kaiser", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
    }
}
