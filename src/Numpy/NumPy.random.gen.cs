// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Python.Runtime;
using Python.Included;
using Numpy.Models;

namespace Numpy
{
    public partial class NumPy
    {
        
        /// <summary>
        /// Random values in a given shape.
        /// 
        /// Create an array of the given shape and populate it with
        /// random samples from a uniform distribution
        /// over [0, 1).
        /// 
        /// Notes
        /// 
        /// This is a convenience function. If you want an interface that
        /// takes a shape-tuple as the first argument, refer to
        /// np.random.random_sample .
        /// </summary>
        /// <param name="d1">
        /// The dimensions of the returned array, should all be positive.
        /// If no argument is given a single Python float is returned.
        /// </param>
        /// <param name="d0">
        /// The dimensions of the returned array, should all be positive.
        /// If no argument is given a single Python float is returned.
        /// </param>
        /// <returns>
        /// Random values.
        /// </returns>
        public NDarray rand(int? d1 = null, int? d0 = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (d1!=null) kwargs["d1"]=ToPython(d1);
            if (d0!=null) kwargs["d0"]=ToPython(d0);
            dynamic py = __self__.InvokeMethod("rand", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Return a sample (or samples) from the “standard normal” distribution.
        /// 
        /// If positive, int_like or int-convertible arguments are provided,
        /// randn generates an array of shape (d0, d1, ..., dn), filled
        /// with random floats sampled from a univariate “normal” (Gaussian)
        /// distribution of mean 0 and variance 1 (if any of the  are
        /// floats, they are first converted to integers by truncation). A single
        /// float randomly sampled from the distribution is returned if no
        /// argument is provided.
        /// 
        /// This is a convenience function.  If you want an interface that takes a
        /// tuple as the first argument, use numpy.random.standard_normal instead.
        /// 
        /// Notes
        /// 
        /// For random samples from , use:
        /// 
        /// sigma * np.random.randn(...) + mu
        /// </summary>
        /// <param name="d1">
        /// The dimensions of the returned array, should be all positive.
        /// If no argument is given a single Python float is returned.
        /// </param>
        /// <param name="d0">
        /// The dimensions of the returned array, should be all positive.
        /// If no argument is given a single Python float is returned.
        /// </param>
        /// <returns>
        /// A (d0, d1, ..., dn)-shaped array of floating-point samples from
        /// the standard normal distribution, or a single such float if
        /// no parameters were supplied.
        /// </returns>
        public NDarray randn(int? d1 = null, int? d0 = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (d1!=null) kwargs["d1"]=ToPython(d1);
            if (d0!=null) kwargs["d0"]=ToPython(d0);
            dynamic py = __self__.InvokeMethod("randn", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Return random integers from low (inclusive) to high (exclusive).
        /// 
        /// Return random integers from the “discrete uniform” distribution of
        /// the specified dtype in the “half-open” interval [low, high). If
        /// high is None (the default), then results are from [0, low).
        /// </summary>
        /// <param name="low">
        /// Lowest (signed) integer to be drawn from the distribution (unless
        /// high=None, in which case this parameter is one above the
        /// highest such integer).
        /// </param>
        /// <param name="high">
        /// If provided, one above the largest (signed) integer to be drawn
        /// from the distribution (see above for behavior if high=None).
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  Default is None, in which case a
        /// single value is returned.
        /// </param>
        /// <param name="dtype">
        /// Desired dtype of the result. All dtypes are determined by their
        /// name, i.e., ‘int64’, ‘int’, etc, so byteorder is not available
        /// and a specific precision may have different C types depending
        /// on the platform. The default value is ‘np.int’.
        /// </param>
        /// <returns>
        /// size-shaped array of random integers from the appropriate
        /// distribution, or a single such random int if size not provided.
        /// </returns>
        public NDarray<int> randint(int low, int? high = null, int[] size = null, Dtype dtype = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                low,
            });
            var kwargs=new PyDict();
            if (high!=null) kwargs["high"]=ToPython(high);
            if (size!=null) kwargs["size"]=ToPython(size);
            if (dtype!=null) kwargs["dtype"]=ToPython(dtype);
            dynamic py = __self__.InvokeMethod("randint", pyargs, kwargs);
            return ToCsharp<NDarray<int>>(py);
        }
        
        /// <summary>
        /// Random integers of type np.int between low and high, inclusive.
        /// 
        /// Return random integers of type np.int from the “discrete uniform”
        /// distribution in the closed interval [low, high].  If high is
        /// None (the default), then results are from [1, low]. The np.int
        /// type translates to the C long type used by Python 2 for “short”
        /// integers and its precision is platform dependent.
        /// 
        /// This function has been deprecated. Use randint instead.
        /// 
        /// Notes
        /// 
        /// To sample from N evenly spaced floating-point numbers between a and b,
        /// use:
        /// </summary>
        /// <param name="low">
        /// Lowest (signed) integer to be drawn from the distribution (unless
        /// high=None, in which case this parameter is the highest such
        /// integer).
        /// </param>
        /// <param name="high">
        /// If provided, the largest (signed) integer to be drawn from the
        /// distribution (see above for behavior if high=None).
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  Default is None, in which case a
        /// single value is returned.
        /// </param>
        /// <returns>
        /// size-shaped array of random integers from the appropriate
        /// distribution, or a single such random int if size not provided.
        /// </returns>
        public NDarray<int> random_integers(int low, int? high = null, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                low,
            });
            var kwargs=new PyDict();
            if (high!=null) kwargs["high"]=ToPython(high);
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("random_integers", pyargs, kwargs);
            return ToCsharp<NDarray<int>>(py);
        }
        
        /// <summary>
        /// Return random floats in the half-open interval [0.0, 1.0).
        /// 
        /// Results are from the “continuous uniform” distribution over the
        /// stated interval.  To sample  multiply
        /// the output of random_sample by (b-a) and add a:
        /// </summary>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  Default is None, in which case a
        /// single value is returned.
        /// </param>
        /// <returns>
        /// Array of random floats of shape size (unless size=None, in which
        /// case a single float is returned).
        /// </returns>
        public NDarray<float> random_sample(int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("random_sample", pyargs, kwargs);
            return ToCsharp<NDarray<float>>(py);
        }
        
        /// <summary>
        /// Return random floats in the half-open interval [0.0, 1.0).
        /// 
        /// Results are from the “continuous uniform” distribution over the
        /// stated interval.  To sample  multiply
        /// the output of random_sample by (b-a) and add a:
        /// </summary>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  Default is None, in which case a
        /// single value is returned.
        /// </param>
        /// <returns>
        /// Array of random floats of shape size (unless size=None, in which
        /// case a single float is returned).
        /// </returns>
        public NDarray<float> random(int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("random", pyargs, kwargs);
            return ToCsharp<NDarray<float>>(py);
        }
        
        /// <summary>
        /// Return random floats in the half-open interval [0.0, 1.0).
        /// 
        /// Results are from the “continuous uniform” distribution over the
        /// stated interval.  To sample  multiply
        /// the output of random_sample by (b-a) and add a:
        /// </summary>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  Default is None, in which case a
        /// single value is returned.
        /// </param>
        /// <returns>
        /// Array of random floats of shape size (unless size=None, in which
        /// case a single float is returned).
        /// </returns>
        public NDarray<float> ranf(int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("ranf", pyargs, kwargs);
            return ToCsharp<NDarray<float>>(py);
        }
        
        /// <summary>
        /// Return random floats in the half-open interval [0.0, 1.0).
        /// 
        /// Results are from the “continuous uniform” distribution over the
        /// stated interval.  To sample  multiply
        /// the output of random_sample by (b-a) and add a:
        /// </summary>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  Default is None, in which case a
        /// single value is returned.
        /// </param>
        /// <returns>
        /// Array of random floats of shape size (unless size=None, in which
        /// case a single float is returned).
        /// </returns>
        public NDarray<float> sample(int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("sample", pyargs, kwargs);
            return ToCsharp<NDarray<float>>(py);
        }
        
        /// <summary>
        /// Generates a random sample from a given 1-D array
        /// </summary>
        /// <param name="a">
        /// If an ndarray, a random sample is generated from its elements.
        /// If an int, the random sample is generated as if a were np.arange(a)
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  Default is None, in which case a
        /// single value is returned.
        /// </param>
        /// <param name="replace">
        /// Whether the sample is with or without replacement
        /// </param>
        /// <param name="p">
        /// The probabilities associated with each entry in a.
        /// If not given the sample assumes a uniform distribution over all
        /// entries in a.
        /// </param>
        /// <returns>
        /// The generated random samples
        /// </returns>
        public NDarray choice(NDarray a, int[] size = null, bool? replace = true, NDarray p = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                a,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            if (replace!=true) kwargs["replace"]=ToPython(replace);
            if (p!=null) kwargs["p"]=ToPython(p);
            dynamic py = __self__.InvokeMethod("choice", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Generates a random sample from a given 1-D array
        /// </summary>
        /// <param name="a">
        /// If an ndarray, a random sample is generated from its elements.
        /// If an int, the random sample is generated as if a were np.arange(a)
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  Default is None, in which case a
        /// single value is returned.
        /// </param>
        /// <param name="replace">
        /// Whether the sample is with or without replacement
        /// </param>
        /// <param name="p">
        /// The probabilities associated with each entry in a.
        /// If not given the sample assumes a uniform distribution over all
        /// entries in a.
        /// </param>
        /// <returns>
        /// The generated random samples
        /// </returns>
        public NDarray choice(int a, int[] size = null, bool? replace = true, NDarray p = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                a,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            if (replace!=true) kwargs["replace"]=ToPython(replace);
            if (p!=null) kwargs["p"]=ToPython(p);
            dynamic py = __self__.InvokeMethod("choice", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Return random bytes.
        /// </summary>
        /// <param name="length">
        /// Number of random bytes.
        /// </param>
        /// <returns>
        /// String of length length.
        /// </returns>
        public string bytes(int length)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                length,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("bytes", pyargs, kwargs);
            return ToCsharp<string>(py);
        }
        
        /// <summary>
        /// Modify a sequence in-place by shuffling its contents.
        /// 
        /// This function only shuffles the array along the first axis of a
        /// multi-dimensional array. The order of sub-arrays is changed but
        /// their contents remains the same.
        /// </summary>
        /// <param name="x">
        /// The array or list to be shuffled.
        /// </param>
        public void shuffle(NDarray x)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                x,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("shuffle", pyargs, kwargs);
        }
        
        /// <summary>
        /// Randomly permute a sequence, or return a permuted range.
        /// 
        /// If x is a multi-dimensional array, it is only shuffled along its
        /// first index.
        /// </summary>
        /// <param name="x">
        /// If x is an integer, randomly permute np.arange(x).
        /// If x is an array, make a copy and shuffle the elements
        /// randomly.
        /// </param>
        /// <returns>
        /// Permuted sequence or array range.
        /// </returns>
        public NDarray permutation(NDarray x)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                x,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("permutation", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Randomly permute a sequence, or return a permuted range.
        /// 
        /// If x is a multi-dimensional array, it is only shuffled along its
        /// first index.
        /// </summary>
        /// <param name="x">
        /// If x is an integer, randomly permute np.arange(x).
        /// If x is an array, make a copy and shuffle the elements
        /// randomly.
        /// </param>
        /// <returns>
        /// Permuted sequence or array range.
        /// </returns>
        public NDarray permutation(int x)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                x,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("permutation", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a Beta distribution.
        /// 
        /// The Beta distribution is a special case of the Dirichlet distribution,
        /// and is related to the Gamma distribution.  It has the probability
        /// distribution function
        /// 
        /// where the normalisation, B, is the beta function,
        /// 
        /// It is often seen in Bayesian inference and order statistics.
        /// </summary>
        /// <param name="a">
        /// Alpha, positive (&gt;0).
        /// </param>
        /// <param name="b">
        /// Beta, positive (&gt;0).
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if a and b are both scalars.
        /// Otherwise, np.broadcast(a, b).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized beta distribution.
        /// </returns>
        public NDarray beta(NDarray<float> a, NDarray<float> b, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                a,
                b,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("beta", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a binomial distribution.
        /// 
        /// Samples are drawn from a binomial distribution with specified
        /// parameters, n trials and p probability of success where
        /// n an integer &gt;= 0 and p is in the interval [0,1]. (n may be
        /// input as a float, but it is truncated to an integer in use)
        /// 
        /// Notes
        /// 
        /// The probability density for the binomial distribution is
        /// 
        /// where  is the number of trials,  is the probability
        /// of success, and  is the number of successes.
        /// 
        /// When estimating the standard error of a proportion in a population by
        /// using a random sample, the normal distribution works well unless the
        /// product p*n &lt;=5, where p = population proportion estimate, and n =
        /// number of samples, in which case the binomial distribution is used
        /// instead. For example, a sample of 15 people shows 4 who are left
        /// handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4,
        /// so the binomial distribution should be used in this case.
        /// 
        /// References
        /// </summary>
        /// <param name="n">
        /// Parameter of the distribution, &gt;= 0. Floats are also accepted,
        /// but they will be truncated to integers.
        /// </param>
        /// <param name="p">
        /// Parameter of the distribution, &gt;= 0 and &lt;=1.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if n and p are both scalars.
        /// Otherwise, np.broadcast(n, p).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized binomial distribution, where
        /// each sample is equal to the number of successes over the n trials.
        /// </returns>
        public NDarray binomial(NDarray<int> n, NDarray<float> p, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                n,
                p,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("binomial", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a binomial distribution.
        /// 
        /// Samples are drawn from a binomial distribution with specified
        /// parameters, n trials and p probability of success where
        /// n an integer &gt;= 0 and p is in the interval [0,1]. (n may be
        /// input as a float, but it is truncated to an integer in use)
        /// 
        /// Notes
        /// 
        /// The probability density for the binomial distribution is
        /// 
        /// where  is the number of trials,  is the probability
        /// of success, and  is the number of successes.
        /// 
        /// When estimating the standard error of a proportion in a population by
        /// using a random sample, the normal distribution works well unless the
        /// product p*n &lt;=5, where p = population proportion estimate, and n =
        /// number of samples, in which case the binomial distribution is used
        /// instead. For example, a sample of 15 people shows 4 who are left
        /// handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4,
        /// so the binomial distribution should be used in this case.
        /// 
        /// References
        /// </summary>
        /// <param name="n">
        /// Parameter of the distribution, &gt;= 0. Floats are also accepted,
        /// but they will be truncated to integers.
        /// </param>
        /// <param name="p">
        /// Parameter of the distribution, &gt;= 0 and &lt;=1.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if n and p are both scalars.
        /// Otherwise, np.broadcast(n, p).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized binomial distribution, where
        /// each sample is equal to the number of successes over the n trials.
        /// </returns>
        public NDarray binomial(int n, NDarray<float> p, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                n,
                p,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("binomial", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a chi-square distribution.
        /// 
        /// When df independent random variables, each with standard normal
        /// distributions (mean 0, variance 1), are squared and summed, the
        /// resulting distribution is chi-square (see Notes).  This distribution
        /// is often used in hypothesis testing.
        /// 
        /// Notes
        /// 
        /// The variable obtained by summing the squares of df independent,
        /// standard normally distributed random variables:
        /// 
        /// is chi-square distributed, denoted
        /// 
        /// The probability density function of the chi-squared distribution is
        /// 
        /// where  is the gamma function,
        /// 
        /// References
        /// </summary>
        /// <param name="df">
        /// Number of degrees of freedom, should be &gt; 0.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if df is a scalar.  Otherwise,
        /// np.array(df).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized chi-square distribution.
        /// </returns>
        public NDarray chisquare(NDarray<float> df, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                df,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("chisquare", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from the Dirichlet distribution.
        /// 
        /// Draw size samples of dimension k from a Dirichlet distribution. A
        /// Dirichlet-distributed random variable can be seen as a multivariate
        /// generalization of a Beta distribution. Dirichlet pdf is the conjugate
        /// prior of a multinomial in Bayesian inference.
        /// 
        /// Notes
        /// 
        /// Uses the following property for computation: for each dimension,
        /// draw a random sample y_i from a standard gamma generator of shape
        /// alpha_i, then
        ///  is
        /// Dirichlet distributed.
        /// 
        /// References
        /// </summary>
        /// <param name="alpha">
        /// Parameter of the distribution (k dimension for sample of
        /// dimension k).
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  Default is None, in which case a
        /// single value is returned.
        /// </param>
        /// <returns>
        /// The drawn samples, of shape (size, alpha.ndim).
        /// </returns>
        public NDarray dirichlet(NDarray alpha, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                alpha,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("dirichlet", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from an exponential distribution.
        /// 
        /// Its probability density function is
        /// 
        /// for x &gt; 0 and 0 elsewhere.  is the scale parameter,
        /// which is the inverse of the rate parameter .
        /// The rate parameter is an alternative, widely used parameterization
        /// of the exponential distribution [3].
        /// 
        /// The exponential distribution is a continuous analogue of the
        /// geometric distribution.  It describes many common situations, such as
        /// the size of raindrops measured over many rainstorms [1], or the time
        /// between page requests to Wikipedia [2].
        /// 
        /// References
        /// </summary>
        /// <param name="scale">
        /// The scale parameter, .
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if scale is a scalar.  Otherwise,
        /// np.array(scale).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized exponential distribution.
        /// </returns>
        public NDarray exponential(NDarray<float> scale = null, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                scale,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("exponential", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from an F distribution.
        /// 
        /// Samples are drawn from an F distribution with specified parameters,
        /// dfnum (degrees of freedom in numerator) and dfden (degrees of
        /// freedom in denominator), where both parameters should be greater than
        /// zero.
        /// 
        /// The random variate of the F distribution (also known as the
        /// Fisher distribution) is a continuous probability distribution
        /// that arises in ANOVA tests, and is the ratio of two chi-square
        /// variates.
        /// 
        /// Notes
        /// 
        /// The F statistic is used to compare in-group variances to between-group
        /// variances. Calculating the distribution depends on the sampling, and
        /// so it is a function of the respective degrees of freedom in the
        /// problem.  The variable dfnum is the number of samples minus one, the
        /// between-groups degrees of freedom, while dfden is the within-groups
        /// degrees of freedom, the sum of the number of samples in each group
        /// minus the number of groups.
        /// 
        /// References
        /// </summary>
        /// <param name="dfnum">
        /// Degrees of freedom in numerator, should be &gt; 0.
        /// </param>
        /// <param name="dfden">
        /// Degrees of freedom in denominator, should be &gt; 0.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if dfnum and dfden are both scalars.
        /// Otherwise, np.broadcast(dfnum, dfden).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized Fisher distribution.
        /// </returns>
        public NDarray f(NDarray<float> dfnum, NDarray<float> dfden, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                dfnum,
                dfden,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("f", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a Gamma distribution.
        /// 
        /// Samples are drawn from a Gamma distribution with specified parameters,
        /// shape (sometimes designated “k”) and scale (sometimes designated
        /// “theta”), where both parameters are &gt; 0.
        /// 
        /// Notes
        /// 
        /// The probability density for the Gamma distribution is
        /// 
        /// where  is the shape and  the scale,
        /// and  is the Gamma function.
        /// 
        /// The Gamma distribution is often used to model the times to failure of
        /// electronic components, and arises naturally in processes for which the
        /// waiting times between Poisson distributed events are relevant.
        /// 
        /// References
        /// </summary>
        /// <param name="shape">
        /// The shape of the gamma distribution. Should be greater than zero.
        /// </param>
        /// <param name="scale">
        /// The scale of the gamma distribution. Should be greater than zero.
        /// Default is equal to 1.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if shape and scale are both scalars.
        /// Otherwise, np.broadcast(shape, scale).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized gamma distribution.
        /// </returns>
        public NDarray gamma(Shape shape, NDarray<float> scale = null, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                shape,
            });
            var kwargs=new PyDict();
            if (scale!=null) kwargs["scale"]=ToPython(scale);
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("gamma", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from the geometric distribution.
        /// 
        /// Bernoulli trials are experiments with one of two outcomes:
        /// success or failure (an example of such an experiment is flipping
        /// a coin).  The geometric distribution models the number of trials
        /// that must be run in order to achieve success.  It is therefore
        /// supported on the positive integers, k = 1, 2, ....
        /// 
        /// The probability mass function of the geometric distribution is
        /// 
        /// where p is the probability of success of an individual trial.
        /// </summary>
        /// <param name="p">
        /// The probability of success of an individual trial.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if p is a scalar.  Otherwise,
        /// np.array(p).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized geometric distribution.
        /// </returns>
        public NDarray geometric(NDarray<float> p, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                p,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("geometric", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a Gumbel distribution.
        /// 
        /// Draw samples from a Gumbel distribution with specified location and
        /// scale.  For more information on the Gumbel distribution, see
        /// Notes and References below.
        /// 
        /// Notes
        /// 
        /// The Gumbel (or Smallest Extreme Value (SEV) or the Smallest Extreme
        /// Value Type I) distribution is one of a class of Generalized Extreme
        /// Value (GEV) distributions used in modeling extreme value problems.
        /// The Gumbel is a special case of the Extreme Value Type I distribution
        /// for maximums from distributions with “exponential-like” tails.
        /// 
        /// The probability density for the Gumbel distribution is
        /// 
        /// where  is the mode, a location parameter, and
        ///  is the scale parameter.
        /// 
        /// The Gumbel (named for German mathematician Emil Julius Gumbel) was used
        /// very early in the hydrology literature, for modeling the occurrence of
        /// flood events. It is also used for modeling maximum wind speed and
        /// rainfall rates.  It is a “fat-tailed” distribution - the probability of
        /// an event in the tail of the distribution is larger than if one used a
        /// Gaussian, hence the surprisingly frequent occurrence of 100-year
        /// floods. Floods were initially modeled as a Gaussian process, which
        /// underestimated the frequency of extreme events.
        /// 
        /// It is one of a class of extreme value distributions, the Generalized
        /// Extreme Value (GEV) distributions, which also includes the Weibull and
        /// Frechet.
        /// 
        /// The function has a mean of  and a variance
        /// of .
        /// 
        /// References
        /// </summary>
        /// <param name="loc">
        /// The location of the mode of the distribution. Default is 0.
        /// </param>
        /// <param name="scale">
        /// The scale parameter of the distribution. Default is 1.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if loc and scale are both scalars.
        /// Otherwise, np.broadcast(loc, scale).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized Gumbel distribution.
        /// </returns>
        public NDarray gumbel(NDarray<float> loc = null, NDarray<float> scale = null, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (loc!=null) kwargs["loc"]=ToPython(loc);
            if (scale!=null) kwargs["scale"]=ToPython(scale);
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("gumbel", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a Hypergeometric distribution.
        /// 
        /// Samples are drawn from a hypergeometric distribution with specified
        /// parameters, ngood (ways to make a good selection), nbad (ways to make
        /// a bad selection), and nsample = number of items sampled, which is less
        /// than or equal to the sum ngood + nbad.
        /// 
        /// Notes
        /// 
        /// The probability density for the Hypergeometric distribution is
        /// 
        /// where  and 
        /// 
        /// for P(x) the probability of x successes, g = ngood, b = nbad, and
        /// n = number of samples.
        /// 
        /// Consider an urn with black and white marbles in it, ngood of them
        /// black and nbad are white. If you draw nsample balls without
        /// replacement, then the hypergeometric distribution describes the
        /// distribution of black balls in the drawn sample.
        /// 
        /// Note that this distribution is very similar to the binomial
        /// distribution, except that in this case, samples are drawn without
        /// replacement, whereas in the Binomial case samples are drawn with
        /// replacement (or the sample space is infinite). As the sample space
        /// becomes large, this distribution approaches the binomial.
        /// 
        /// References
        /// </summary>
        /// <param name="ngood">
        /// Number of ways to make a good selection.  Must be nonnegative.
        /// </param>
        /// <param name="nbad">
        /// Number of ways to make a bad selection.  Must be nonnegative.
        /// </param>
        /// <param name="nsample">
        /// Number of items sampled.  Must be at least 1 and at most
        /// ngood + nbad.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if ngood, nbad, and nsample
        /// are all scalars.  Otherwise, np.broadcast(ngood, nbad, nsample).size
        /// samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized hypergeometric distribution.
        /// </returns>
        public NDarray hypergeometric(NDarray<int> ngood, NDarray<int> nbad, NDarray<int> nsample, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                ngood,
                nbad,
                nsample,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("hypergeometric", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from the Laplace or double exponential distribution with
        /// specified location (or mean) and scale (decay).
        /// 
        /// The Laplace distribution is similar to the Gaussian/normal distribution,
        /// but is sharper at the peak and has fatter tails. It represents the
        /// difference between two independent, identically distributed exponential
        /// random variables.
        /// 
        /// Notes
        /// 
        /// It has the probability density function
        /// 
        /// The first law of Laplace, from 1774, states that the frequency
        /// of an error can be expressed as an exponential function of the
        /// absolute magnitude of the error, which leads to the Laplace
        /// distribution. For many problems in economics and health
        /// sciences, this distribution seems to model the data better
        /// than the standard Gaussian distribution.
        /// 
        /// References
        /// </summary>
        /// <param name="loc">
        /// The position, , of the distribution peak. Default is 0.
        /// </param>
        /// <param name="scale">
        /// , the exponential decay. Default is 1.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if loc and scale are both scalars.
        /// Otherwise, np.broadcast(loc, scale).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized Laplace distribution.
        /// </returns>
        public NDarray laplace(NDarray<float> loc = null, NDarray<float> scale = null, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (loc!=null) kwargs["loc"]=ToPython(loc);
            if (scale!=null) kwargs["scale"]=ToPython(scale);
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("laplace", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a logistic distribution.
        /// 
        /// Samples are drawn from a logistic distribution with specified
        /// parameters, loc (location or mean, also median), and scale (&gt;0).
        /// 
        /// Notes
        /// 
        /// The probability density for the Logistic distribution is
        /// 
        /// where  = location and  = scale.
        /// 
        /// The Logistic distribution is used in Extreme Value problems where it
        /// can act as a mixture of Gumbel distributions, in Epidemiology, and by
        /// the World Chess Federation (FIDE) where it is used in the Elo ranking
        /// system, assuming the performance of each player is a logistically
        /// distributed random variable.
        /// 
        /// References
        /// </summary>
        /// <param name="loc">
        /// Parameter of the distribution. Default is 0.
        /// </param>
        /// <param name="scale">
        /// Parameter of the distribution. Should be greater than zero.
        /// Default is 1.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if loc and scale are both scalars.
        /// Otherwise, np.broadcast(loc, scale).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized logistic distribution.
        /// </returns>
        public NDarray logistic(NDarray<float> loc = null, NDarray<float> scale = null, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (loc!=null) kwargs["loc"]=ToPython(loc);
            if (scale!=null) kwargs["scale"]=ToPython(scale);
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("logistic", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a log-normal distribution.
        /// 
        /// Draw samples from a log-normal distribution with specified mean,
        /// standard deviation, and array shape.  Note that the mean and standard
        /// deviation are not the values for the distribution itself, but of the
        /// underlying normal distribution it is derived from.
        /// 
        /// Notes
        /// 
        /// A variable x has a log-normal distribution if log(x) is normally
        /// distributed.  The probability density function for the log-normal
        /// distribution is:
        /// 
        /// where  is the mean and  is the standard
        /// deviation of the normally distributed logarithm of the variable.
        /// A log-normal distribution results if a random variable is the product
        /// of a large number of independent, identically-distributed variables in
        /// the same way that a normal distribution results if the variable is the
        /// sum of a large number of independent, identically-distributed
        /// variables.
        /// 
        /// References
        /// </summary>
        /// <param name="mean">
        /// Mean value of the underlying normal distribution. Default is 0.
        /// </param>
        /// <param name="sigma">
        /// Standard deviation of the underlying normal distribution. Should
        /// be greater than zero. Default is 1.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if mean and sigma are both scalars.
        /// Otherwise, np.broadcast(mean, sigma).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized log-normal distribution.
        /// </returns>
        public NDarray lognormal(NDarray<float> mean = null, NDarray<float> sigma = null, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (mean!=null) kwargs["mean"]=ToPython(mean);
            if (sigma!=null) kwargs["sigma"]=ToPython(sigma);
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("lognormal", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a logarithmic series distribution.
        /// 
        /// Samples are drawn from a log series distribution with specified
        /// shape parameter, 0 &lt; p &lt; 1.
        /// 
        /// Notes
        /// 
        /// The probability density for the Log Series distribution is
        /// 
        /// where p = probability.
        /// 
        /// The log series distribution is frequently used to represent species
        /// richness and occurrence, first proposed by Fisher, Corbet, and
        /// Williams in 1943 [2].  It may also be used to model the numbers of
        /// occupants seen in cars [3].
        /// 
        /// References
        /// </summary>
        /// <param name="p">
        /// Shape parameter for the distribution.  Must be in the range (0, 1).
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if p is a scalar.  Otherwise,
        /// np.array(p).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized logarithmic series distribution.
        /// </returns>
        public NDarray logseries(NDarray<float> p, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                p,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("logseries", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a multinomial distribution.
        /// 
        /// The multinomial distribution is a multivariate generalisation of the
        /// binomial distribution.  Take an experiment with one of p
        /// possible outcomes.  An example of such an experiment is throwing a dice,
        /// where the outcome can be 1 through 6.  Each sample drawn from the
        /// distribution represents n such experiments.  Its values,
        /// X_i = [X_0, X_1, ..., X_p], represent the number of times the
        /// outcome was i.
        /// </summary>
        /// <param name="n">
        /// Number of experiments.
        /// </param>
        /// <param name="pvals">
        /// Probabilities of each of the p different outcomes.  These
        /// should sum to 1 (however, the last element is always assumed to
        /// account for the remaining probability, as long as
        /// sum(pvals[:-1]) &lt;= 1).
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  Default is None, in which case a
        /// single value is returned.
        /// </param>
        /// <returns>
        /// The drawn samples, of shape size, if that was provided.  If not,
        /// the shape is (N,).
        /// 
        /// In other words, each entry out[i,j,...,:] is an N-dimensional
        /// value drawn from the distribution.
        /// </returns>
        public NDarray multinomial(int n, NDarray<float> pvals, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                n,
                pvals,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("multinomial", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw random samples from a multivariate normal distribution.
        /// 
        /// The multivariate normal, multinormal or Gaussian distribution is a
        /// generalization of the one-dimensional normal distribution to higher
        /// dimensions.  Such a distribution is specified by its mean and
        /// covariance matrix.  These parameters are analogous to the mean
        /// (average or “center”) and variance (standard deviation, or “width,”
        /// squared) of the one-dimensional normal distribution.
        /// 
        /// Notes
        /// 
        /// The mean is a coordinate in N-dimensional space, which represents the
        /// location where samples are most likely to be generated.  This is
        /// analogous to the peak of the bell curve for the one-dimensional or
        /// univariate normal distribution.
        /// 
        /// Covariance indicates the level to which two variables vary together.
        /// From the multivariate normal distribution, we draw N-dimensional
        /// samples, .  The covariance matrix
        /// element  is the covariance of  and .
        /// The element  is the variance of  (i.e. its
        /// “spread”).
        /// 
        /// Instead of specifying the full covariance matrix, popular
        /// approximations include:
        /// 
        /// This geometrical property can be seen in two dimensions by plotting
        /// generated data-points:
        /// 
        /// Diagonal covariance means that points are oriented along x or y-axis:
        /// 
        /// Note that the covariance matrix must be positive semidefinite (a.k.a.
        /// nonnegative-definite). Otherwise, the behavior of this method is
        /// undefined and backwards compatibility is not guaranteed.
        /// 
        /// References
        /// </summary>
        /// <param name="mean">
        /// Mean of the N-dimensional distribution.
        /// </param>
        /// <param name="cov">
        /// Covariance matrix of the distribution. It must be symmetric and
        /// positive-semidefinite for proper sampling.
        /// </param>
        /// <param name="size">
        /// Given a shape of, for example, (m,n,k), m*n*k samples are
        /// generated, and packed in an m-by-n-by-k arrangement.  Because
        /// each sample is N-dimensional, the output shape is (m,n,k,N).
        /// If no shape is specified, a single (N-D) sample is returned.
        /// </param>
        /// <param name="check_valid">
        /// Behavior when the covariance matrix is not positive semidefinite.
        /// </param>
        /// <param name="tol">
        /// Tolerance when checking the singular values in covariance matrix.
        /// </param>
        /// <returns>
        /// The drawn samples, of shape size, if that was provided.  If not,
        /// the shape is (N,).
        /// 
        /// In other words, each entry out[i,j,...,:] is an N-dimensional
        /// value drawn from the distribution.
        /// </returns>
        public NDarray multivariate_normal(NDarray mean, NDarray cov, int[] size = null, string check_valid = null, float? tol = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                mean,
                cov,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            if (check_valid!=null) kwargs["check_valid"]=ToPython(check_valid);
            if (tol!=null) kwargs["tol"]=ToPython(tol);
            dynamic py = __self__.InvokeMethod("multivariate_normal", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a negative binomial distribution.
        /// 
        /// Samples are drawn from a negative binomial distribution with specified
        /// parameters, n successes and p probability of success where n is an
        /// integer &gt; 0 and p is in the interval [0, 1].
        /// 
        /// Notes
        /// 
        /// The probability density for the negative binomial distribution is
        /// 
        /// where  is the number of successes,  is the
        /// probability of success, and  is the number of trials.
        /// The negative binomial distribution gives the probability of N
        /// failures given n successes, with a success on the last trial.
        /// 
        /// If one throws a die repeatedly until the third time a “1” appears,
        /// then the probability distribution of the number of non-“1”s that
        /// appear before the third “1” is a negative binomial distribution.
        /// 
        /// References
        /// </summary>
        /// <param name="n">
        /// Parameter of the distribution, &gt; 0. Floats are also accepted,
        /// but they will be truncated to integers.
        /// </param>
        /// <param name="p">
        /// Parameter of the distribution, &gt;= 0 and &lt;=1.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if n and p are both scalars.
        /// Otherwise, np.broadcast(n, p).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized negative binomial distribution,
        /// where each sample is equal to N, the number of failures that
        /// occurred before a total of n successes was reached.
        /// </returns>
        public NDarray negative_binomial(NDarray<int> n, NDarray<float> p, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                n,
                p,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("negative_binomial", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a noncentral chi-square distribution.
        /// 
        /// The noncentral  distribution is a generalisation of
        /// the  distribution.
        /// 
        /// Notes
        /// 
        /// The probability density function for the noncentral Chi-square
        /// distribution is
        /// 
        /// where  is the Chi-square with q degrees of freedom.
        /// 
        /// In Delhi (2007), it is noted that the noncentral chi-square is
        /// useful in bombing and coverage problems, the probability of
        /// killing the point target given by the noncentral chi-squared
        /// distribution.
        /// 
        /// References
        /// </summary>
        /// <param name="df">
        /// Degrees of freedom, should be &gt; 0.
        /// </param>
        /// <param name="nonc">
        /// Non-centrality, should be non-negative.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if df and nonc are both scalars.
        /// Otherwise, np.broadcast(df, nonc).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized noncentral chi-square distribution.
        /// </returns>
        public NDarray noncentral_chisquare(NDarray<float> df, NDarray<float> nonc, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                df,
                nonc,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("noncentral_chisquare", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from the noncentral F distribution.
        /// 
        /// Samples are drawn from an F distribution with specified parameters,
        /// dfnum (degrees of freedom in numerator) and dfden (degrees of
        /// freedom in denominator), where both parameters &gt; 1.
        /// nonc is the non-centrality parameter.
        /// 
        /// Notes
        /// 
        /// When calculating the power of an experiment (power = probability of
        /// rejecting the null hypothesis when a specific alternative is true) the
        /// non-central F statistic becomes important.  When the null hypothesis is
        /// true, the F statistic follows a central F distribution. When the null
        /// hypothesis is not true, then it follows a non-central F statistic.
        /// 
        /// References
        /// </summary>
        /// <param name="dfnum">
        /// Numerator degrees of freedom, should be &gt; 0.
        /// </param>
        /// <param name="dfden">
        /// Denominator degrees of freedom, should be &gt; 0.
        /// </param>
        /// <param name="nonc">
        /// Non-centrality parameter, the sum of the squares of the numerator
        /// means, should be &gt;= 0.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if dfnum, dfden, and nonc
        /// are all scalars.  Otherwise, np.broadcast(dfnum, dfden, nonc).size
        /// samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized noncentral Fisher distribution.
        /// </returns>
        public NDarray noncentral_f(NDarray<float> dfnum, NDarray<float> dfden, NDarray<float> nonc, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                dfnum,
                dfden,
                nonc,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("noncentral_f", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw random samples from a normal (Gaussian) distribution.
        /// 
        /// The probability density function of the normal distribution, first
        /// derived by De Moivre and 200 years later by both Gauss and Laplace
        /// independently [2], is often called the bell curve because of
        /// its characteristic shape (see the example below).
        /// 
        /// The normal distributions occurs often in nature.  For example, it
        /// describes the commonly occurring distribution of samples influenced
        /// by a large number of tiny, random disturbances, each with its own
        /// unique distribution [2].
        /// 
        /// Notes
        /// 
        /// The probability density for the Gaussian distribution is
        /// 
        /// where  is the mean and  the standard
        /// deviation. The square of the standard deviation, ,
        /// is called the variance.
        /// 
        /// The function has its peak at the mean, and its “spread” increases with
        /// the standard deviation (the function reaches 0.607 times its maximum at
        ///  and  [2]).  This implies that
        /// numpy.random.normal is more likely to return samples lying close to
        /// the mean, rather than those far away.
        /// 
        /// References
        /// </summary>
        /// <param name="loc">
        /// Mean (“centre”) of the distribution.
        /// </param>
        /// <param name="scale">
        /// Standard deviation (spread or “width”) of the distribution.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if loc and scale are both scalars.
        /// Otherwise, np.broadcast(loc, scale).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized normal distribution.
        /// </returns>
        public NDarray normal(NDarray<float> loc = null, NDarray<float> scale = null, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (loc!=null) kwargs["loc"]=ToPython(loc);
            if (scale!=null) kwargs["scale"]=ToPython(scale);
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("normal", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a Pareto II or Lomax distribution with
        /// specified shape.
        /// 
        /// The Lomax or Pareto II distribution is a shifted Pareto
        /// distribution. The classical Pareto distribution can be
        /// obtained from the Lomax distribution by adding 1 and
        /// multiplying by the scale parameter m (see Notes).  The
        /// smallest value of the Lomax distribution is zero while for the
        /// classical Pareto distribution it is mu, where the standard
        /// Pareto distribution has location mu = 1.  Lomax can also
        /// be considered as a simplified version of the Generalized
        /// Pareto distribution (available in SciPy), with the scale set
        /// to one and the location set to zero.
        /// 
        /// The Pareto distribution must be greater than zero, and is
        /// unbounded above.  It is also known as the “80-20 rule”.  In
        /// this distribution, 80 percent of the weights are in the lowest
        /// 20 percent of the range, while the other 20 percent fill the
        /// remaining 80 percent of the range.
        /// 
        /// Notes
        /// 
        /// The probability density for the Pareto distribution is
        /// 
        /// where  is the shape and  the scale.
        /// 
        /// The Pareto distribution, named after the Italian economist
        /// Vilfredo Pareto, is a power law probability distribution
        /// useful in many real world problems.  Outside the field of
        /// economics it is generally referred to as the Bradford
        /// distribution. Pareto developed the distribution to describe
        /// the distribution of wealth in an economy.  It has also found
        /// use in insurance, web page access statistics, oil field sizes,
        /// and many other problems, including the download frequency for
        /// projects in Sourceforge [1].  It is one of the so-called
        /// “fat-tailed” distributions.
        /// 
        /// References
        /// </summary>
        /// <param name="a">
        /// Shape of the distribution. Should be greater than zero.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if a is a scalar.  Otherwise,
        /// np.array(a).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized Pareto distribution.
        /// </returns>
        public NDarray pareto(NDarray<float> a, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                a,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("pareto", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a Poisson distribution.
        /// 
        /// The Poisson distribution is the limit of the binomial distribution
        /// for large N.
        /// 
        /// Notes
        /// 
        /// The Poisson distribution
        /// 
        /// For events with an expected separation  the Poisson
        /// distribution  describes the probability of
        ///  events occurring within the observed
        /// interval .
        /// 
        /// Because the output is limited to the range of the C long type, a
        /// ValueError is raised when lam is within 10 sigma of the maximum
        /// representable value.
        /// 
        /// References
        /// </summary>
        /// <param name="lam">
        /// Expectation of interval, should be &gt;= 0. A sequence of expectation
        /// intervals must be broadcastable over the requested size.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if lam is a scalar. Otherwise,
        /// np.array(lam).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized Poisson distribution.
        /// </returns>
        public NDarray poisson(NDarray<float> lam = null, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (lam!=null) kwargs["lam"]=ToPython(lam);
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("poisson", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a Rayleigh distribution.
        /// 
        /// The  and Weibull distributions are generalizations of the
        /// Rayleigh.
        /// 
        /// Notes
        /// 
        /// The probability density function for the Rayleigh distribution is
        /// 
        /// The Rayleigh distribution would arise, for example, if the East
        /// and North components of the wind velocity had identical zero-mean
        /// Gaussian distributions.  Then the wind speed would have a Rayleigh
        /// distribution.
        /// 
        /// References
        /// </summary>
        /// <param name="scale">
        /// Scale, also equals the mode. Should be &gt;= 0. Default is 1.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if scale is a scalar.  Otherwise,
        /// np.array(scale).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized Rayleigh distribution.
        /// </returns>
        public NDarray rayleigh(NDarray<float> scale = null, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (scale!=null) kwargs["scale"]=ToPython(scale);
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("rayleigh", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a standard Cauchy distribution with mode = 0.
        /// 
        /// Also known as the Lorentz distribution.
        /// 
        /// Notes
        /// 
        /// The probability density function for the full Cauchy distribution is
        /// 
        /// and the Standard Cauchy distribution just sets  and
        /// 
        /// 
        /// The Cauchy distribution arises in the solution to the driven harmonic
        /// oscillator problem, and also describes spectral line broadening. It
        /// also describes the distribution of values at which a line tilted at
        /// a random angle will cut the x axis.
        /// 
        /// When studying hypothesis tests that assume normality, seeing how the
        /// tests perform on data from a Cauchy distribution is a good indicator of
        /// their sensitivity to a heavy-tailed distribution, since the Cauchy looks
        /// very much like a Gaussian distribution, but with heavier tails.
        /// 
        /// References
        /// </summary>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  Default is None, in which case a
        /// single value is returned.
        /// </param>
        /// <returns>
        /// The drawn samples.
        /// </returns>
        public NDarray standard_cauchy(int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("standard_cauchy", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from the standard exponential distribution.
        /// 
        /// standard_exponential is identical to the exponential distribution
        /// with a scale parameter of 1.
        /// </summary>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  Default is None, in which case a
        /// single value is returned.
        /// </param>
        /// <returns>
        /// Drawn samples.
        /// </returns>
        public NDarray standard_exponential(int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("standard_exponential", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a standard Gamma distribution.
        /// 
        /// Samples are drawn from a Gamma distribution with specified parameters,
        /// shape (sometimes designated “k”) and scale=1.
        /// 
        /// Notes
        /// 
        /// The probability density for the Gamma distribution is
        /// 
        /// where  is the shape and  the scale,
        /// and  is the Gamma function.
        /// 
        /// The Gamma distribution is often used to model the times to failure of
        /// electronic components, and arises naturally in processes for which the
        /// waiting times between Poisson distributed events are relevant.
        /// 
        /// References
        /// </summary>
        /// <param name="shape">
        /// Parameter, should be &gt; 0.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if shape is a scalar.  Otherwise,
        /// np.array(shape).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized standard gamma distribution.
        /// </returns>
        public NDarray standard_gamma(Shape shape, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                shape,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("standard_gamma", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a standard Normal distribution (mean=0, stdev=1).
        /// </summary>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  Default is None, in which case a
        /// single value is returned.
        /// </param>
        /// <returns>
        /// Drawn samples.
        /// </returns>
        public NDarray standard_normal(int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("standard_normal", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a standard Student’s t distribution with df degrees
        /// of freedom.
        /// 
        /// A special case of the hyperbolic distribution.  As df gets
        /// large, the result resembles that of the standard normal
        /// distribution (standard_normal).
        /// 
        /// Notes
        /// 
        /// The probability density function for the t distribution is
        /// 
        /// The t test is based on an assumption that the data come from a
        /// Normal distribution. The t test provides a way to test whether
        /// the sample mean (that is the mean calculated from the data) is
        /// a good estimate of the true mean.
        /// 
        /// The derivation of the t-distribution was first published in
        /// 1908 by William Gosset while working for the Guinness Brewery
        /// in Dublin. Due to proprietary issues, he had to publish under
        /// a pseudonym, and so he used the name Student.
        /// 
        /// References
        /// </summary>
        /// <param name="df">
        /// Degrees of freedom, should be &gt; 0.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if df is a scalar.  Otherwise,
        /// np.array(df).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized standard Student’s t distribution.
        /// </returns>
        public NDarray standard_t(NDarray<float> df, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                df,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("standard_t", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from the triangular distribution over the
        /// interval [left, right].
        /// 
        /// The triangular distribution is a continuous probability
        /// distribution with lower limit left, peak at mode, and upper
        /// limit right. Unlike the other distributions, these parameters
        /// directly define the shape of the pdf.
        /// 
        /// Notes
        /// 
        /// The probability density function for the triangular distribution is
        /// 
        /// The triangular distribution is often used in ill-defined
        /// problems where the underlying distribution is not known, but
        /// some knowledge of the limits and mode exists. Often it is used
        /// in simulations.
        /// 
        /// References
        /// </summary>
        /// <param name="left">
        /// Lower limit.
        /// </param>
        /// <param name="mode">
        /// The value where the peak of the distribution occurs.
        /// The value should fulfill the condition left &lt;= mode &lt;= right.
        /// </param>
        /// <param name="right">
        /// Upper limit, should be larger than left.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if left, mode, and right
        /// are all scalars.  Otherwise, np.broadcast(left, mode, right).size
        /// samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized triangular distribution.
        /// </returns>
        public NDarray triangular(NDarray<float> left, NDarray<float> mode, NDarray<float> right, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                left,
                mode,
                right,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("triangular", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a uniform distribution.
        /// 
        /// Samples are uniformly distributed over the half-open interval
        /// [low, high) (includes low, but excludes high).  In other words,
        /// any value within the given interval is equally likely to be drawn
        /// by uniform.
        /// 
        /// Notes
        /// 
        /// The probability density function of the uniform distribution is
        /// 
        /// anywhere within the interval [a, b), and zero elsewhere.
        /// 
        /// When high == low, values of low will be returned.
        /// If high &lt; low, the results are officially undefined
        /// and may eventually raise an error, i.e. do not rely on this
        /// function to behave when passed arguments satisfying that
        /// inequality condition.
        /// </summary>
        /// <param name="low">
        /// Lower boundary of the output interval.  All values generated will be
        /// greater than or equal to low.  The default value is 0.
        /// </param>
        /// <param name="high">
        /// Upper boundary of the output interval.  All values generated will be
        /// less than high.  The default value is 1.0.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if low and high are both scalars.
        /// Otherwise, np.broadcast(low, high).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized uniform distribution.
        /// </returns>
        public NDarray uniform(NDarray<float> low = null, NDarray<float> high = null, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (low!=null) kwargs["low"]=ToPython(low);
            if (high!=null) kwargs["high"]=ToPython(high);
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("uniform", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a von Mises distribution.
        /// 
        /// Samples are drawn from a von Mises distribution with specified mode
        /// (mu) and dispersion (kappa), on the interval [-pi, pi].
        /// 
        /// The von Mises distribution (also known as the circular normal
        /// distribution) is a continuous probability distribution on the unit
        /// circle.  It may be thought of as the circular analogue of the normal
        /// distribution.
        /// 
        /// Notes
        /// 
        /// The probability density for the von Mises distribution is
        /// 
        /// where  is the mode and  the dispersion,
        /// and  is the modified Bessel function of order 0.
        /// 
        /// The von Mises is named for Richard Edler von Mises, who was born in
        /// Austria-Hungary, in what is now the Ukraine.  He fled to the United
        /// States in 1939 and became a professor at Harvard.  He worked in
        /// probability theory, aerodynamics, fluid mechanics, and philosophy of
        /// science.
        /// 
        /// References
        /// </summary>
        /// <param name="mu">
        /// Mode (“center”) of the distribution.
        /// </param>
        /// <param name="kappa">
        /// Dispersion of the distribution, has to be &gt;=0.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if mu and kappa are both scalars.
        /// Otherwise, np.broadcast(mu, kappa).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized von Mises distribution.
        /// </returns>
        public NDarray vonmises(NDarray<float> mu, NDarray<float> kappa, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                mu,
                kappa,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("vonmises", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a Wald, or inverse Gaussian, distribution.
        /// 
        /// As the scale approaches infinity, the distribution becomes more like a
        /// Gaussian. Some references claim that the Wald is an inverse Gaussian
        /// with mean equal to 1, but this is by no means universal.
        /// 
        /// The inverse Gaussian distribution was first studied in relationship to
        /// Brownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian
        /// because there is an inverse relationship between the time to cover a
        /// unit distance and distance covered in unit time.
        /// 
        /// Notes
        /// 
        /// The probability density function for the Wald distribution is
        /// 
        /// As noted above the inverse Gaussian distribution first arise
        /// from attempts to model Brownian motion. It is also a
        /// competitor to the Weibull for use in reliability modeling and
        /// modeling stock returns and interest rate processes.
        /// 
        /// References
        /// </summary>
        /// <param name="mean">
        /// Distribution mean, should be &gt; 0.
        /// </param>
        /// <param name="scale">
        /// Scale parameter, should be &gt;= 0.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if mean and scale are both scalars.
        /// Otherwise, np.broadcast(mean, scale).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized Wald distribution.
        /// </returns>
        public NDarray wald(NDarray<float> mean, NDarray<float> scale, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                mean,
                scale,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("wald", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a Weibull distribution.
        /// 
        /// Draw samples from a 1-parameter Weibull distribution with the given
        /// shape parameter a.
        /// 
        /// Here, U is drawn from the uniform distribution over (0,1].
        /// 
        /// The more common 2-parameter Weibull, including a scale parameter
        ///  is just .
        /// 
        /// Notes
        /// 
        /// The Weibull (or Type III asymptotic extreme value distribution
        /// for smallest values, SEV Type III, or Rosin-Rammler
        /// distribution) is one of a class of Generalized Extreme Value
        /// (GEV) distributions used in modeling extreme value problems.
        /// This class includes the Gumbel and Frechet distributions.
        /// 
        /// The probability density for the Weibull distribution is
        /// 
        /// where  is the shape and  the scale.
        /// 
        /// The function has its peak (the mode) at
        /// .
        /// 
        /// When a = 1, the Weibull distribution reduces to the exponential
        /// distribution.
        /// 
        /// References
        /// </summary>
        /// <param name="a">
        /// Shape parameter of the distribution.  Must be nonnegative.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if a is a scalar.  Otherwise,
        /// np.array(a).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized Weibull distribution.
        /// </returns>
        public NDarray weibull(NDarray<float> a, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                a,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("weibull", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Draw samples from a Zipf distribution.
        /// 
        /// Samples are drawn from a Zipf distribution with specified parameter
        /// a &gt; 1.
        /// 
        /// The Zipf distribution (also known as the zeta distribution) is a
        /// continuous probability distribution that satisfies Zipf’s law: the
        /// frequency of an item is inversely proportional to its rank in a
        /// frequency table.
        /// 
        /// Notes
        /// 
        /// The probability density for the Zipf distribution is
        /// 
        /// where  is the Riemann Zeta function.
        /// 
        /// It is named for the American linguist George Kingsley Zipf, who noted
        /// that the frequency of any word in a sample of a language is inversely
        /// proportional to its rank in the frequency table.
        /// 
        /// References
        /// </summary>
        /// <param name="a">
        /// Distribution parameter. Should be greater than 1.
        /// </param>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  If size is None (default),
        /// a single value is returned if a is a scalar. Otherwise,
        /// np.array(a).size samples are drawn.
        /// </param>
        /// <returns>
        /// Drawn samples from the parameterized Zipf distribution.
        /// </returns>
        public NDarray zipf(NDarray<float> a, int[] size = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                a,
            });
            var kwargs=new PyDict();
            if (size!=null) kwargs["size"]=ToPython(size);
            dynamic py = __self__.InvokeMethod("zipf", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Container for the Mersenne Twister pseudo-random number generator.
        /// 
        /// RandomState exposes a number of methods for generating random numbers
        /// drawn from a variety of probability distributions. In addition to the
        /// distribution-specific arguments, each method takes a keyword argument
        /// size that defaults to None. If size is None, then a single
        /// value is generated and returned. If size is an integer, then a 1-D
        /// array filled with generated values is returned. If size is a tuple,
        /// then an array with that shape is filled and returned.
        /// 
        /// Compatibility Guarantee
        /// A fixed seed and a fixed series of calls to ‘RandomState’ methods using
        /// the same parameters will always produce the same results up to roundoff
        /// error except when the values were incorrect. Incorrect values will be
        /// fixed and the NumPy version in which the fix was made will be noted in
        /// the relevant docstring. Extension of existing parameter ranges and the
        /// addition of new parameters is allowed as long the previous behavior
        /// remains unchanged.
        /// 
        /// Notes
        /// 
        /// The Python stdlib module “random” also contains a Mersenne Twister
        /// pseudo-random number generator with a number of methods that are similar
        /// to the ones available in RandomState. RandomState, besides being
        /// NumPy-aware, has the advantage that it provides a much larger number
        /// of probability distributions to choose from.
        /// 
        /// Methods
        /// </summary>
        /// <param name="seed">
        /// Random seed used to initialize the pseudo-random number generator.  Can
        /// be any integer between 0 and 2**32 - 1 inclusive, an array (or other
        /// sequence) of such integers, or None (the default).  If seed is
        /// None, then RandomState will try to read data from
        /// /dev/urandom (or the Windows analogue) if available or seed from
        /// the clock otherwise.
        /// </param>
        public void RandomState(int? seed = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (seed!=null) kwargs["seed"]=ToPython(seed);
            dynamic py = __self__.InvokeMethod("RandomState", pyargs, kwargs);
        }
        
        /// <summary>
        /// Container for the Mersenne Twister pseudo-random number generator.
        /// 
        /// RandomState exposes a number of methods for generating random numbers
        /// drawn from a variety of probability distributions. In addition to the
        /// distribution-specific arguments, each method takes a keyword argument
        /// size that defaults to None. If size is None, then a single
        /// value is generated and returned. If size is an integer, then a 1-D
        /// array filled with generated values is returned. If size is a tuple,
        /// then an array with that shape is filled and returned.
        /// 
        /// Compatibility Guarantee
        /// A fixed seed and a fixed series of calls to ‘RandomState’ methods using
        /// the same parameters will always produce the same results up to roundoff
        /// error except when the values were incorrect. Incorrect values will be
        /// fixed and the NumPy version in which the fix was made will be noted in
        /// the relevant docstring. Extension of existing parameter ranges and the
        /// addition of new parameters is allowed as long the previous behavior
        /// remains unchanged.
        /// 
        /// Notes
        /// 
        /// The Python stdlib module “random” also contains a Mersenne Twister
        /// pseudo-random number generator with a number of methods that are similar
        /// to the ones available in RandomState. RandomState, besides being
        /// NumPy-aware, has the advantage that it provides a much larger number
        /// of probability distributions to choose from.
        /// 
        /// Methods
        /// </summary>
        /// <param name="seed">
        /// Random seed used to initialize the pseudo-random number generator.  Can
        /// be any integer between 0 and 2**32 - 1 inclusive, an array (or other
        /// sequence) of such integers, or None (the default).  If seed is
        /// None, then RandomState will try to read data from
        /// /dev/urandom (or the Windows analogue) if available or seed from
        /// the clock otherwise.
        /// </param>
        public void RandomState(NDarray seed = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (seed!=null) kwargs["seed"]=ToPython(seed);
            dynamic py = __self__.InvokeMethod("RandomState", pyargs, kwargs);
        }
        
        /// <summary>
        /// Seed the generator.
        /// 
        /// This method is called when RandomState is initialized. It can be
        /// called again to re-seed the generator. For details, see RandomState.
        /// </summary>
        /// <param name="seed">
        /// Seed for RandomState.
        /// Must be convertible to 32 bit unsigned integers.
        /// </param>
        public void seed(int? seed = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (seed!=null) kwargs["seed"]=ToPython(seed);
            dynamic py = __self__.InvokeMethod("seed", pyargs, kwargs);
        }
        
        /// <summary>
        /// Seed the generator.
        /// 
        /// This method is called when RandomState is initialized. It can be
        /// called again to re-seed the generator. For details, see RandomState.
        /// </summary>
        /// <param name="seed">
        /// Seed for RandomState.
        /// Must be convertible to 32 bit unsigned integers.
        /// </param>
        public void seed(NDarray seed = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (seed!=null) kwargs["seed"]=ToPython(seed);
            dynamic py = __self__.InvokeMethod("seed", pyargs, kwargs);
        }
        
        /*
        /// <summary>
        /// Return a tuple representing the internal state of the generator.
        /// 
        /// For more details, see set_state.
        /// 
        /// Notes
        /// 
        /// set_state and get_state are not needed to work with any of the
        /// random distributions in NumPy. If the internal state is manually altered,
        /// the user should know exactly what he/she is doing.
        /// </summary>
        /// <param name="@out">
        /// The returned tuple has the following items:
        /// </param>
        /// <returns>
        /// The returned tuple has the following items:
        /// </returns>
        public tuple(str get_state(tuple(str @out = null)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (@out!=null) kwargs["out"]=ToPython(@out);
            dynamic py = __self__.InvokeMethod("get_state", pyargs, kwargs);
            return ToCsharp<tuple(str>(py);
        }
        */
        
        /*
        /// <summary>
        /// Set the internal state of the generator from a tuple.
        /// 
        /// For use if one has reason to manually (re-)set the internal state of the
        /// “Mersenne Twister”[1] pseudo-random number generating algorithm.
        /// 
        /// Notes
        /// 
        /// set_state and get_state are not needed to work with any of the
        /// random distributions in NumPy. If the internal state is manually altered,
        /// the user should know exactly what he/she is doing.
        /// 
        /// For backwards compatibility, the form (str, array of 624 uints, int) is
        /// also accepted although it is missing some information about the cached
        /// Gaussian value: state = ('MT19937', keys, pos).
        /// 
        /// References
        /// </summary>
        /// <param name="state">
        /// The state tuple has the following items:
        /// </param>
        /// <returns>
        /// Returns ‘None’ on success.
        /// </returns>
        public None set_state(tuple(str state)
        {
            //auto-generated code, do not change
            var random = self.GetAttr("random");
            var __self__=random;
            var pyargs=ToTuple(new object[]
            {
                state,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("set_state", pyargs, kwargs);
            return ToCsharp<None>(py);
        }
        */
        
    }
}
