// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Python.Runtime;
using Python.Included;
using Numpy.Models;

namespace Numpy
{
    public partial class NDarray
    {
        
        /// <summary>
        /// Copy an element of an array to a standard Python scalar and return it.
        /// 
        /// Notes
        /// 
        /// When the data type of a is longdouble or clongdouble, item() returns
        /// a scalar array object because there is no available Python scalar that
        /// would not lose information. Void arrays return a buffer object for item(),
        /// unless fields are defined, in which case a tuple is returned.
        /// 
        /// item is very similar to a[args], except, instead of an array scalar,
        /// a standard Python scalar is returned. This can be useful for speeding up
        /// access to elements of the array and doing arithmetic on elements of the
        /// array using Python’s optimized math.
        /// </summary>
        /// <returns>
        /// A copy of the specified element of the array as a suitable
        /// Python scalar
        /// </returns>
        public T item<T>(params int[] args)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                args,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("item", pyargs, kwargs);
            return ToCsharp<T>(py);
        }
        
        /// <summary>
        /// Return the array as a (possibly nested) list.
        /// 
        /// Return a copy of the array data as a (nested) Python list.
        /// Data items are converted to the nearest compatible Python type.
        /// 
        /// Notes
        /// 
        /// The array may be recreated, a = np.array(a.tolist()).
        /// </summary>
        /// <returns>
        /// The possibly nested list of array elements.
        /// </returns>
        public List<T> tolist<T>()
        {
            //auto-generated code, do not change
            var __self__=self;
            dynamic py = __self__.InvokeMethod("tolist");
            return ToCsharp<List<T>>(py);
        }
        
        /// <summary>
        /// Write array to a file as text or binary (default).
        /// 
        /// Data is always written in ‘C’ order, independent of the order of a.
        /// The data produced by this method can be recovered using the function
        /// fromfile().
        /// 
        /// Notes
        /// 
        /// This is a convenience function for quick storage of array data.
        /// Information on endianness and precision is lost, so this method is not a
        /// good choice for files intended to archive data or transport data between
        /// machines with different endianness. Some of these problems can be overcome
        /// by outputting the data as text files, at the expense of speed and file
        /// size.
        /// 
        /// When fid is a file object, array contents are directly written to the
        /// file, bypassing the file object’s write method. As a result, tofile
        /// cannot be used with files objects supporting compression (e.g., GzipFile)
        /// or file-like objects that do not support fileno() (e.g., BytesIO).
        /// </summary>
        /// <param name="fid">
        /// An open file object, or a string containing a filename.
        /// </param>
        /// <param name="sep">
        /// Separator between array items for text output.
        /// If “” (empty), a binary file is written, equivalent to
        /// file.write(a.tobytes()).
        /// </param>
        /// <param name="format">
        /// Format string for text file output.
        /// Each entry in the array is formatted to text by first converting
        /// it to the closest Python type, and then using “format” % item.
        /// </param>
        public void tofile(string fid, string sep, string format)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                fid,
                sep,
                format,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("tofile", pyargs, kwargs);
        }
        
        /// <summary>
        /// Dump a pickle of the array to the specified file.
        /// The array can be read back with pickle.load or numpy.load.
        /// </summary>
        /// <param name="file">
        /// A string naming the dump file.
        /// </param>
        public void dump(string file)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                file,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("dump", pyargs, kwargs);
        }
        
        /// <summary>
        /// Returns the pickle of the array as a string.
        /// pickle.loads or numpy.loads will convert the string back to an array.
        /// </summary>
        public void dumps()
        {
            //auto-generated code, do not change
            var __self__=self;
            dynamic py = __self__.InvokeMethod("dumps");
        }
        
        /// <summary>
        /// Copy of the array, cast to a specified type.
        /// 
        /// Notes
        /// 
        /// Starting in NumPy 1.9, astype method now returns an error if the string
        /// dtype to cast to is not long enough in ‘safe’ casting mode to hold the max
        /// value of integer/float array that is being casted. Previously the casting
        /// was allowed even if the result was truncated.
        /// </summary>
        /// <param name="dtype">
        /// Typecode or data-type to which the array is cast.
        /// </param>
        /// <param name="order">
        /// Controls the memory layout order of the result.
        /// ‘C’ means C order, ‘F’ means Fortran order, ‘A’
        /// means ‘F’ order if all the arrays are Fortran contiguous,
        /// ‘C’ order otherwise, and ‘K’ means as close to the
        /// order the array elements appear in memory as possible.
        /// Default is ‘K’.
        /// </param>
        /// <param name="casting">
        /// Controls what kind of data casting may occur. Defaults to ‘unsafe’
        /// for backwards compatibility.
        /// </param>
        /// <param name="subok">
        /// If True, then sub-classes will be passed-through (default), otherwise
        /// the returned array will be forced to be a base-class array.
        /// </param>
        /// <param name="copy">
        /// By default, astype always returns a newly allocated array. If this
        /// is set to false, and the dtype, order, and subok
        /// requirements are satisfied, the input array is returned instead
        /// of a copy.
        /// </param>
        /// <returns>
        /// Unless copy is False and the other conditions for returning the input
        /// array are satisfied (see description for copy input parameter), arr_t
        /// is a new array of the same shape as the input array, with dtype, order
        /// given by dtype, order.
        /// </returns>
        public NDarray astype(Dtype dtype, string order = null, string casting = null, bool? subok = null, bool? copy = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                dtype,
            });
            var kwargs=new PyDict();
            if (order!=null) kwargs["order"]=ToPython(order);
            if (casting!=null) kwargs["casting"]=ToPython(casting);
            if (subok!=null) kwargs["subok"]=ToPython(subok);
            if (copy!=null) kwargs["copy"]=ToPython(copy);
            dynamic py = __self__.InvokeMethod("astype", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Swap the bytes of the array elements
        /// 
        /// Toggle between low-endian and big-endian data representation by
        /// returning a byteswapped array, optionally swapped in-place.
        /// </summary>
        /// <param name="inplace">
        /// If True, swap bytes in-place, default is False.
        /// </param>
        /// <returns>
        /// The byteswapped array. If inplace is True, this is
        /// a view to self.
        /// </returns>
        public NDarray byteswap(bool? inplace = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (inplace!=null) kwargs["inplace"]=ToPython(inplace);
            dynamic py = __self__.InvokeMethod("byteswap", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Return a copy of the array.
        /// </summary>
        /// <param name="order">
        /// Controls the memory layout of the copy. ‘C’ means C-order,
        /// ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous,
        /// ‘C’ otherwise. ‘K’ means match the layout of a as closely
        /// as possible. (Note that this function and numpy.copy are very
        /// similar, but have different default values for their order=
        /// arguments.)
        /// </param>
        public void copy(string order = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (order!=null) kwargs["order"]=ToPython(order);
            dynamic py = __self__.InvokeMethod("copy", pyargs, kwargs);
        }
        
        /// <summary>
        /// Returns a field of the given array as a certain type.
        /// 
        /// A field is a view of the array data with a given data-type. The values in
        /// the view are determined by the given type and the offset into the current
        /// array in bytes. The offset needs to be such that the view dtype fits in the
        /// array dtype; for example an array of dtype complex128 has 16-byte elements.
        /// If taking a view with a 32-bit integer (4 bytes), the offset needs to be
        /// between 0 and 12 bytes.
        /// </summary>
        /// <param name="dtype">
        /// The data type of the view. The dtype size of the view can not be larger
        /// than that of the array itself.
        /// </param>
        /// <param name="offset">
        /// Number of bytes to skip before beginning the element view.
        /// </param>
        public void getfield(Dtype dtype, int offset)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                dtype,
                offset,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("getfield", pyargs, kwargs);
        }
        
        /// <summary>
        /// Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),
        /// respectively.
        /// 
        /// These Boolean-valued flags affect how numpy interprets the memory
        /// area used by a (see Notes below). The ALIGNED flag can only
        /// be set to True if the data is actually aligned according to the type.
        /// The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set
        /// to True. The flag WRITEABLE can only be set to True if the array owns its
        /// own memory, or the ultimate owner of the memory exposes a writeable buffer
        /// interface, or is a string. (The exception for string is made so that
        /// unpickling can be done without copying memory.)
        /// 
        /// Notes
        /// 
        /// Array flags provide information about how the memory area used
        /// for the array is to be interpreted. There are 7 Boolean flags
        /// in use, only four of which can be changed by the user:
        /// WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.
        /// 
        /// WRITEABLE (W) the data area can be written to;
        /// 
        /// ALIGNED (A) the data and strides are aligned appropriately for the hardware
        /// (as determined by the compiler);
        /// 
        /// UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;
        /// 
        /// WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced
        /// by .base). When the C-API function PyArray_ResolveWritebackIfCopy is
        /// called, the base array will be updated with the contents of this array.
        /// 
        /// All flags can be accessed using the single (upper case) letter as well
        /// as the full name.
        /// </summary>
        /// <param name="write">
        /// Describes whether or not a can be written to.
        /// </param>
        /// <param name="align">
        /// Describes whether or not a is aligned properly for its type.
        /// </param>
        /// <param name="uic">
        /// Describes whether or not a is a copy of another “base” array.
        /// </param>
        public void setflags(bool? write = null, bool? align = null, bool? uic = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (write!=null) kwargs["write"]=ToPython(write);
            if (align!=null) kwargs["align"]=ToPython(align);
            if (uic!=null) kwargs["uic"]=ToPython(uic);
            dynamic py = __self__.InvokeMethod("setflags", pyargs, kwargs);
        }
        
        /// <summary>
        /// Fill the array with a scalar value.
        /// </summary>
        /// <param name="@value">
        /// All elements of a will be assigned this value.
        /// </param>
        public void fill(ValueType @value)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                @value,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("fill", pyargs, kwargs);
        }
        
        /// <summary>
        /// Returns a view of the array with axes transposed.
        /// 
        /// For a 1-D array, this has no effect. (To change between column and
        /// row vectors, first cast the 1-D array into a matrix object.)
        /// For a 2-D array, this is the usual matrix transpose.
        /// For an n-D array, if axes are given, their order indicates how the
        /// axes are permuted (see Examples). If axes are not provided and
        /// a.shape = (i[0], i[1], ... i[n-2], i[n-1]), then
        /// a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0]).
        /// </summary>
        /// <returns>
        /// View of a, with axes suitably permuted.
        /// </returns>
        public NDarray transpose(int[] axes = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                axes,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("transpose", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Return a copy of the array collapsed into one dimension.
        /// </summary>
        /// <param name="order">
        /// ‘C’ means to flatten in row-major (C-style) order.
        /// ‘F’ means to flatten in column-major (Fortran-
        /// style) order. ‘A’ means to flatten in column-major
        /// order if a is Fortran contiguous in memory,
        /// row-major order otherwise. ‘K’ means to flatten
        /// a in the order the elements occur in memory.
        /// The default is ‘C’.
        /// </param>
        /// <returns>
        /// A copy of the input array, flattened to one dimension.
        /// </returns>
        public NDarray flatten(string order = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (order!=null) kwargs["order"]=ToPython(order);
            dynamic py = __self__.InvokeMethod("flatten", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// For unpickling.
        /// 
        /// The state argument must be a sequence that contains the following
        /// elements:
        /// </summary>
        /// <param name="version">
        /// optional pickle version. If omitted defaults to 0.
        /// </param>
        /// <param name="rawdata">
        /// a binary string with the data (or a list if ‘a’ is an object array)
        /// </param>
        public void __setstate__(int version, Shape shape, Dtype dtype, bool isFortran, string rawdata)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                version,
                shape,
                dtype,
                isFortran,
                rawdata,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("__setstate__", pyargs, kwargs);
        }
        
        /// <summary>
        /// Gives a new shape to an array without changing its data.
        /// 
        /// Notes
        /// 
        /// It is not always possible to change the shape of an array without
        /// copying the data. If you want an error to be raised when the data is copied,
        /// you should assign the new shape to the shape attribute of the array:
        /// 
        /// The order keyword gives the index ordering both for fetching the values
        /// from a, and then placing the values into the output array.
        /// For example, let’s say you have an array:
        /// 
        /// You can think of reshaping as first raveling the array (using the given
        /// index order), then inserting the elements from the raveled array into the
        /// new array using the same kind of index ordering as was used for the
        /// raveling.
        /// </summary>
        /// <param name="newshape">
        /// The new shape should be compatible with the original shape. If
        /// an integer, then the result will be a 1-D array of that length.
        /// One shape dimension can be -1. In this case, the value is
        /// inferred from the length of the array and remaining dimensions.
        /// </param>
        /// <param name="order">
        /// Read the elements of a using this index order, and place the
        /// elements into the reshaped array using this index order.  ‘C’
        /// means to read / write the elements using C-like index order,
        /// with the last axis index changing fastest, back to the first
        /// axis index changing slowest. ‘F’ means to read / write the
        /// elements using Fortran-like index order, with the first index
        /// changing fastest, and the last index changing slowest. Note that
        /// the ‘C’ and ‘F’ options take no account of the memory layout of
        /// the underlying array, and only refer to the order of indexing.
        /// ‘A’ means to read / write the elements in Fortran-like index
        /// order if a is Fortran contiguous in memory, C-like order
        /// otherwise.
        /// </param>
        /// <returns>
        /// This will be a new view object if possible; otherwise, it will
        /// be a copy.  Note there is no guarantee of the memory layout (C- or
        /// Fortran- contiguous) of the returned array.
        /// </returns>
        public NDarray reshape(Shape newshape, string order = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.reshape(@this, newshape, order:order);
        }
        
        /// <summary>
        /// Return a contiguous flattened array.
        /// 
        /// A 1-D array, containing the elements of the input, is returned.  A copy is
        /// made only if needed.
        /// 
        /// As of NumPy 1.10, the returned array will have the same type as the input
        /// array. (for example, a masked array will be returned for a masked array
        /// input)
        /// 
        /// Notes
        /// 
        /// In row-major, C-style order, in two dimensions, the row index
        /// varies the slowest, and the column index the quickest.  This can
        /// be generalized to multiple dimensions, where row-major order
        /// implies that the index along the first axis varies slowest, and
        /// the index along the last quickest.  The opposite holds for
        /// column-major, Fortran-style index ordering.
        /// 
        /// When a view is desired in as many cases as possible, arr.reshape(-1)
        /// may be preferable.
        /// </summary>
        /// <param name="order">
        /// The elements of a are read using this index order. ‘C’ means
        /// to index the elements in row-major, C-style order,
        /// with the last axis index changing fastest, back to the first
        /// axis index changing slowest.  ‘F’ means to index the elements
        /// in column-major, Fortran-style order, with the
        /// first index changing fastest, and the last index changing
        /// slowest. Note that the ‘C’ and ‘F’ options take no account of
        /// the memory layout of the underlying array, and only refer to
        /// the order of axis indexing.  ‘A’ means to read the elements in
        /// Fortran-like index order if a is Fortran contiguous in
        /// memory, C-like order otherwise.  ‘K’ means to read the
        /// elements in the order they occur in memory, except for
        /// reversing the data when strides are negative.  By default, ‘C’
        /// index order is used.
        /// </param>
        /// <returns>
        /// y is an array of the same subtype as a, with shape (a.size,).
        /// Note that matrices are special cased for backward compatibility, if a
        /// is a matrix, then y is a 1-D ndarray.
        /// </returns>
        public NDarray ravel(string order = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.ravel(@this, order:order);
        }
        
        /// <summary>
        /// Move axes of an array to new positions.
        /// 
        /// Other axes remain in their original order.
        /// </summary>
        /// <param name="source">
        /// Original positions of the axes to move. These must be unique.
        /// </param>
        /// <param name="destination">
        /// Destination positions for each of the original axes. These must also be
        /// unique.
        /// </param>
        /// <returns>
        /// Array with moved axes. This array is a view of the input array.
        /// </returns>
        public NDarray moveaxis(int[] source, int[] destination)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.moveaxis(@this, source, destination);
        }
        
        /// <summary>
        /// Roll the specified axis backwards, until it lies in a given position.
        /// 
        /// This function continues to be supported for backward compatibility, but you
        /// should prefer moveaxis. The moveaxis function was added in NumPy
        /// 1.11.
        /// </summary>
        /// <param name="axis">
        /// The axis to roll backwards.  The positions of the other axes do not
        /// change relative to one another.
        /// </param>
        /// <param name="start">
        /// The axis is rolled until it lies before this position.  The default,
        /// 0, results in a “complete” roll.
        /// </param>
        /// <returns>
        /// For NumPy &gt;= 1.10.0 a view of a is always returned. For earlier
        /// NumPy versions a view of a is returned only if the order of the
        /// axes is changed, otherwise the input array is returned.
        /// </returns>
        public NDarray rollaxis(int axis, int? start = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.rollaxis(@this, axis, start:start);
        }
        
        /// <summary>
        /// Interchange two axes of an array.
        /// </summary>
        /// <param name="axis1">
        /// First axis.
        /// </param>
        /// <param name="axis2">
        /// Second axis.
        /// </param>
        /// <returns>
        /// For NumPy &gt;= 1.10.0, if a is an ndarray, then a view of a is
        /// returned; otherwise a new array is created. For earlier NumPy
        /// versions a view of a is returned only if the order of the
        /// axes is changed, otherwise the input array is returned.
        /// </returns>
        public NDarray swapaxes(int axis1, int axis2)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.swapaxes(@this, axis1, axis2);
        }
        
        /// <summary>
        /// Broadcast an array to a new shape.
        /// 
        /// Notes
        /// </summary>
        /// <param name="shape">
        /// The shape of the desired array.
        /// </param>
        /// <param name="subok">
        /// If True, then sub-classes will be passed-through, otherwise
        /// the returned array will be forced to be a base-class array (default).
        /// </param>
        /// <returns>
        /// A readonly view on the original array with the given shape. It is
        /// typically not contiguous. Furthermore, more than one element of a
        /// broadcasted array may refer to a single memory location.
        /// </returns>
        public NDarray broadcast_to(Shape shape, bool? subok = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.broadcast_to(@this, shape, subok:subok);
        }
        
        /// <summary>
        /// Expand the shape of an array.
        /// 
        /// Insert a new axis that will appear at the axis position in the expanded
        /// array shape.
        /// </summary>
        /// <param name="axis">
        /// Position in the expanded axes where the new axis is placed.
        /// </param>
        /// <returns>
        /// Output array. The number of dimensions is one greater than that of
        /// the input array.
        /// </returns>
        public NDarray expand_dims(int axis)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.expand_dims(@this, axis);
        }
        
        /// <summary>
        /// Remove single-dimensional entries from the shape of an array.
        /// </summary>
        /// <param name="axis">
        /// Selects a subset of the single-dimensional entries in the
        /// shape. If an axis is selected with shape entry greater than
        /// one, an error is raised.
        /// </param>
        /// <returns>
        /// The input array, but with all or a subset of the
        /// dimensions of length 1 removed. This is always a itself
        /// or a view into a.
        /// </returns>
        public NDarray squeeze(int[] axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.squeeze(@this, axis:axis);
        }
        
        /// <summary>
        /// Return an array converted to a float type.
        /// </summary>
        /// <param name="dtype">
        /// Float type code to coerce input array a.  If dtype is one of the
        /// ‘int’ dtypes, it is replaced with float64.
        /// </param>
        /// <returns>
        /// The input a as a float ndarray.
        /// </returns>
        public NDarray asfarray(Dtype dtype = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.asfarray(@this, dtype:dtype);
        }
        
        /// <summary>
        /// Return an array (ndim &gt;= 1) laid out in Fortran order in memory.
        /// </summary>
        /// <param name="dtype">
        /// By default, the data-type is inferred from the input data.
        /// </param>
        /// <returns>
        /// The input a in Fortran, or column-major, order.
        /// </returns>
        public NDarray asfortranarray(Dtype dtype = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.asfortranarray(@this, dtype:dtype);
        }
        
        /// <summary>
        /// Convert the input to an array, checking for NaNs or Infs.
        /// </summary>
        /// <param name="dtype">
        /// By default, the data-type is inferred from the input data.
        /// </param>
        /// <param name="order">
        /// Whether to use row-major (C-style) or
        /// column-major (Fortran-style) memory representation.
        /// Defaults to ‘C’.
        /// </param>
        /// <returns>
        /// Array interpretation of a.  No copy is performed if the input
        /// is already an ndarray.  If a is a subclass of ndarray, a base
        /// class ndarray is returned.
        /// </returns>
        public NDarray asarray_chkfinite(Dtype dtype = null, string order = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.asarray_chkfinite(@this, dtype:dtype, order:order);
        }
        
        /// <summary>
        /// Return an ndarray of the provided type that satisfies requirements.
        /// 
        /// This function is useful to be sure that an array with the correct flags
        /// is returned for passing to compiled code (perhaps through ctypes).
        /// 
        /// Notes
        /// 
        /// The returned array will be guaranteed to have the listed requirements
        /// by making a copy if needed.
        /// </summary>
        /// <param name="dtype">
        /// The required data-type. If None preserve the current dtype. If your
        /// application requires the data to be in native byteorder, include
        /// a byteorder specification as a part of the dtype specification.
        /// </param>
        /// <param name="requirements">
        /// The requirements list can be any of the following
        /// </param>
        public NDarray require(Dtype dtype, string[] requirements)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.require(@this, dtype, requirements);
        }
        
        /// <summary>
        /// Split an array into multiple sub-arrays.
        /// </summary>
        /// <param name="indices_or_sections">
        /// If indices_or_sections is an integer, N, the array will be divided
        /// into N equal arrays along axis.  If such a split is not possible,
        /// an error is raised.
        /// 
        /// If indices_or_sections is a 1-D array of sorted integers, the entries
        /// indicate where along axis the array is split.  For example,
        /// [2, 3] would, for axis=0, result in
        /// 
        /// If an index exceeds the dimension of the array along axis,
        /// an empty sub-array is returned correspondingly.
        /// </param>
        /// <param name="axis">
        /// The axis along which to split, default is 0.
        /// </param>
        /// <returns>
        /// A list of sub-arrays.
        /// </returns>
        public NDarray[] split(int[] indices_or_sections, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.split(@this, indices_or_sections, axis:axis);
        }
        
        /// <summary>
        /// Construct an array by repeating A the number of times given by reps.
        /// 
        /// If reps has length d, the result will have dimension of
        /// max(d, A.ndim).
        /// 
        /// If A.ndim &lt; d, A is promoted to be d-dimensional by prepending new
        /// axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,
        /// or shape (1, 1, 3) for 3-D replication. If this is not the desired
        /// behavior, promote A to d-dimensions manually before calling this
        /// function.
        /// 
        /// If A.ndim &gt; d, reps is promoted to A.ndim by pre-pending 1’s to it.
        /// Thus for an A of shape (2, 3, 4, 5), a reps of (2, 2) is treated as
        /// (1, 1, 2, 2).
        /// 
        /// Note : Although tile may be used for broadcasting, it is strongly
        /// recommended to use numpy’s broadcasting operations and functions.
        /// </summary>
        /// <param name="reps">
        /// The number of repetitions of A along each axis.
        /// </param>
        /// <returns>
        /// The tiled output array.
        /// </returns>
        public NDarray tile(NDarray reps)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.tile(@this, reps);
        }
        
        /// <summary>
        /// Repeat elements of an array.
        /// </summary>
        /// <param name="repeats">
        /// The number of repetitions for each element.  repeats is broadcasted
        /// to fit the shape of the given axis.
        /// </param>
        /// <param name="axis">
        /// The axis along which to repeat values.  By default, use the
        /// flattened input array, and return a flat output array.
        /// </param>
        /// <returns>
        /// Output array which has the same shape as a, except along
        /// the given axis.
        /// </returns>
        public NDarray repeat(int[] repeats, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.repeat(@this, repeats, axis:axis);
        }
        
        /// <summary>
        /// Return a new array with sub-arrays along an axis deleted. For a one
        /// dimensional array, this returns those entries not returned by
        /// arr[obj].
        /// 
        /// Notes
        /// 
        /// Often it is preferable to use a boolean mask. For example:
        /// 
        /// Is equivalent to np.delete(arr, [0,2,4], axis=0), but allows further
        /// use of mask.
        /// </summary>
        /// <param name="obj">
        /// Indicate which sub-arrays to remove.
        /// </param>
        /// <param name="axis">
        /// The axis along which to delete the subarray defined by obj.
        /// If axis is None, obj is applied to the flattened array.
        /// </param>
        /// <returns>
        /// A copy of arr with the elements specified by obj removed. Note
        /// that delete does not occur in-place. If axis is None, out is
        /// a flattened array.
        /// </returns>
        public NDarray delete(Slice obj, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.delete(@this, obj, axis:axis);
        }
        
        /// <summary>
        /// Insert values along the given axis before the given indices.
        /// 
        /// Notes
        /// 
        /// Note that for higher dimensional inserts obj=0 behaves very different
        /// from obj=[0] just like arr[:,0,:] = values is different from
        /// arr[:,[0],:] = values.
        /// </summary>
        /// <param name="obj">
        /// Object that defines the index or indices before which values is
        /// inserted.
        /// 
        /// Support for multiple insertions when obj is a single scalar or a
        /// sequence with one element (similar to calling insert multiple
        /// times).
        /// </param>
        /// <param name="values">
        /// Values to insert into arr. If the type of values is different
        /// from that of arr, values is converted to the type of arr.
        /// values should be shaped so that arr[...,obj,...] = values
        /// is legal.
        /// </param>
        /// <param name="axis">
        /// Axis along which to insert values.  If axis is None then arr
        /// is flattened first.
        /// </param>
        /// <returns>
        /// A copy of arr with values inserted.  Note that insert
        /// does not occur in-place: a new array is returned. If
        /// axis is None, out is a flattened array.
        /// </returns>
        public NDarray insert(int obj, NDarray values, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.insert(@this, obj, values, axis:axis);
        }
        
        /// <summary>
        /// Append values to the end of an array.
        /// </summary>
        /// <param name="values">
        /// These values are appended to a copy of arr.  It must be of the
        /// correct shape (the same shape as arr, excluding axis).  If
        /// axis is not specified, values can be any shape and will be
        /// flattened before use.
        /// </param>
        /// <param name="axis">
        /// The axis along which values are appended.  If axis is not
        /// given, both arr and values are flattened before use.
        /// </param>
        /// <returns>
        /// A copy of arr with values appended to axis.  Note that
        /// append does not occur in-place: a new array is allocated and
        /// filled.  If axis is None, out is a flattened array.
        /// </returns>
        public NDarray append(NDarray values, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.append(@this, values, axis:axis);
        }
        
        /// <summary>
        /// Trim the leading and/or trailing zeros from a 1-D array or sequence.
        /// </summary>
        /// <param name="trim">
        /// A string with ‘f’ representing trim from front and ‘b’ to trim from
        /// back. Default is ‘fb’, trim zeros from both front and back of the
        /// array.
        /// </param>
        /// <returns>
        /// The result of trimming the input. The input data type is preserved.
        /// </returns>
        public NDarray trim_zeros(string trim = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.trim_zeros(@this, trim:trim);
        }
        
        /// <summary>
        /// Find the unique elements of an array.
        /// 
        /// Returns the sorted unique elements of an array. There are three optional
        /// outputs in addition to the unique elements:
        /// 
        /// Notes
        /// 
        /// When an axis is specified the subarrays indexed by the axis are sorted.
        /// This is done by making the specified axis the first dimension of the array
        /// and then flattening the subarrays in C order. The flattened subarrays are
        /// then viewed as a structured type with each element given a label, with the
        /// effect that we end up with a 1-D array of structured types that can be
        /// treated in the same way as any other 1-D array. The result is that the
        /// flattened subarrays are sorted in lexicographic order starting with the
        /// first element.
        /// </summary>
        /// <param name="return_index">
        /// If True, also return the indices of ar (along the specified axis,
        /// if provided, or in the flattened array) that result in the unique array.
        /// </param>
        /// <param name="return_inverse">
        /// If True, also return the indices of the unique array (for the specified
        /// axis, if provided) that can be used to reconstruct ar.
        /// </param>
        /// <param name="return_counts">
        /// If True, also return the number of times each unique item appears
        /// in ar.
        /// </param>
        /// <param name="axis">
        /// The axis to operate on. If None, ar will be flattened. If an integer,
        /// the subarrays indexed by the given axis will be flattened and treated
        /// as the elements of a 1-D array with the dimension of the given axis,
        /// see the notes for more details.  Object arrays or structured arrays
        /// that contain objects are not supported if the axis kwarg is used. The
        /// default is None.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// unique
        /// The sorted unique values.
        /// unique_indices
        /// The indices of the first occurrences of the unique values in the
        /// original array. Only provided if return_index is True.
        /// unique_inverse
        /// The indices to reconstruct the original array from the
        /// unique array. Only provided if return_inverse is True.
        /// unique_counts
        /// The number of times each of the unique values comes up in the
        /// original array. Only provided if return_counts is True.
        /// </returns>
        public (NDarray, NDarray, NDarray, NDarray) unique(bool? return_index = null, bool? return_inverse = null, bool? return_counts = null, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.unique(@this, return_index:return_index, return_inverse:return_inverse, return_counts:return_counts, axis:axis);
        }
        
        /// <summary>
        /// Reverse the order of elements in an array along the given axis.
        /// 
        /// The shape of the array is preserved, but the elements are reordered.
        /// 
        /// Notes
        /// 
        /// flip(m, 0) is equivalent to flipud(m).
        /// 
        /// flip(m, 1) is equivalent to fliplr(m).
        /// 
        /// flip(m, n) corresponds to m[...,::-1,...] with ::-1 at position n.
        /// 
        /// flip(m) corresponds to m[::-1,::-1,...,::-1] with ::-1 at all
        /// positions.
        /// 
        /// flip(m, (0, 1)) corresponds to m[::-1,::-1,...] with ::-1 at
        /// position 0 and position 1.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which to flip over. The default,
        /// axis=None, will flip over all of the axes of the input array.
        /// If axis is negative it counts from the last to the first axis.
        /// 
        /// If axis is a tuple of ints, flipping is performed on all of the axes
        /// specified in the tuple.
        /// </param>
        /// <returns>
        /// A view of m with the entries of axis reversed.  Since a view is
        /// returned, this operation is done in constant time.
        /// </returns>
        public NDarray flip(int[] axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.flip(@this, axis:axis);
        }
        
        /// <summary>
        /// Flip array in the left/right direction.
        /// 
        /// Flip the entries in each row in the left/right direction.
        /// Columns are preserved, but appear in a different order than before.
        /// 
        /// Notes
        /// 
        /// Equivalent to m[:,::-1]. Requires the array to be at least 2-D.
        /// </summary>
        /// <returns>
        /// A view of m with the columns reversed.  Since a view
        /// is returned, this operation is .
        /// </returns>
        public NDarray fliplr()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.fliplr(@this);
        }
        
        /// <summary>
        /// Flip array in the up/down direction.
        /// 
        /// Flip the entries in each column in the up/down direction.
        /// Rows are preserved, but appear in a different order than before.
        /// 
        /// Notes
        /// 
        /// Equivalent to m[::-1,...].
        /// Does not require the array to be two-dimensional.
        /// </summary>
        /// <returns>
        /// A view of m with the rows reversed.  Since a view is
        /// returned, this operation is .
        /// </returns>
        public NDarray flipud()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.flipud(@this);
        }
        
        /// <summary>
        /// Roll array elements along a given axis.
        /// 
        /// Elements that roll beyond the last position are re-introduced at
        /// the first.
        /// 
        /// Notes
        /// 
        /// Supports rolling over multiple dimensions simultaneously.
        /// </summary>
        /// <param name="shift">
        /// The number of places by which elements are shifted.  If a tuple,
        /// then axis must be a tuple of the same size, and each of the
        /// given axes is shifted by the corresponding number.  If an int
        /// while axis is a tuple of ints, then the same value is used for
        /// all given axes.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which elements are shifted.  By default, the
        /// array is flattened before shifting, after which the original
        /// shape is restored.
        /// </param>
        /// <returns>
        /// Output array, with the same shape as a.
        /// </returns>
        public NDarray roll(int[] shift, int[] axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.roll(@this, shift, axis:axis);
        }
        
        /// <summary>
        /// Rotate an array by 90 degrees in the plane specified by axes.
        /// 
        /// Rotation direction is from the first towards the second axis.
        /// 
        /// Notes
        /// 
        /// rot90(m, k=1, axes=(1,0)) is the reverse of rot90(m, k=1, axes=(0,1))
        /// rot90(m, k=1, axes=(1,0)) is equivalent to rot90(m, k=-1, axes=(0,1))
        /// </summary>
        /// <param name="k">
        /// Number of times the array is rotated by 90 degrees.
        /// </param>
        /// <param name="axes">
        /// The array is rotated in the plane defined by the axes.
        /// Axes must be different.
        /// </param>
        /// <returns>
        /// A rotated view of m.
        /// </returns>
        public NDarray rot90(int k, int[] axes = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.rot90(@this, k, axes);
        }
        
        /// <summary>
        /// Packs the elements of a binary-valued array into bits in a uint8 array.
        /// 
        /// The result is padded to full bytes by inserting zero bits at the end.
        /// </summary>
        /// <param name="axis">
        /// The dimension over which bit-packing is done.
        /// None implies packing the flattened array.
        /// </param>
        /// <returns>
        /// Array of type uint8 whose elements represent bits corresponding to the
        /// logical (0 or nonzero) value of the input elements. The shape of
        /// packed has the same number of dimensions as the input (unless axis
        /// is None, in which case the output is 1-D).
        /// </returns>
        public NDarray packbits(int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.packbits(@this, axis:axis);
        }
        
        /// <summary>
        /// Unpacks elements of a uint8 array into a binary-valued output array.
        /// 
        /// Each element of myarray represents a bit-field that should be unpacked
        /// into a binary-valued output array. The shape of the output array is either
        /// 1-D (if axis is None) or the same shape as the input array with unpacking
        /// done along the axis specified.
        /// </summary>
        /// <param name="axis">
        /// The dimension over which bit-unpacking is done.
        /// None implies unpacking the flattened array.
        /// </param>
        /// <returns>
        /// The elements are binary-valued (0 or 1).
        /// </returns>
        public NDarray unpackbits(int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.unpackbits(@this, axis:axis);
        }
        
        /// <summary>
        /// Cholesky decomposition.
        /// 
        /// Return the Cholesky decomposition, L * L.H, of the square matrix a,
        /// where L is lower-triangular and .H is the conjugate transpose operator
        /// (which is the ordinary transpose if a is real-valued).  a must be
        /// Hermitian (symmetric if real-valued) and positive-definite.  Only L is
        /// actually returned.
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// The Cholesky decomposition is often used as a fast way of solving
        /// 
        /// (when A is both Hermitian/symmetric and positive-definite).
        /// 
        /// First, we solve for  in
        /// 
        /// and then for  in
        /// </summary>
        /// <returns>
        /// Upper or lower-triangular Cholesky factor of a.  Returns a
        /// matrix object if a is a matrix object.
        /// </returns>
        public NDarray cholesky()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.cholesky(@this);
        }
        
        /// <summary>
        /// Compute the determinant of an array.
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// The determinant is computed via LU factorization using the LAPACK
        /// routine z/dgetrf.
        /// </summary>
        /// <returns>
        /// Determinant of a.
        /// </returns>
        public NDarray det()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.det(@this);
        }
        
        /// <summary>
        /// Compute the eigenvalues and right eigenvectors of a square array.
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// This is implemented using the _geev LAPACK routines which compute
        /// the eigenvalues and eigenvectors of general square arrays.
        /// 
        /// The number w is an eigenvalue of a if there exists a vector
        /// v such that dot(a,v) = w * v. Thus, the arrays a, w, and
        /// v satisfy the equations dot(a[:,:], v[:,i]) = w[i] * v[:,i]
        /// for .
        /// 
        /// The array v of eigenvectors may not be of maximum rank, that is, some
        /// of the columns may be linearly dependent, although round-off error may
        /// obscure that fact. If the eigenvalues are all different, then theoretically
        /// the eigenvectors are linearly independent. Likewise, the (complex-valued)
        /// matrix of eigenvectors v is unitary if the matrix a is normal, i.e.,
        /// if dot(a, a.H) = dot(a.H, a), where a.H denotes the conjugate
        /// transpose of a.
        /// 
        /// Finally, it is emphasized that v consists of the right (as in
        /// right-hand side) eigenvectors of a.  A vector y satisfying
        /// dot(y.T, a) = z * y.T for some number z is called a left
        /// eigenvector of a, and, in general, the left and right eigenvectors
        /// of a matrix are not necessarily the (perhaps conjugate) transposes
        /// of each other.
        /// 
        /// References
        /// 
        /// G. Strang, Linear Algebra and Its Applications, 2nd Ed., Orlando, FL,
        /// Academic Press, Inc., 1980, Various pp.
        /// </summary>
        /// <returns>
        /// A tuple of:
        /// w
        /// The eigenvalues, each repeated according to its multiplicity.
        /// The eigenvalues are not necessarily ordered. The resulting
        /// array will be of complex type, unless the imaginary part is
        /// zero in which case it will be cast to a real type. When a
        /// is real the resulting eigenvalues will be real (0 imaginary
        /// part) or occur in conjugate pairs
        /// v
        /// The normalized (unit “length”) eigenvectors, such that the
        /// column v[:,i] is the eigenvector corresponding to the
        /// eigenvalue w[i].
        /// </returns>
        public (NDarray, NDarray) eig()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.eig(@this);
        }
        
        /// <summary>
        /// Return the eigenvalues and eigenvectors of a complex Hermitian
        /// (conjugate symmetric) or a real symmetric matrix.
        /// 
        /// Returns two objects, a 1-D array containing the eigenvalues of a, and
        /// a 2-D square array or matrix (depending on the input type) of the
        /// corresponding eigenvectors (in columns).
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// The eigenvalues/eigenvectors are computed using LAPACK routines _syevd,
        /// _heevd
        /// 
        /// The eigenvalues of real symmetric or complex Hermitian matrices are
        /// always real. [1] The array v of (column) eigenvectors is unitary
        /// and a, w, and v satisfy the equations
        /// dot(a, v[:, i]) = w[i] * v[:, i].
        /// 
        /// References
        /// </summary>
        /// <param name="UPLO">
        /// Specifies whether the calculation is done with the lower triangular
        /// part of a (‘L’, default) or the upper triangular part (‘U’).
        /// Irrespective of this value only the real parts of the diagonal will
        /// be considered in the computation to preserve the notion of a Hermitian
        /// matrix. It therefore follows that the imaginary part of the diagonal
        /// will always be treated as zero.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// w
        /// The eigenvalues in ascending order, each repeated according to
        /// its multiplicity.
        /// v
        /// The column v[:, i] is the normalized eigenvector corresponding
        /// to the eigenvalue w[i].  Will return a matrix object if a is
        /// a matrix object.
        /// </returns>
        public (NDarray, NDarray) eigh(string UPLO = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.eigh(@this, UPLO:UPLO);
        }
        
        /// <summary>
        /// Compute the eigenvalues of a general matrix.
        /// 
        /// Main difference between eigvals and eig: the eigenvectors aren’t
        /// returned.
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// This is implemented using the _geev LAPACK routines which compute
        /// the eigenvalues and eigenvectors of general square arrays.
        /// </summary>
        /// <returns>
        /// The eigenvalues, each repeated according to its multiplicity.
        /// They are not necessarily ordered, nor are they necessarily
        /// real for real matrices.
        /// </returns>
        public NDarray eigvals()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.eigvals(@this);
        }
        
        /// <summary>
        /// Compute the eigenvalues of a complex Hermitian or real symmetric matrix.
        /// 
        /// Main difference from eigh: the eigenvectors are not computed.
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// The eigenvalues are computed using LAPACK routines _syevd, _heevd
        /// </summary>
        /// <param name="UPLO">
        /// Specifies whether the calculation is done with the lower triangular
        /// part of a (‘L’, default) or the upper triangular part (‘U’).
        /// Irrespective of this value only the real parts of the diagonal will
        /// be considered in the computation to preserve the notion of a Hermitian
        /// matrix. It therefore follows that the imaginary part of the diagonal
        /// will always be treated as zero.
        /// </param>
        /// <returns>
        /// The eigenvalues in ascending order, each repeated according to
        /// its multiplicity.
        /// </returns>
        public NDarray eigvalsh(string UPLO = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.eigvalsh(@this, UPLO:UPLO);
        }
        
        /// <summary>
        /// Compute the (multiplicative) inverse of a matrix.
        /// 
        /// Given a square matrix a, return the matrix ainv satisfying
        /// dot(a, ainv) = dot(ainv, a) = eye(a.shape[0]).
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// </summary>
        /// <returns>
        /// (Multiplicative) inverse of the matrix a.
        /// </returns>
        public NDarray inv()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.inv(@this);
        }
        
        /// <summary>
        /// Return the least-squares solution to a linear matrix equation.
        /// 
        /// Solves the equation a x = b by computing a vector x that
        /// minimizes the Euclidean 2-norm || b - a x ||^2.  The equation may
        /// be under-, well-, or over- determined (i.e., the number of
        /// linearly independent rows of a can be less than, equal to, or
        /// greater than its number of linearly independent columns).  If a
        /// is square and of full rank, then x (but for round-off error) is
        /// the “exact” solution of the equation.
        /// 
        /// Notes
        /// 
        /// If b is a matrix, then all array results are returned as matrices.
        /// </summary>
        /// <param name="b">
        /// Ordinate or “dependent variable” values. If b is two-dimensional,
        /// the least-squares solution is calculated for each of the K columns
        /// of b.
        /// </param>
        /// <param name="rcond">
        /// Cut-off ratio for small singular values of a.
        /// For the purposes of rank determination, singular values are treated
        /// as zero if they are smaller than rcond times the largest singular
        /// value of a.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// x
        /// Least-squares solution. If b is two-dimensional,
        /// the solutions are in the K columns of x.
        /// residuals
        /// Sums of residuals; squared Euclidean 2-norm for each column in
        /// b - a*x.
        /// If the rank of a is &lt; N or M &lt;= N, this is an empty array.
        /// If b is 1-dimensional, this is a (1,) shape array.
        /// Otherwise the shape is (K,).
        /// rank
        /// Rank of matrix a.
        /// s
        /// Singular values of a.
        /// </returns>
        public (NDarray, NDarray, int, NDarray) lstsq(NDarray b, float? rcond = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.lstsq(@this, b, rcond:rcond);
        }
        
        /// <summary>
        /// Compute the (Moore-Penrose) pseudo-inverse of a matrix.
        /// 
        /// Calculate the generalized inverse of a matrix using its
        /// singular-value decomposition (SVD) and including all
        /// large singular values.
        /// 
        /// Notes
        /// 
        /// The pseudo-inverse of a matrix A, denoted , is
        /// defined as: “the matrix that ‘solves’ [the least-squares problem]
        /// ,” i.e., if  is said solution, then
        ///  is that matrix such that .
        /// 
        /// It can be shown that if  is the singular
        /// value decomposition of A, then
        /// , where  are
        /// orthogonal matrices,  is a diagonal matrix consisting
        /// of A’s so-called singular values, (followed, typically, by
        /// zeros), and then  is simply the diagonal matrix
        /// consisting of the reciprocals of A’s singular values
        /// (again, followed by zeros). [1]
        /// 
        /// References
        /// </summary>
        /// <param name="rcond">
        /// Cutoff for small singular values.
        /// Singular values smaller (in modulus) than
        /// rcond * largest_singular_value (again, in modulus)
        /// are set to zero. Broadcasts against the stack of matrices
        /// </param>
        /// <returns>
        /// The pseudo-inverse of a. If a is a matrix instance, then so
        /// is B.
        /// </returns>
        public NDarray pinv(NDarray rcond)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.pinv(@this, rcond);
        }
        
        /// <summary>
        /// Solve a linear matrix equation, or system of linear scalar equations.
        /// 
        /// Computes the “exact” solution, x, of the well-determined, i.e., full
        /// rank, linear matrix equation ax = b.
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// The solutions are computed using LAPACK routine _gesv
        /// 
        /// a must be square and of full-rank, i.e., all rows (or, equivalently,
        /// columns) must be linearly independent; if either is not true, use
        /// lstsq for the least-squares best “solution” of the
        /// system/equation.
        /// 
        /// References
        /// </summary>
        /// <param name="b">
        /// Ordinate or “dependent variable” values.
        /// </param>
        /// <returns>
        /// Solution to the system a x = b.  Returned shape is identical to b.
        /// </returns>
        public NDarray solve(NDarray b)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.solve(@this, b);
        }
        
        /// <summary>
        /// Singular Value Decomposition.
        /// 
        /// When a is a 2D array, it is factorized as u &#64; np.diag(s) &#64; vh
        /// = (u * s) &#64; vh, where u and vh are 2D unitary arrays and s is a 1D
        /// array of a’s singular values. When a is higher-dimensional, SVD is
        /// applied in stacked mode as explained below.
        /// 
        /// Notes
        /// 
        /// The decomposition is performed using LAPACK routine _gesdd.
        /// 
        /// SVD is usually described for the factorization of a 2D matrix .
        /// The higher-dimensional case will be discussed below. In the 2D case, SVD is
        /// written as , where , ,
        ///  and . The 1D array s
        /// contains the singular values of a and u and vh are unitary. The rows
        /// of vh are the eigenvectors of  and the columns of u are
        /// the eigenvectors of . In both cases the corresponding
        /// (possibly non-zero) eigenvalues are given by s**2.
        /// 
        /// If a has more than two dimensions, then broadcasting rules apply, as
        /// explained in Linear algebra on several matrices at once. This means that SVD is
        /// working in “stacked” mode: it iterates over all indices of the first
        /// a.ndim - 2 dimensions and for each combination SVD is applied to the
        /// last two indices. The matrix a can be reconstructed from the
        /// decomposition with either (u * s[..., None, :]) &#64; vh or
        /// u &#64; (s[..., None] * vh). (The &#64; operator can be replaced by the
        /// function np.matmul for python versions below 3.5.)
        /// 
        /// If a is a matrix object (as opposed to an ndarray), then so are
        /// all the return values.
        /// </summary>
        /// <param name="full_matrices">
        /// If True (default), u and vh have the shapes (..., M, M) and
        /// (..., N, N), respectively.  Otherwise, the shapes are
        /// (..., M, K) and (..., K, N), respectively, where
        /// K = min(M, N).
        /// </param>
        /// <param name="compute_uv">
        /// Whether or not to compute u and vh in addition to s.  True
        /// by default.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// u
        /// Unitary array(s). The first a.ndim - 2 dimensions have the same
        /// size as those of the input a. The size of the last two dimensions
        /// depends on the value of full_matrices. Only returned when
        /// compute_uv is True.
        /// s
        /// Vector(s) with the singular values, within each vector sorted in
        /// descending order. The first a.ndim - 2 dimensions have the same
        /// size as those of the input a.
        /// vh
        /// Unitary array(s). The first a.ndim - 2 dimensions have the same
        /// size as those of the input a. The size of the last two dimensions
        /// depends on the value of full_matrices. Only returned when
        /// compute_uv is True.
        /// </returns>
        public (NDarray, NDarray, NDarray) svd(bool? full_matrices = null, bool? compute_uv = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.svd(@this, full_matrices:full_matrices, compute_uv:compute_uv);
        }
        
        /// <summary>
        /// Compute the one-dimensional discrete Fourier Transform.
        /// 
        /// This function computes the one-dimensional n-point discrete Fourier
        /// Transform (DFT) with the efficient Fast Fourier Transform (FFT)
        /// algorithm [CT].
        /// 
        /// Notes
        /// 
        /// FFT (Fast Fourier Transform) refers to a way the discrete Fourier
        /// Transform (DFT) can be calculated efficiently, by using symmetries in the
        /// calculated terms.  The symmetry is highest when n is a power of 2, and
        /// the transform is therefore most efficient for these sizes.
        /// 
        /// The DFT is defined, with the conventions used in this implementation, in
        /// the documentation for the numpy.fft module.
        /// 
        /// References
        /// </summary>
        /// <param name="n">
        /// Length of the transformed axis of the output.
        /// If n is smaller than the length of the input, the input is cropped.
        /// If it is larger, the input is padded with zeros.  If n is not given,
        /// the length of the input along the axis specified by axis is used.
        /// </param>
        /// <param name="axis">
        /// Axis over which to compute the FFT.  If not given, the last axis is
        /// used.
        /// </param>
        /// <param name="norm">
        /// Normalization mode (see numpy.fft). Default is None.
        /// </param>
        /// <returns>
        /// The truncated or zero-padded input, transformed along the axis
        /// indicated by axis, or the last one if axis is not specified.
        /// </returns>
        public NDarray fft(int? n = null, int? axis = null, string norm = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.fft(@this, n:n, axis:axis, norm:norm);
        }
        
        /// <summary>
        /// Compute the 2-dimensional discrete Fourier Transform
        /// 
        /// This function computes the n-dimensional discrete Fourier Transform
        /// over any axes in an M-dimensional array by means of the
        /// Fast Fourier Transform (FFT).  By default, the transform is computed over
        /// the last two axes of the input array, i.e., a 2-dimensional FFT.
        /// 
        /// Notes
        /// 
        /// fft2 is just fftn with a different default for axes.
        /// 
        /// The output, analogously to fft, contains the term for zero frequency in
        /// the low-order corner of the transformed axes, the positive frequency terms
        /// in the first half of these axes, the term for the Nyquist frequency in the
        /// middle of the axes and the negative frequency terms in the second half of
        /// the axes, in order of decreasingly negative frequency.
        /// 
        /// See fftn for details and a plotting example, and numpy.fft for
        /// definitions and conventions used.
        /// </summary>
        /// <param name="s">
        /// Shape (length of each transformed axis) of the output
        /// (s[0] refers to axis 0, s[1] to axis 1, etc.).
        /// This corresponds to n for fft(x, n).
        /// Along each axis, if the given shape is smaller than that of the input,
        /// the input is cropped.  If it is larger, the input is padded with zeros.
        /// if s is not given, the shape of the input along the axes specified
        /// by axes is used.
        /// </param>
        /// <param name="axes">
        /// Axes over which to compute the FFT.  If not given, the last two
        /// axes are used.  A repeated index in axes means the transform over
        /// that axis is performed multiple times.  A one-element sequence means
        /// that a one-dimensional FFT is performed.
        /// </param>
        /// <param name="norm">
        /// Normalization mode (see numpy.fft). Default is None.
        /// </param>
        /// <returns>
        /// The truncated or zero-padded input, transformed along the axes
        /// indicated by axes, or the last two axes if axes is not given.
        /// </returns>
        public NDarray fft2(int[] s = null, int[] axes = null, string norm = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.fft2(@this, s:s, axes:axes, norm:norm);
        }
        
        /// <summary>
        /// Compute the N-dimensional discrete Fourier Transform.
        /// 
        /// This function computes the N-dimensional discrete Fourier Transform over
        /// any number of axes in an M-dimensional array by means of the Fast Fourier
        /// Transform (FFT).
        /// 
        /// Notes
        /// 
        /// The output, analogously to fft, contains the term for zero frequency in
        /// the low-order corner of all axes, the positive frequency terms in the
        /// first half of all axes, the term for the Nyquist frequency in the middle
        /// of all axes and the negative frequency terms in the second half of all
        /// axes, in order of decreasingly negative frequency.
        /// 
        /// See numpy.fft for details, definitions and conventions used.
        /// </summary>
        /// <param name="s">
        /// Shape (length of each transformed axis) of the output
        /// (s[0] refers to axis 0, s[1] to axis 1, etc.).
        /// This corresponds to n for fft(x, n).
        /// Along any axis, if the given shape is smaller than that of the input,
        /// the input is cropped.  If it is larger, the input is padded with zeros.
        /// if s is not given, the shape of the input along the axes specified
        /// by axes is used.
        /// </param>
        /// <param name="axes">
        /// Axes over which to compute the FFT.  If not given, the last len(s)
        /// axes are used, or all axes if s is also not specified.
        /// Repeated indices in axes means that the transform over that axis is
        /// performed multiple times.
        /// </param>
        /// <param name="norm">
        /// Normalization mode (see numpy.fft). Default is None.
        /// </param>
        /// <returns>
        /// The truncated or zero-padded input, transformed along the axes
        /// indicated by axes, or by a combination of s and a,
        /// as explained in the parameters section above.
        /// </returns>
        public NDarray fftn(int[] s = null, int[] axes = null, string norm = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.fftn(@this, s:s, axes:axes, norm:norm);
        }
        
        /// <summary>
        /// Compute the one-dimensional inverse discrete Fourier Transform.
        /// 
        /// This function computes the inverse of the one-dimensional n-point
        /// discrete Fourier transform computed by fft.  In other words,
        /// ifft(fft(a)) == a to within numerical accuracy.
        /// For a general description of the algorithm and definitions,
        /// see numpy.fft.
        /// 
        /// The input should be ordered in the same way as is returned by fft,
        /// i.e.,
        /// 
        /// For an even number of input points, A[n//2] represents the sum of
        /// the values at the positive and negative Nyquist frequencies, as the two
        /// are aliased together. See numpy.fft for details.
        /// 
        /// Notes
        /// 
        /// If the input parameter n is larger than the size of the input, the input
        /// is padded by appending zeros at the end.  Even though this is the common
        /// approach, it might lead to surprising results.  If a different padding is
        /// desired, it must be performed before calling ifft.
        /// </summary>
        /// <param name="n">
        /// Length of the transformed axis of the output.
        /// If n is smaller than the length of the input, the input is cropped.
        /// If it is larger, the input is padded with zeros.  If n is not given,
        /// the length of the input along the axis specified by axis is used.
        /// See notes about padding issues.
        /// </param>
        /// <param name="axis">
        /// Axis over which to compute the inverse DFT.  If not given, the last
        /// axis is used.
        /// </param>
        /// <param name="norm">
        /// Normalization mode (see numpy.fft). Default is None.
        /// </param>
        /// <returns>
        /// The truncated or zero-padded input, transformed along the axis
        /// indicated by axis, or the last one if axis is not specified.
        /// </returns>
        public NDarray ifft(int? n = null, int? axis = null, string norm = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.ifft(@this, n:n, axis:axis, norm:norm);
        }
        
        /// <summary>
        /// Compute the 2-dimensional inverse discrete Fourier Transform.
        /// 
        /// This function computes the inverse of the 2-dimensional discrete Fourier
        /// Transform over any number of axes in an M-dimensional array by means of
        /// the Fast Fourier Transform (FFT).  In other words, ifft2(fft2(a)) == a
        /// to within numerical accuracy.  By default, the inverse transform is
        /// computed over the last two axes of the input array.
        /// 
        /// The input, analogously to ifft, should be ordered in the same way as is
        /// returned by fft2, i.e. it should have the term for zero frequency
        /// in the low-order corner of the two axes, the positive frequency terms in
        /// the first half of these axes, the term for the Nyquist frequency in the
        /// middle of the axes and the negative frequency terms in the second half of
        /// both axes, in order of decreasingly negative frequency.
        /// 
        /// Notes
        /// 
        /// ifft2 is just ifftn with a different default for axes.
        /// 
        /// See ifftn for details and a plotting example, and numpy.fft for
        /// definition and conventions used.
        /// 
        /// Zero-padding, analogously with ifft, is performed by appending zeros to
        /// the input along the specified dimension.  Although this is the common
        /// approach, it might lead to surprising results.  If another form of zero
        /// padding is desired, it must be performed before ifft2 is called.
        /// </summary>
        /// <param name="s">
        /// Shape (length of each axis) of the output (s[0] refers to axis 0,
        /// s[1] to axis 1, etc.).  This corresponds to n for ifft(x, n).
        /// Along each axis, if the given shape is smaller than that of the input,
        /// the input is cropped.  If it is larger, the input is padded with zeros.
        /// if s is not given, the shape of the input along the axes specified
        /// by axes is used.  See notes for issue on ifft zero padding.
        /// </param>
        /// <param name="axes">
        /// Axes over which to compute the FFT.  If not given, the last two
        /// axes are used.  A repeated index in axes means the transform over
        /// that axis is performed multiple times.  A one-element sequence means
        /// that a one-dimensional FFT is performed.
        /// </param>
        /// <param name="norm">
        /// Normalization mode (see numpy.fft). Default is None.
        /// </param>
        /// <returns>
        /// The truncated or zero-padded input, transformed along the axes
        /// indicated by axes, or the last two axes if axes is not given.
        /// </returns>
        public NDarray ifft2(int[] s = null, int[] axes = null, string norm = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.ifft2(@this, s:s, axes:axes, norm:norm);
        }
        
        /// <summary>
        /// Compute the N-dimensional inverse discrete Fourier Transform.
        /// 
        /// This function computes the inverse of the N-dimensional discrete
        /// Fourier Transform over any number of axes in an M-dimensional array by
        /// means of the Fast Fourier Transform (FFT).  In other words,
        /// ifftn(fftn(a)) == a to within numerical accuracy.
        /// For a description of the definitions and conventions used, see numpy.fft.
        /// 
        /// The input, analogously to ifft, should be ordered in the same way as is
        /// returned by fftn, i.e. it should have the term for zero frequency
        /// in all axes in the low-order corner, the positive frequency terms in the
        /// first half of all axes, the term for the Nyquist frequency in the middle
        /// of all axes and the negative frequency terms in the second half of all
        /// axes, in order of decreasingly negative frequency.
        /// 
        /// Notes
        /// 
        /// See numpy.fft for definitions and conventions used.
        /// 
        /// Zero-padding, analogously with ifft, is performed by appending zeros to
        /// the input along the specified dimension.  Although this is the common
        /// approach, it might lead to surprising results.  If another form of zero
        /// padding is desired, it must be performed before ifftn is called.
        /// </summary>
        /// <param name="s">
        /// Shape (length of each transformed axis) of the output
        /// (s[0] refers to axis 0, s[1] to axis 1, etc.).
        /// This corresponds to n for ifft(x, n).
        /// Along any axis, if the given shape is smaller than that of the input,
        /// the input is cropped.  If it is larger, the input is padded with zeros.
        /// if s is not given, the shape of the input along the axes specified
        /// by axes is used.  See notes for issue on ifft zero padding.
        /// </param>
        /// <param name="axes">
        /// Axes over which to compute the IFFT.  If not given, the last len(s)
        /// axes are used, or all axes if s is also not specified.
        /// Repeated indices in axes means that the inverse transform over that
        /// axis is performed multiple times.
        /// </param>
        /// <param name="norm">
        /// Normalization mode (see numpy.fft). Default is None.
        /// </param>
        /// <returns>
        /// The truncated or zero-padded input, transformed along the axes
        /// indicated by axes, or by a combination of s or a,
        /// as explained in the parameters section above.
        /// </returns>
        public NDarray ifftn(int[] s = null, int[] axes = null, string norm = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.ifftn(@this, s:s, axes:axes, norm:norm);
        }
        
        /// <summary>
        /// Modified Bessel function of the first kind, order 0.
        /// 
        /// Usually denoted .  This function does broadcast, but will not
        /// “up-cast” int dtype arguments unless accompanied by at least one float or
        /// complex dtype argument (see Raises below).
        /// 
        /// Notes
        /// 
        /// We use the algorithm published by Clenshaw [1] and referenced by
        /// Abramowitz and Stegun [2], for which the function domain is
        /// partitioned into the two intervals [0,8] and (8,inf), and Chebyshev
        /// polynomial expansions are employed in each interval. Relative error on
        /// the domain [0,30] using IEEE arithmetic is documented [3] as having a
        /// peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).
        /// 
        /// References
        /// </summary>
        /// <returns>
        /// The modified Bessel function evaluated at each of the elements of x.
        /// </returns>
        public NDarray i0()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.i0(@this);
        }
        
        /// <summary>
        /// Unwrap by changing deltas between values to 2*pi complement.
        /// 
        /// Unwrap radian phase p by changing absolute jumps greater than
        /// discont to their 2*pi complement along the given axis.
        /// 
        /// Notes
        /// 
        /// If the discontinuity in p is smaller than pi, but larger than
        /// discont, no unwrapping is done because taking the 2*pi complement
        /// would only make the discontinuity larger.
        /// </summary>
        /// <param name="discont">
        /// Maximum discontinuity between values, default is pi.
        /// </param>
        /// <param name="axis">
        /// Axis along which unwrap will operate, default is the last axis.
        /// </param>
        /// <returns>
        /// Output array.
        /// </returns>
        public NDarray unwrap(float? discont = null, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.unwrap(@this, discont:discont, axis:axis);
        }
        
        /// <summary>
        /// Evenly round to the given number of decimals.
        /// 
        /// Notes
        /// 
        /// For values exactly halfway between rounded decimal values, NumPy
        /// rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,
        /// -0.5 and 0.5 round to 0.0, etc. Results may also be surprising due
        /// to the inexact representation of decimal fractions in the IEEE
        /// floating point standard [1] and errors introduced when scaling
        /// by powers of ten.
        /// 
        /// References
        /// </summary>
        /// <param name="decimals">
        /// Number of decimal places to round to (default: 0).  If
        /// decimals is negative, it specifies the number of positions to
        /// the left of the decimal point.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output, but the type of the output
        /// values will be cast if necessary. See doc.ufuncs (Section
        /// “Output arguments”) for details.
        /// </param>
        /// <returns>
        /// An array of the same type as a, containing the rounded values.
        /// Unless out was specified, a new array is created.  A reference to
        /// the result is returned.
        /// 
        /// The real and imaginary parts of complex numbers are rounded
        /// separately.  The result of rounding a float is a float.
        /// </returns>
        public NDarray around(int? decimals = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.around(@this, decimals:decimals, @out:@out);
        }
        
        /// <summary>
        /// Round to nearest integer towards zero.
        /// 
        /// Round an array of floats element-wise to nearest integer towards zero.
        /// The rounded values are returned as floats.
        /// </summary>
        /// <param name="y">
        /// Output array
        /// </param>
        /// <returns>
        /// The array of rounded numbers
        /// </returns>
        public NDarray fix(NDarray y = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.fix(@this, y:y);
        }
        
        /// <summary>
        /// Return the product of array elements over a given axis.
        /// 
        /// Notes
        /// 
        /// Arithmetic is modular when using integer types, and no error is
        /// raised on overflow.  That means that, on a 32-bit platform:
        /// 
        /// The product of an empty array is the neutral element 1:
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which a product is performed.  The default,
        /// axis=None, will calculate the product of all the elements in the
        /// input array. If axis is negative it counts from the last to the
        /// first axis.
        /// 
        /// If axis is a tuple of ints, a product is performed on all of the
        /// axes specified in the tuple instead of a single axis or all the
        /// axes as before.
        /// </param>
        /// <param name="dtype">
        /// The type of the returned array, as well as of the accumulator in
        /// which the elements are multiplied.  The dtype of a is used by
        /// default unless a has an integer dtype of less precision than the
        /// default platform integer.  In that case, if a is signed then the
        /// platform integer is used while if a is unsigned then an unsigned
        /// integer of the same precision as the platform integer is used.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output, but the type of the output
        /// values will be cast if necessary.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left in the
        /// result as dimensions with size one. With this option, the result
        /// will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the prod method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <param name="initial">
        /// The starting value for this product. See reduce for details.
        /// </param>
        /// <returns>
        /// An array shaped as a but with the specified axis removed.
        /// Returns a reference to out if specified.
        /// </returns>
        public NDarray prod(int[] axis = null, Dtype dtype = null, NDarray @out = null, bool? keepdims = null, ValueType initial = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.prod(@this, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims, initial:initial);
        }
        
        /// <summary>
        /// Sum of array elements over a given axis.
        /// 
        /// Notes
        /// 
        /// Arithmetic is modular when using integer types, and no error is
        /// raised on overflow.
        /// 
        /// The sum of an empty array is the neutral element 0:
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which a sum is performed.  The default,
        /// axis=None, will sum all of the elements of the input array.  If
        /// axis is negative it counts from the last to the first axis.
        /// 
        /// If axis is a tuple of ints, a sum is performed on all of the axes
        /// specified in the tuple instead of a single axis or all the axes as
        /// before.
        /// </param>
        /// <param name="dtype">
        /// The type of the returned array and of the accumulator in which the
        /// elements are summed.  The dtype of a is used by default unless a
        /// has an integer dtype of less precision than the default platform
        /// integer.  In that case, if a is signed then the platform integer
        /// is used while if a is unsigned then an unsigned integer of the
        /// same precision as the platform integer is used.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output, but the type of the output
        /// values will be cast if necessary.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the sum method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <param name="initial">
        /// Starting value for the sum. See reduce for details.
        /// </param>
        /// <returns>
        /// An array with the same shape as a, with the specified
        /// axis removed.   If a is a 0-d array, or if axis is None, a scalar
        /// is returned.  If an output array is specified, a reference to
        /// out is returned.
        /// </returns>
        public NDarray sum(int[] axis = null, Dtype dtype = null, NDarray @out = null, bool? keepdims = null, ValueType initial = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.sum(@this, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims, initial:initial);
        }
        
        /// <summary>
        /// Return the product of array elements over a given axis treating Not a
        /// Numbers (NaNs) as ones.
        /// 
        /// One is returned for slices that are all-NaN or empty.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the product is computed. The default is to compute
        /// the product of the flattened array.
        /// </param>
        /// <param name="dtype">
        /// The type of the returned array and of the accumulator in which the
        /// elements are summed.  By default, the dtype of a is used.  An
        /// exception is when a has an integer type with less precision than
        /// the platform (u)intp. In that case, the default will be either
        /// (u)int32 or (u)int64 depending on whether the platform is 32 or 64
        /// bits. For inexact inputs, dtype must be inexact.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None. If provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.  See
        /// doc.ufuncs for details. The casting of NaN to integer can yield
        /// unexpected results.
        /// </param>
        /// <param name="keepdims">
        /// If True, the axes which are reduced are left in the result as
        /// dimensions with size one. With this option, the result will
        /// broadcast correctly against the original arr.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which case it is returned.
        /// </returns>
        public NDarray nanprod(int[] axis = null, Dtype dtype = null, NDarray @out = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanprod(@this, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims);
        }
        
        /// <summary>
        /// Return the sum of array elements over a given axis treating Not a
        /// Numbers (NaNs) as zero.
        /// 
        /// In NumPy versions &lt;= 1.9.0 Nan is returned for slices that are all-NaN or
        /// empty. In later versions zero is returned.
        /// 
        /// Notes
        /// 
        /// If both positive and negative infinity are present, the sum will be Not
        /// A Number (NaN).
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the sum is computed. The default is to compute the
        /// sum of the flattened array.
        /// </param>
        /// <param name="dtype">
        /// The type of the returned array and of the accumulator in which the
        /// elements are summed.  By default, the dtype of a is used.  An
        /// exception is when a has an integer type with less precision than
        /// the platform (u)intp. In that case, the default will be either
        /// (u)int32 or (u)int64 depending on whether the platform is 32 or 64
        /// bits. For inexact inputs, dtype must be inexact.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None. If provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.  See
        /// doc.ufuncs for details. The casting of NaN to integer can yield
        /// unexpected results.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// 
        /// If the value is anything but the default, then
        /// keepdims will be passed through to the mean or sum methods
        /// of sub-classes of ndarray.  If the sub-classes methods
        /// does not implement keepdims any exceptions will be raised.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which it is returned. The result has the same
        /// size as a, and the same shape as a if axis is not None
        /// or a is a 1-d array.
        /// </returns>
        public NDarray nansum(int[] axis = null, Dtype dtype = null, NDarray @out = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nansum(@this, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims);
        }
        
        /// <summary>
        /// Return the cumulative product of elements along a given axis.
        /// 
        /// Notes
        /// 
        /// Arithmetic is modular when using integer types, and no error is
        /// raised on overflow.
        /// </summary>
        /// <param name="axis">
        /// Axis along which the cumulative product is computed.  By default
        /// the input is flattened.
        /// </param>
        /// <param name="dtype">
        /// Type of the returned array, as well as of the accumulator in which
        /// the elements are multiplied.  If dtype is not specified, it
        /// defaults to the dtype of a, unless a has an integer dtype with
        /// a precision less than that of the default platform integer.  In
        /// that case, the default platform integer is used instead.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output
        /// but the type of the resulting values will be cast if necessary.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which case a reference to out is returned.
        /// </returns>
        public NDarray cumprod(int? axis = null, Dtype dtype = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.cumprod(@this, axis:axis, dtype:dtype, @out:@out);
        }
        
        /// <summary>
        /// Return the cumulative sum of the elements along a given axis.
        /// 
        /// Notes
        /// 
        /// Arithmetic is modular when using integer types, and no error is
        /// raised on overflow.
        /// </summary>
        /// <param name="axis">
        /// Axis along which the cumulative sum is computed. The default
        /// (None) is to compute the cumsum over the flattened array.
        /// </param>
        /// <param name="dtype">
        /// Type of the returned array and of the accumulator in which the
        /// elements are summed.  If dtype is not specified, it defaults
        /// to the dtype of a, unless a has an integer dtype with a
        /// precision less than that of the default platform integer.  In
        /// that case, the default platform integer is used.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output
        /// but the type will be cast if necessary. See doc.ufuncs
        /// (Section “Output arguments”) for more details.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which case a reference to out is returned. The
        /// result has the same size as a, and the same shape as a if
        /// axis is not None or a is a 1-d array.
        /// </returns>
        public NDarray cumsum(int? axis = null, Dtype dtype = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.cumsum(@this, axis:axis, dtype:dtype, @out:@out);
        }
        
        /// <summary>
        /// Return the cumulative product of array elements over a given axis treating Not a
        /// Numbers (NaNs) as one.  The cumulative product does not change when NaNs are
        /// encountered and leading NaNs are replaced by ones.
        /// 
        /// Ones are returned for slices that are all-NaN or empty.
        /// </summary>
        /// <param name="axis">
        /// Axis along which the cumulative product is computed.  By default
        /// the input is flattened.
        /// </param>
        /// <param name="dtype">
        /// Type of the returned array, as well as of the accumulator in which
        /// the elements are multiplied.  If dtype is not specified, it
        /// defaults to the dtype of a, unless a has an integer dtype with
        /// a precision less than that of the default platform integer.  In
        /// that case, the default platform integer is used instead.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output
        /// but the type of the resulting values will be cast if necessary.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which case it is returned.
        /// </returns>
        public NDarray nancumprod(int? axis = null, Dtype dtype = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nancumprod(@this, axis:axis, dtype:dtype, @out:@out);
        }
        
        /// <summary>
        /// Return the cumulative sum of array elements over a given axis treating Not a
        /// Numbers (NaNs) as zero.  The cumulative sum does not change when NaNs are
        /// encountered and leading NaNs are replaced by zeros.
        /// 
        /// Zeros are returned for slices that are all-NaN or empty.
        /// </summary>
        /// <param name="axis">
        /// Axis along which the cumulative sum is computed. The default
        /// (None) is to compute the cumsum over the flattened array.
        /// </param>
        /// <param name="dtype">
        /// Type of the returned array and of the accumulator in which the
        /// elements are summed.  If dtype is not specified, it defaults
        /// to the dtype of a, unless a has an integer dtype with a
        /// precision less than that of the default platform integer.  In
        /// that case, the default platform integer is used.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output
        /// but the type will be cast if necessary. See doc.ufuncs
        /// (Section “Output arguments”) for more details.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which it is returned. The result has the same
        /// size as a, and the same shape as a if axis is not None
        /// or a is a 1-d array.
        /// </returns>
        public NDarray nancumsum(int? axis = null, Dtype dtype = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nancumsum(@this, axis:axis, dtype:dtype, @out:@out);
        }
        
        /// <summary>
        /// Calculate the n-th discrete difference along the given axis.
        /// 
        /// The first difference is given by out[n] = a[n+1] - a[n] along
        /// the given axis, higher differences are calculated by using diff
        /// recursively.
        /// 
        /// Notes
        /// 
        /// Type is preserved for boolean arrays, so the result will contain
        /// False when consecutive elements are the same and True when they
        /// differ.
        /// 
        /// For unsigned integer arrays, the results will also be unsigned. This
        /// should not be surprising, as the result is consistent with
        /// calculating the difference directly:
        /// 
        /// If this is not desirable, then the array should be cast to a larger
        /// integer type first:
        /// </summary>
        /// <param name="n">
        /// The number of times values are differenced. If zero, the input
        /// is returned as-is.
        /// </param>
        /// <param name="axis">
        /// The axis along which the difference is taken, default is the
        /// last axis.
        /// </param>
        /// <param name="append">
        /// Values to prepend or append to “a” along axis prior to
        /// performing the difference.  Scalar values are expanded to
        /// arrays with length 1 in the direction of axis and the shape
        /// of the input array in along all other axes.  Otherwise the
        /// dimension and shape must match “a” except along axis.
        /// </param>
        /// <param name="prepend">
        /// Values to prepend or append to “a” along axis prior to
        /// performing the difference.  Scalar values are expanded to
        /// arrays with length 1 in the direction of axis and the shape
        /// of the input array in along all other axes.  Otherwise the
        /// dimension and shape must match “a” except along axis.
        /// </param>
        /// <returns>
        /// The n-th differences. The shape of the output is the same as a
        /// except along axis where the dimension is smaller by n. The
        /// type of the output is the same as the type of the difference
        /// between any two elements of a. This is the same as the type of
        /// a in most cases. A notable exception is datetime64, which
        /// results in a timedelta64 output array.
        /// </returns>
        public NDarray diff(int? n = null, int? axis = null, NDarray append = null, NDarray prepend = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.diff(@this, n:n, axis:axis, append:append, prepend:prepend);
        }
        
        /// <summary>
        /// The differences between consecutive elements of an array.
        /// 
        /// Notes
        /// 
        /// When applied to masked arrays, this function drops the mask information
        /// if the to_begin and/or to_end parameters are used.
        /// </summary>
        /// <param name="to_end">
        /// Number(s) to append at the end of the returned differences.
        /// </param>
        /// <param name="to_begin">
        /// Number(s) to prepend at the beginning of the returned differences.
        /// </param>
        /// <returns>
        /// The differences. Loosely, this is ary.flat[1:] - ary.flat[:-1].
        /// </returns>
        public NDarray ediff1d(NDarray to_end = null, NDarray to_begin = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.ediff1d(@this, to_end:to_end, to_begin:to_begin);
        }
        
        /// <summary>
        /// Return the gradient of an N-dimensional array.
        /// 
        /// The gradient is computed using second order accurate central differences
        /// in the interior points and either first or second order accurate one-sides
        /// (forward or backwards) differences at the boundaries.
        /// The returned gradient hence has the same shape as the input array.
        /// 
        /// Notes
        /// 
        /// Assuming that  (i.e.,  has at least 3 continuous
        /// derivatives) and let  be a non-homogeneous stepsize, we
        /// minimize the “consistency error”  between the true gradient
        /// and its estimate from a linear combination of the neighboring grid-points:
        /// 
        /// By substituting  and 
        /// with their Taylor series expansion, this translates into solving
        /// the following the linear system:
        /// 
        /// The resulting approximation of  is the following:
        /// 
        /// It is worth noting that if 
        /// (i.e., data are evenly spaced)
        /// we find the standard second order approximation:
        /// 
        /// With a similar procedure the forward/backward approximations used for
        /// boundaries can be derived.
        /// 
        /// References
        /// </summary>
        /// <param name="varargs">
        /// Spacing between f values. Default unitary spacing for all dimensions.
        /// Spacing can be specified using:
        /// 
        /// If axis is given, the number of varargs must equal the number of axes.
        /// Default: 1.
        /// </param>
        /// <param name="edge_order">
        /// Gradient is calculated using N-th order accurate differences
        /// at the boundaries. Default: 1.
        /// </param>
        /// <param name="axis">
        /// Gradient is calculated only along the given axis or axes
        /// The default (axis = None) is to calculate the gradient for all the axes
        /// of the input array. axis may be negative, in which case it counts from
        /// the last to the first axis.
        /// </param>
        /// <returns>
        /// A set of ndarrays (or a single ndarray if there is only one dimension)
        /// corresponding to the derivatives of f with respect to each dimension.
        /// Each derivative has the same shape as f.
        /// </returns>
        public NDarray gradient(NDarray varargs = null, int? edge_order = null, int[] axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.gradient(@this, varargs:varargs, edge_order:edge_order, axis:axis);
        }
        
        /// <summary>
        /// Return the cross product of two (arrays of) vectors.
        /// 
        /// The cross product of a and b in  is a vector perpendicular
        /// to both a and b.  If a and b are arrays of vectors, the vectors
        /// are defined by the last axis of a and b by default, and these axes
        /// can have dimensions 2 or 3.  Where the dimension of either a or b is
        /// 2, the third component of the input vector is assumed to be zero and the
        /// cross product calculated accordingly.  In cases where both input vectors
        /// have dimension 2, the z-component of the cross product is returned.
        /// 
        /// Notes
        /// 
        /// Supports full broadcasting of the inputs.
        /// </summary>
        /// <param name="b">
        /// Components of the second vector(s).
        /// </param>
        /// <param name="axisa">
        /// Axis of a that defines the vector(s).  By default, the last axis.
        /// </param>
        /// <param name="axisb">
        /// Axis of b that defines the vector(s).  By default, the last axis.
        /// </param>
        /// <param name="axisc">
        /// Axis of c containing the cross product vector(s).  Ignored if
        /// both input vectors have dimension 2, as the return is scalar.
        /// By default, the last axis.
        /// </param>
        /// <param name="axis">
        /// If defined, the axis of a, b and c that defines the vector(s)
        /// and cross product(s).  Overrides axisa, axisb and axisc.
        /// </param>
        /// <returns>
        /// Vector cross product(s).
        /// </returns>
        public NDarray cross(NDarray b, int? axisa = null, int? axisb = null, int? axisc = null, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.cross(@this, b, axisa:axisa, axisb:axisb, axisc:axisc, axis:axis);
        }
        
        /// <summary>
        /// Integrate along the given axis using the composite trapezoidal rule.
        /// 
        /// Integrate y (x) along given axis.
        /// 
        /// Notes
        /// 
        /// Image [2] illustrates trapezoidal rule – y-axis locations of points
        /// will be taken from y array, by default x-axis distances between
        /// points will be 1.0, alternatively they can be provided with x array
        /// or with dx scalar.  Return value will be equal to combined area under
        /// the red lines.
        /// 
        /// References
        /// </summary>
        /// <param name="x">
        /// The sample points corresponding to the y values. If x is None,
        /// the sample points are assumed to be evenly spaced dx apart. The
        /// default is None.
        /// </param>
        /// <param name="dx">
        /// The spacing between sample points when x is None. The default is 1.
        /// </param>
        /// <param name="axis">
        /// The axis along which to integrate.
        /// </param>
        /// <returns>
        /// Definite integral as approximated by trapezoidal rule.
        /// </returns>
        public float trapz(NDarray x = null, ValueType dx = null, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.trapz(@this, x:x, dx:dx, axis:axis);
        }
        
        /// <summary>
        /// Return the sinc function.
        /// 
        /// The sinc function is .
        /// 
        /// Notes
        /// 
        /// sinc(0) is the limit value 1.
        /// 
        /// The name sinc is short for “sine cardinal” or “sinus cardinalis”.
        /// 
        /// The sinc function is used in various signal processing applications,
        /// including in anti-aliasing, in the construction of a Lanczos resampling
        /// filter, and in interpolation.
        /// 
        /// For bandlimited interpolation of discrete-time signals, the ideal
        /// interpolation kernel is proportional to the sinc function.
        /// 
        /// References
        /// </summary>
        /// <returns>
        /// sinc(x), which has the same shape as the input.
        /// </returns>
        public NDarray sinc()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.sinc(@this);
        }
        
        /// <summary>
        /// Return the angle of the complex argument.
        /// </summary>
        /// <param name="deg">
        /// Return angle in degrees if True, radians if False (default).
        /// </param>
        /// <returns>
        /// The counterclockwise angle from the positive real axis on
        /// the complex plane, with dtype as numpy.float64.
        /// </returns>
        public NDarray angle(bool? deg = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.angle(@this, deg:deg);
        }
        
        /// <summary>
        /// Return the real part of the complex argument.
        /// </summary>
        /// <returns>
        /// The real component of the complex argument. If val is real, the type
        /// of val is used for the output.  If val has complex elements, the
        /// returned type is float.
        /// </returns>
        public NDarray real()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.real(@this);
        }
        
        /// <summary>
        /// Return the imaginary part of the complex argument.
        /// </summary>
        /// <returns>
        /// The imaginary component of the complex argument. If val is real,
        /// the type of val is used for the output.  If val has complex
        /// elements, the returned type is float.
        /// </returns>
        public NDarray imag()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.imag(@this);
        }
        
        /// <summary>
        /// Returns the discrete, linear convolution of two one-dimensional sequences.
        /// 
        /// The convolution operator is often seen in signal processing, where it
        /// models the effect of a linear time-invariant system on a signal [1].  In
        /// probability theory, the sum of two independent random variables is
        /// distributed according to the convolution of their individual
        /// distributions.
        /// 
        /// If v is longer than a, the arrays are swapped before computation.
        /// 
        /// Notes
        /// 
        /// The discrete convolution operation is defined as
        /// 
        /// It can be shown that a convolution  in time/space
        /// is equivalent to the multiplication  in the Fourier
        /// domain, after appropriate padding (padding is necessary to prevent
        /// circular convolution).  Since multiplication is more efficient (faster)
        /// than convolution, the function scipy.signal.fftconvolve exploits the
        /// FFT to calculate the convolution of large data-sets.
        /// 
        /// References
        /// </summary>
        /// <param name="v">
        /// Second one-dimensional input array.
        /// </param>
        /// <returns>
        /// Discrete, linear convolution of a and v.
        /// </returns>
        public NDarray convolve(NDarray v, string mode = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.convolve(@this, v, mode:mode);
        }
        
        /// <summary>
        /// Clip (limit) the values in an array.
        /// 
        /// Given an interval, values outside the interval are clipped to
        /// the interval edges.  For example, if an interval of [0, 1]
        /// is specified, values smaller than 0 become 0, and values larger
        /// than 1 become 1.
        /// </summary>
        /// <param name="a_min">
        /// Minimum value. If None, clipping is not performed on lower
        /// interval edge. Not more than one of a_min and a_max may be
        /// None.
        /// </param>
        /// <param name="a_max">
        /// Maximum value. If None, clipping is not performed on upper
        /// interval edge. Not more than one of a_min and a_max may be
        /// None. If a_min or a_max are array_like, then the three
        /// arrays will be broadcasted to match their shapes.
        /// </param>
        /// <param name="@out">
        /// The results will be placed in this array. It may be the input
        /// array for in-place clipping.  out must be of the right shape
        /// to hold the output.  Its type is preserved.
        /// </param>
        /// <returns>
        /// An array with the elements of a, but where values
        /// &lt; a_min are replaced with a_min, and those &gt; a_max
        /// with a_max.
        /// </returns>
        public NDarray clip(NDarray a_min, NDarray a_max, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.clip(@this, a_min, a_max, @out:@out);
        }
        
        /// <summary>
        /// Replace NaN with zero and infinity with large finite numbers.
        /// 
        /// If x is inexact, NaN is replaced by zero, and infinity and -infinity
        /// replaced by the respectively largest and most negative finite floating
        /// point values representable by x.dtype.
        /// 
        /// For complex dtypes, the above is applied to each of the real and
        /// imaginary components of x separately.
        /// 
        /// If x is not inexact, then no replacements are made.
        /// 
        /// Notes
        /// 
        /// NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
        /// (IEEE 754). This means that Not a Number is not equivalent to infinity.
        /// </summary>
        /// <param name="copy">
        /// Whether to create a copy of x (True) or to replace values
        /// in-place (False). The in-place operation only occurs if
        /// casting to an array does not require a copy.
        /// Default is True.
        /// </param>
        /// <returns>
        /// x, with the non-finite values replaced. If copy is False, this may
        /// be x itself.
        /// </returns>
        public NDarray nan_to_num(bool? copy = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nan_to_num(@this, copy:copy);
        }
        
        /// <summary>
        /// If complex input returns a real array if complex parts are close to zero.
        /// 
        /// “Close to zero” is defined as tol * (machine epsilon of the type for
        /// a).
        /// 
        /// Notes
        /// 
        /// Machine epsilon varies from machine to machine and between data types
        /// but Python floats on most platforms have a machine epsilon equal to
        /// 2.2204460492503131e-16.  You can use ‘np.finfo(float).eps’ to print
        /// out the machine epsilon for floats.
        /// </summary>
        /// <param name="tol">
        /// Tolerance in machine epsilons for the complex part of the elements
        /// in the array.
        /// </param>
        /// <returns>
        /// If a is real, the type of a is used for the output.  If a
        /// has complex elements, the returned type is float.
        /// </returns>
        public NDarray real_if_close(float tol)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.real_if_close(@this, tol);
        }
        
        /*
        /// <summary>
        /// One-dimensional linear interpolation.
        /// 
        /// Returns the one-dimensional piecewise linear interpolant to a function
        /// with given discrete data points (xp, fp), evaluated at x.
        /// 
        /// Notes
        /// 
        /// Does not check that the x-coordinate sequence xp is increasing.
        /// If xp is not increasing, the results are nonsense.
        /// A simple check for increasing is:
        /// </summary>
        /// <param name="xp">
        /// The x-coordinates of the data points, must be increasing if argument
        /// period is not specified. Otherwise, xp is internally sorted after
        /// normalizing the periodic boundaries with xp = xp % period.
        /// </param>
        /// <param name="fp">
        /// The y-coordinates of the data points, same length as xp.
        /// </param>
        /// <param name="left">
        /// Value to return for x &lt; xp[0], default is fp[0].
        /// </param>
        /// <param name="right">
        /// Value to return for x &gt; xp[-1], default is fp[-1].
        /// </param>
        /// <param name="period">
        /// A period for the x-coordinates. This parameter allows the proper
        /// interpolation of angular x-coordinates. Parameters left and right
        /// are ignored if period is specified.
        /// </param>
        /// <returns>
        /// The interpolated values, same shape as x.
        /// </returns>
        public float or complex (corresponding to fp) or ndarray interp(1-D sequence of floats xp, 1-D sequence of float or complex fp, optional float or complex corresponding to fp left = null, optional float or complex corresponding to fp right = null, None or float period = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.interp(@this, xp, fp, left:left, right:right, period:period);
        }
        */
        
        /// <summary>
        /// Test whether all array elements along a given axis evaluate to True.
        /// 
        /// Notes
        /// 
        /// Not a Number (NaN), positive infinity and negative infinity
        /// evaluate to True because these are not equal to zero.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which a logical AND reduction is performed.
        /// The default (axis = None) is to perform a logical AND over all
        /// the dimensions of the input array. axis may be negative, in
        /// which case it counts from the last to the first axis.
        /// 
        /// If this is a tuple of ints, a reduction is performed on multiple
        /// axes, instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.
        /// It must have the same shape as the expected output and its
        /// type is preserved (e.g., if dtype(out) is float, the result
        /// will consist of 0.0’s and 1.0’s).  See doc.ufuncs (Section
        /// “Output arguments”) for more details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the all method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <returns>
        /// A new boolean or array is returned unless out is specified,
        /// in which case a reference to out is returned.
        /// </returns>
        public NDarray<bool> all(int[] axis, NDarray @out = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.all(@this, axis:axis, @out:@out, keepdims:keepdims);
        }
        
        /// <summary>
        /// Test whether all array elements along a given axis evaluate to True.
        /// 
        /// Notes
        /// 
        /// Not a Number (NaN), positive infinity and negative infinity
        /// evaluate to True because these are not equal to zero.
        /// </summary>
        /// <returns>
        /// A new boolean or array is returned unless out is specified,
        /// in which case a reference to out is returned.
        /// </returns>
        public bool all()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.all(@this);
        }
        
        /// <summary>
        /// Test whether any array element along a given axis evaluates to True.
        /// 
        /// Returns single boolean unless axis is not None
        /// 
        /// Notes
        /// 
        /// Not a Number (NaN), positive infinity and negative infinity evaluate
        /// to True because these are not equal to zero.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which a logical OR reduction is performed.
        /// The default (axis = None) is to perform a logical OR over all
        /// the dimensions of the input array. axis may be negative, in
        /// which case it counts from the last to the first axis.
        /// 
        /// If this is a tuple of ints, a reduction is performed on multiple
        /// axes, instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  It must have
        /// the same shape as the expected output and its type is preserved
        /// (e.g., if it is of type float, then it will remain so, returning
        /// 1.0 for True and 0.0 for False, regardless of the type of a).
        /// See doc.ufuncs (Section “Output arguments”) for details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the any method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <returns>
        /// A new boolean or ndarray is returned unless out is specified,
        /// in which case a reference to out is returned.
        /// </returns>
        public NDarray<bool> any(int[] axis, NDarray @out = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.any(@this, axis:axis, @out:@out, keepdims:keepdims);
        }
        
        /// <summary>
        /// Test whether any array element along a given axis evaluates to True.
        /// 
        /// Returns single boolean unless axis is not None
        /// 
        /// Notes
        /// 
        /// Not a Number (NaN), positive infinity and negative infinity evaluate
        /// to True because these are not equal to zero.
        /// </summary>
        /// <returns>
        /// A new boolean or ndarray is returned unless out is specified,
        /// in which case a reference to out is returned.
        /// </returns>
        public bool any()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.any(@this);
        }
        
        /// <summary>
        /// Test element-wise for negative infinity, return result as bool array.
        /// 
        /// Notes
        /// 
        /// NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
        /// (IEEE 754).
        /// 
        /// Errors result if the second argument is also supplied when x is a scalar
        /// input, if first and second arguments have different shapes, or if the
        /// first argument has complex values.
        /// </summary>
        /// <param name="@out">
        /// A boolean array with the same shape and type as x to store the
        /// result.
        /// </param>
        /// <returns>
        /// A boolean array with the same dimensions as the input.
        /// If second argument is not supplied then a numpy boolean array is
        /// returned with values True where the corresponding element of the
        /// input is negative infinity and values False where the element of
        /// the input is not negative infinity.
        /// 
        /// If a second argument is supplied the result is stored there. If the
        /// type of that array is a numeric type the result is represented as
        /// zeros and ones, if the type is boolean then as False and True. The
        /// return value out is then a reference to that array.
        /// </returns>
        public NDarray isneginf(NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.isneginf(@this, @out:@out);
        }
        
        /// <summary>
        /// Test element-wise for positive infinity, return result as bool array.
        /// 
        /// Notes
        /// 
        /// NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
        /// (IEEE 754).
        /// 
        /// Errors result if the second argument is also supplied when x is a scalar
        /// input, if first and second arguments have different shapes, or if the
        /// first argument has complex values
        /// </summary>
        /// <param name="y">
        /// A boolean array with the same shape as x to store the result.
        /// </param>
        /// <returns>
        /// A boolean array with the same dimensions as the input.
        /// If second argument is not supplied then a boolean array is returned
        /// with values True where the corresponding element of the input is
        /// positive infinity and values False where the element of the input is
        /// not positive infinity.
        /// 
        /// If a second argument is supplied the result is stored there. If the
        /// type of that array is a numeric type the result is represented as zeros
        /// and ones, if the type is boolean then as False and True.
        /// The return value out is then a reference to that array.
        /// </returns>
        public NDarray isposinf(NDarray y = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.isposinf(@this, y:y);
        }
        
        /// <summary>
        /// Returns a bool array, where True if input element is complex.
        /// 
        /// What is tested is whether the input has a non-zero imaginary part, not if
        /// the input type is complex.
        /// </summary>
        /// <returns>
        /// Output array.
        /// </returns>
        public NDarray iscomplex()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.iscomplex(@this);
        }
        
        /// <summary>
        /// Returns True if the array is Fortran contiguous but not C contiguous.
        /// 
        /// This function is obsolete and, because of changes due to relaxed stride
        /// checking, its return value for the same array may differ for versions
        /// of NumPy &gt;= 1.10.0 and previous versions. If you only want to check if an
        /// array is Fortran contiguous use a.flags.f_contiguous instead.
        /// </summary>
        public bool isfortran()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.isfortran(@this);
        }
        
        /// <summary>
        /// Returns a bool array, where True if input element is real.
        /// 
        /// If element has complex type with zero complex part, the return value
        /// for that element is True.
        /// </summary>
        /// <returns>
        /// Boolean array of same shape as x.
        /// </returns>
        public NDarray isreal()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.isreal(@this);
        }
        
        /// <summary>
        /// Returns True if two arrays are element-wise equal within a tolerance.
        /// 
        /// The tolerance values are positive, typically very small numbers.  The
        /// relative difference (rtol * abs(b)) and the absolute difference
        /// atol are added together to compare against the absolute difference
        /// between a and b.
        /// 
        /// If either array contains one or more NaNs, False is returned.
        /// Infs are treated as equal if they are in the same place and of the same
        /// sign in both arrays.
        /// 
        /// Notes
        /// 
        /// If the following equation is element-wise True, then allclose returns
        /// True.
        /// 
        /// The above equation is not symmetric in a and b, so that
        /// allclose(a, b) might be different from allclose(b, a) in
        /// some rare cases.
        /// 
        /// The comparison of a and b uses standard broadcasting, which
        /// means that a and b need not have the same shape in order for
        /// allclose(a, b) to evaluate to True.  The same is true for
        /// equal but not array_equal.
        /// </summary>
        /// <param name="a">
        /// Input arrays to compare.
        /// </param>
        /// <param name="rtol">
        /// The relative tolerance parameter (see Notes).
        /// </param>
        /// <param name="atol">
        /// The absolute tolerance parameter (see Notes).
        /// </param>
        /// <param name="equal_nan">
        /// Whether to compare NaN’s as equal.  If True, NaN’s in a will be
        /// considered equal to NaN’s in b in the output array.
        /// </param>
        /// <returns>
        /// Returns True if the two arrays are equal within the given
        /// tolerance; False otherwise.
        /// </returns>
        public bool allclose(NDarray a, float rtol, float atol, bool equal_nan)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.allclose(@this, a, rtol, atol, equal_nan);
        }
        
        /// <summary>
        /// Returns a boolean array where two arrays are element-wise equal within a
        /// tolerance.
        /// 
        /// The tolerance values are positive, typically very small numbers.  The
        /// relative difference (rtol * abs(b)) and the absolute difference
        /// atol are added together to compare against the absolute difference
        /// between a and b.
        /// 
        /// Notes
        /// 
        /// For finite values, isclose uses the following equation to test whether
        /// two floating point values are equivalent.
        /// 
        /// Unlike the built-in math.isclose, the above equation is not symmetric
        /// in a and b – it assumes b is the reference value – so that
        /// isclose(a, b) might be different from isclose(b, a). Furthermore,
        /// the default value of atol is not zero, and is used to determine what
        /// small values should be considered close to zero. The default value is
        /// appropriate for expected values of order unity: if the expected values
        /// are significantly smaller than one, it can result in false positives.
        /// atol should be carefully selected for the use case at hand. A zero value
        /// for atol will result in False if either a or b is zero.
        /// </summary>
        /// <param name="a">
        /// Input arrays to compare.
        /// </param>
        /// <param name="rtol">
        /// The relative tolerance parameter (see Notes).
        /// </param>
        /// <param name="atol">
        /// The absolute tolerance parameter (see Notes).
        /// </param>
        /// <param name="equal_nan">
        /// Whether to compare NaN’s as equal.  If True, NaN’s in a will be
        /// considered equal to NaN’s in b in the output array.
        /// </param>
        /// <returns>
        /// Returns a boolean array of where a and b are equal within the
        /// given tolerance. If both a and b are scalars, returns a single
        /// boolean value.
        /// </returns>
        public NDarray isclose(NDarray a, float rtol, float atol, bool equal_nan)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.isclose(@this, a, rtol, atol, equal_nan);
        }
        
        /// <summary>
        /// True if two arrays have the same shape and elements, False otherwise.
        /// </summary>
        /// <param name="a1">
        /// Input arrays.
        /// </param>
        /// <returns>
        /// Returns True if the arrays are equal.
        /// </returns>
        public bool array_equal(NDarray a1)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.array_equal(@this, a1);
        }
        
        /// <summary>
        /// Returns True if input arrays are shape consistent and all elements equal.
        /// 
        /// Shape consistent means they are either the same shape, or one input array
        /// can be broadcasted to create the same shape as the other one.
        /// </summary>
        /// <param name="a1">
        /// Input arrays.
        /// </param>
        /// <returns>
        /// True if equivalent, False otherwise.
        /// </returns>
        public bool array_equiv(NDarray a1)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.array_equiv(@this, a1);
        }
        
        /// <summary>
        /// Return a sorted copy of an array.
        /// 
        /// Notes
        /// 
        /// The various sorting algorithms are characterized by their average speed,
        /// worst case performance, work space size, and whether they are stable. A
        /// stable sort keeps items with the same key in the same relative
        /// order. The three available algorithms have the following
        /// properties:
        /// 
        /// All the sort algorithms make temporary copies of the data when
        /// sorting along any but the last axis.  Consequently, sorting along
        /// the last axis is faster and uses less space than sorting along
        /// any other axis.
        /// 
        /// The sort order for complex numbers is lexicographic. If both the real
        /// and imaginary parts are non-nan then the order is determined by the
        /// real parts except when they are equal, in which case the order is
        /// determined by the imaginary parts.
        /// 
        /// Previous to numpy 1.4.0 sorting real and complex arrays containing nan
        /// values led to undefined behaviour. In numpy versions &gt;= 1.4.0 nan
        /// values are sorted to the end. The extended sort order is:
        /// 
        /// where R is a non-nan real value. Complex values with the same nan
        /// placements are sorted according to the non-nan part if it exists.
        /// Non-nan values are sorted as before.
        /// 
        /// quicksort has been changed to an introsort which will switch
        /// heapsort when it does not make enough progress. This makes its
        /// worst case O(n*log(n)).
        /// 
        /// ‘stable’ automatically choses the best stable sorting algorithm
        /// for the data type being sorted. It is currently mapped to
        /// merge sort.
        /// </summary>
        /// <param name="axis">
        /// Axis along which to sort. If None, the array is flattened before
        /// sorting. The default is -1, which sorts along the last axis.
        /// </param>
        /// <param name="kind">
        /// Sorting algorithm. Default is ‘quicksort’.
        /// </param>
        /// <param name="order">
        /// When a is an array with fields defined, this argument specifies
        /// which fields to compare first, second, etc.  A single field can
        /// be specified as a string, and not all fields need be specified,
        /// but unspecified fields will still be used, in the order in which
        /// they come up in the dtype, to break ties.
        /// </param>
        /// <returns>
        /// Array of the same type and shape as a.
        /// </returns>
        public NDarray sort(int? axis = -1, string kind = null, string order = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.sort(@this, axis:axis, kind:kind, order:order);
        }
        
        /// <summary>
        /// Perform an indirect stable sort using a sequence of keys.
        /// 
        /// Given multiple sorting keys, which can be interpreted as columns in a
        /// spreadsheet, lexsort returns an array of integer indices that describes
        /// the sort order by multiple columns. The last key in the sequence is used
        /// for the primary sort order, the second-to-last key for the secondary sort
        /// order, and so on. The keys argument must be a sequence of objects that
        /// can be converted to arrays of the same shape. If a 2D array is provided
        /// for the keys argument, it’s rows are interpreted as the sorting keys and
        /// sorting is according to the last row, second last row etc.
        /// </summary>
        /// <param name="axis">
        /// Axis to be indirectly sorted.  By default, sort over the last axis.
        /// </param>
        /// <returns>
        /// Array of indices that sort the keys along the specified axis.
        /// </returns>
        public NDarray lexsort(int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.lexsort(@this, axis:axis);
        }
        
        /// <summary>
        /// Returns the indices that would sort an array.
        /// 
        /// Perform an indirect sort along the given axis using the algorithm specified
        /// by the kind keyword. It returns an array of indices of the same shape as
        /// a that index data along the given axis in sorted order.
        /// 
        /// Notes
        /// 
        /// See sort for notes on the different sorting algorithms.
        /// 
        /// As of NumPy 1.4.0 argsort works with real/complex arrays containing
        /// nan values. The enhanced sort order is documented in sort.
        /// </summary>
        /// <param name="axis">
        /// Axis along which to sort.  The default is -1 (the last axis). If None,
        /// the flattened array is used.
        /// </param>
        /// <param name="kind">
        /// Sorting algorithm.
        /// </param>
        /// <param name="order">
        /// When a is an array with fields defined, this argument specifies
        /// which fields to compare first, second, etc.  A single field can
        /// be specified as a string, and not all fields need be specified,
        /// but unspecified fields will still be used, in the order in which
        /// they come up in the dtype, to break ties.
        /// </param>
        /// <returns>
        /// Array of indices that sort a along the specified axis.
        /// If a is one-dimensional, a[index_array] yields a sorted a.
        /// More generally, np.take_along_axis(a, index_array, axis=a) always
        /// yields the sorted a, irrespective of dimensionality.
        /// </returns>
        public NDarray argsort(int? axis = null, string kind = null, string order = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.argsort(@this, axis:axis, kind:kind, order:order);
        }
        
        /// <summary>
        /// Return a copy of an array sorted along the first axis.
        /// 
        /// Notes
        /// 
        /// np.msort(a) is equivalent to  np.sort(a, axis=0).
        /// </summary>
        /// <returns>
        /// Array of the same type and shape as a.
        /// </returns>
        public NDarray msort()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.msort(@this);
        }
        
        /// <summary>
        /// Sort a complex array using the real part first, then the imaginary part.
        /// </summary>
        /// <returns>
        /// Always returns a sorted complex array.
        /// </returns>
        public NDarray sort_complex()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.sort_complex(@this);
        }
        
        /// <summary>
        /// Return a partitioned copy of an array.
        /// 
        /// Creates a copy of the array with its elements rearranged in such a
        /// way that the value of the element in k-th position is in the
        /// position it would be in a sorted array. All elements smaller than
        /// the k-th element are moved before this element and all equal or
        /// greater are moved behind it. The ordering of the elements in the two
        /// partitions is undefined.
        /// 
        /// Notes
        /// 
        /// The various selection algorithms are characterized by their average
        /// speed, worst case performance, work space size, and whether they are
        /// stable. A stable sort keeps items with the same key in the same
        /// relative order. The available algorithms have the following
        /// properties:
        /// 
        /// All the partition algorithms make temporary copies of the data when
        /// partitioning along any but the last axis.  Consequently,
        /// partitioning along the last axis is faster and uses less space than
        /// partitioning along any other axis.
        /// 
        /// The sort order for complex numbers is lexicographic. If both the
        /// real and imaginary parts are non-nan then the order is determined by
        /// the real parts except when they are equal, in which case the order
        /// is determined by the imaginary parts.
        /// </summary>
        /// <param name="kth">
        /// Element index to partition by. The k-th value of the element
        /// will be in its final sorted position and all smaller elements
        /// will be moved before it and all equal or greater elements behind
        /// it. The order of all elements in the partitions is undefined. If
        /// provided with a sequence of k-th it will partition all elements
        /// indexed by k-th  of them into their sorted position at once.
        /// </param>
        /// <param name="axis">
        /// Axis along which to sort. If None, the array is flattened before
        /// sorting. The default is -1, which sorts along the last axis.
        /// </param>
        /// <param name="kind">
        /// Selection algorithm. Default is ‘introselect’.
        /// </param>
        /// <param name="order">
        /// When a is an array with fields defined, this argument
        /// specifies which fields to compare first, second, etc.  A single
        /// field can be specified as a string.  Not all fields need be
        /// specified, but unspecified fields will still be used, in the
        /// order in which they come up in the dtype, to break ties.
        /// </param>
        /// <returns>
        /// Array of the same type and shape as a.
        /// </returns>
        public NDarray partition(int[] kth, int? axis = null, string kind = null, string order = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.partition(@this, kth, axis:axis, kind:kind, order:order);
        }
        
        /// <summary>
        /// Perform an indirect partition along the given axis using the
        /// algorithm specified by the kind keyword. It returns an array of
        /// indices of the same shape as a that index data along the given
        /// axis in partitioned order.
        /// 
        /// Notes
        /// 
        /// See partition for notes on the different selection algorithms.
        /// </summary>
        /// <param name="kth">
        /// Element index to partition by. The k-th element will be in its
        /// final sorted position and all smaller elements will be moved
        /// before it and all larger elements behind it. The order all
        /// elements in the partitions is undefined. If provided with a
        /// sequence of k-th it will partition all of them into their sorted
        /// position at once.
        /// </param>
        /// <param name="axis">
        /// Axis along which to sort. The default is -1 (the last axis). If
        /// None, the flattened array is used.
        /// </param>
        /// <param name="kind">
        /// Selection algorithm. Default is ‘introselect’
        /// </param>
        /// <param name="order">
        /// When a is an array with fields defined, this argument
        /// specifies which fields to compare first, second, etc. A single
        /// field can be specified as a string, and not all fields need be
        /// specified, but unspecified fields will still be used, in the
        /// order in which they come up in the dtype, to break ties.
        /// </param>
        /// <returns>
        /// Array of indices that partition a along the specified axis.
        /// If a is one-dimensional, a[index_array] yields a partitioned a.
        /// More generally, np.take_along_axis(a, index_array, axis=a) always
        /// yields the partitioned a, irrespective of dimensionality.
        /// </returns>
        public NDarray argpartition(int[] kth, int? axis = null, string kind = null, string order = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.argpartition(@this, kth, axis:axis, kind:kind, order:order);
        }
        
        /// <summary>
        /// Returns the indices of the maximum values along an axis.
        /// 
        /// Notes
        /// 
        /// In case of multiple occurrences of the maximum values, the indices
        /// corresponding to the first occurrence are returned.
        /// </summary>
        /// <param name="axis">
        /// By default, the index is into the flattened array, otherwise
        /// along the specified axis.
        /// </param>
        /// <param name="@out">
        /// If provided, the result will be inserted into this array. It should
        /// be of the appropriate shape and dtype.
        /// </param>
        /// <returns>
        /// Array of indices into the array. It has the same shape as a.shape
        /// with the dimension along axis removed.
        /// </returns>
        public NDarray argmax(int? axis = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.argmax(@this, axis:axis, @out:@out);
        }
        
        /// <summary>
        /// Return the indices of the maximum values in the specified axis ignoring
        /// NaNs. For all-NaN slices ValueError is raised. Warning: the
        /// results cannot be trusted if a slice contains only NaNs and -Infs.
        /// </summary>
        /// <param name="axis">
        /// Axis along which to operate.  By default flattened input is used.
        /// </param>
        /// <returns>
        /// An array of indices or a single index value.
        /// </returns>
        public NDarray nanargmax(int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanargmax(@this, axis:axis);
        }
        
        /// <summary>
        /// Returns the indices of the minimum values along an axis.
        /// 
        /// Notes
        /// 
        /// In case of multiple occurrences of the minimum values, the indices
        /// corresponding to the first occurrence are returned.
        /// </summary>
        /// <param name="axis">
        /// By default, the index is into the flattened array, otherwise
        /// along the specified axis.
        /// </param>
        /// <param name="@out">
        /// If provided, the result will be inserted into this array. It should
        /// be of the appropriate shape and dtype.
        /// </param>
        /// <returns>
        /// Array of indices into the array. It has the same shape as a.shape
        /// with the dimension along axis removed.
        /// </returns>
        public NDarray argmin(int? axis = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.argmin(@this, axis:axis, @out:@out);
        }
        
        /// <summary>
        /// Return the indices of the minimum values in the specified axis ignoring
        /// NaNs. For all-NaN slices ValueError is raised. Warning: the results
        /// cannot be trusted if a slice contains only NaNs and Infs.
        /// </summary>
        /// <param name="axis">
        /// Axis along which to operate.  By default flattened input is used.
        /// </param>
        /// <returns>
        /// An array of indices or a single index value.
        /// </returns>
        public NDarray nanargmin(int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanargmin(@this, axis:axis);
        }
        
        /// <summary>
        /// Find the indices of array elements that are non-zero, grouped by element.
        /// 
        /// Notes
        /// 
        /// np.argwhere(a) is the same as np.transpose(np.nonzero(a)).
        /// 
        /// The output of argwhere is not suitable for indexing arrays.
        /// For this purpose use nonzero(a) instead.
        /// </summary>
        /// <returns>
        /// Indices of elements that are non-zero. Indices are grouped by element.
        /// </returns>
        public NDarray argwhere()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.argwhere(@this);
        }
        
        /// <summary>
        /// Return the indices of the elements that are non-zero.
        /// 
        /// Returns a tuple of arrays, one for each dimension of a,
        /// containing the indices of the non-zero elements in that
        /// dimension. The values in a are always tested and returned in
        /// row-major, C-style order. The corresponding non-zero
        /// values can be obtained with:
        /// 
        /// To group the indices by element, rather than dimension, use:
        /// 
        /// The result of this is always a 2-D array, with a row for
        /// each non-zero element.
        /// </summary>
        /// <returns>
        /// Indices of elements that are non-zero.
        /// </returns>
        public NDarray[] nonzero()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nonzero(@this);
        }
        
        /// <summary>
        /// Return indices that are non-zero in the flattened version of a.
        /// 
        /// This is equivalent to np.nonzero(np.ravel(a))[0].
        /// </summary>
        /// <returns>
        /// Output array, containing the indices of the elements of a.ravel()
        /// that are non-zero.
        /// </returns>
        public NDarray flatnonzero()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.flatnonzero(@this);
        }
        
        /// <summary>
        /// Return elements chosen from x or y depending on condition.
        /// 
        /// Notes
        /// 
        /// If all the arrays are 1-D, where is equivalent to:
        /// </summary>
        /// <param name="y">
        /// Values from which to choose. x, y and condition need to be
        /// broadcastable to some shape.
        /// </param>
        /// <param name="x">
        /// Values from which to choose. x, y and condition need to be
        /// broadcastable to some shape.
        /// </param>
        /// <returns>
        /// An array with elements from x where condition is True, and elements
        /// from y elsewhere.
        /// </returns>
        public NDarray @where(NDarray y, NDarray x)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.@where(@this, y, x);
        }
        
        /// <summary>
        /// Find indices where elements should be inserted to maintain order.
        /// 
        /// Find the indices into a sorted array a such that, if the
        /// corresponding elements in v were inserted before the indices, the
        /// order of a would be preserved.
        /// 
        /// Assuming that a is sorted:
        /// 
        /// Notes
        /// 
        /// Binary search is used to find the required insertion points.
        /// 
        /// As of NumPy 1.4.0 searchsorted works with real/complex arrays containing
        /// nan values. The enhanced sort order is documented in sort.
        /// 
        /// This function is a faster version of the builtin python bisect.bisect_left
        /// (side='left') and bisect.bisect_right (side='right') functions,
        /// which is also vectorized in the v argument.
        /// </summary>
        /// <param name="v">
        /// Values to insert into a.
        /// </param>
        /// <param name="side">
        /// If ‘left’, the index of the first suitable location found is given.
        /// If ‘right’, return the last such index.  If there is no suitable
        /// index, return either 0 or N (where N is the length of a).
        /// </param>
        /// <param name="sorter">
        /// Optional array of integer indices that sort array a into ascending
        /// order. They are typically the result of argsort.
        /// </param>
        /// <returns>
        /// Array of insertion points with the same shape as v.
        /// </returns>
        public NDarray<int> searchsorted(NDarray v, string side = null, NDarray sorter = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.searchsorted(@this, v, side:side, sorter:sorter);
        }
        
        /// <summary>
        /// Return the elements of an array that satisfy some condition.
        /// 
        /// This is equivalent to np.compress(ravel(condition), ravel(arr)).  If
        /// condition is boolean np.extract is equivalent to arr[condition].
        /// 
        /// Note that place does the exact opposite of extract.
        /// </summary>
        /// <param name="arr">
        /// Input array of the same size as condition.
        /// </param>
        /// <returns>
        /// Rank 1 array of values from arr where condition is True.
        /// </returns>
        public NDarray extract(NDarray arr)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.extract(@this, arr);
        }
        
        /// <summary>
        /// Counts the number of non-zero values in the array a.
        /// 
        /// The word “non-zero” is in reference to the Python 2.x
        /// built-in method __nonzero__() (renamed __bool__()
        /// in Python 3.x) of Python objects that tests an object’s
        /// “truthfulness”. For example, any number is considered
        /// truthful if it is nonzero, whereas any string is considered
        /// truthful if it is not the empty string. Thus, this function
        /// (recursively) counts how many elements in a (and in
        /// sub-arrays thereof) have their __nonzero__() or __bool__()
        /// method evaluated to True.
        /// </summary>
        /// <param name="axis">
        /// Axis or tuple of axes along which to count non-zeros.
        /// Default is None, meaning that non-zeros will be counted
        /// along a flattened version of a.
        /// </param>
        /// <returns>
        /// Number of non-zero values in the array along a given axis.
        /// Otherwise, the total number of non-zero values in the array
        /// is returned.
        /// </returns>
        public NDarray<int> count_nonzero(int[] axis)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.count_nonzero(@this, axis:axis);
        }
        
        /// <summary>
        /// Counts the number of non-zero values in the array a.
        /// 
        /// The word “non-zero” is in reference to the Python 2.x
        /// built-in method __nonzero__() (renamed __bool__()
        /// in Python 3.x) of Python objects that tests an object’s
        /// “truthfulness”. For example, any number is considered
        /// truthful if it is nonzero, whereas any string is considered
        /// truthful if it is not the empty string. Thus, this function
        /// (recursively) counts how many elements in a (and in
        /// sub-arrays thereof) have their __nonzero__() or __bool__()
        /// method evaluated to True.
        /// </summary>
        /// <returns>
        /// Number of non-zero values in the array along a given axis.
        /// Otherwise, the total number of non-zero values in the array
        /// is returned.
        /// </returns>
        public int count_nonzero()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.count_nonzero(@this);
        }
        
        /// <summary>
        /// Return the minimum of an array or minimum along an axis.
        /// 
        /// Notes
        /// 
        /// NaN values are propagated, that is if at least one item is NaN, the
        /// corresponding min value will be NaN as well. To ignore NaN values
        /// (MATLAB behavior), please use nanmin.
        /// 
        /// Don’t use amin for element-wise comparison of 2 arrays; when
        /// a.shape[0] is 2, minimum(a[0], a[1]) is faster than
        /// amin(a, axis=0).
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which to operate.  By default, flattened input is
        /// used.
        /// 
        /// If this is a tuple of ints, the minimum is selected over multiple axes,
        /// instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result.  Must
        /// be of the same shape and buffer length as the expected output.
        /// See doc.ufuncs (Section “Output arguments”) for more details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the amin method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <param name="initial">
        /// The maximum value of an output element. Must be present to allow
        /// computation on empty slice. See reduce for details.
        /// </param>
        /// <returns>
        /// Minimum of a. If axis is None, the result is a scalar value.
        /// If axis is given, the result is an array of dimension
        /// a.ndim - 1.
        /// </returns>
        public NDarray amin(int[] axis = null, NDarray @out = null, bool? keepdims = null, ValueType initial = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.amin(@this, axis:axis, @out:@out, keepdims:keepdims, initial:initial);
        }
        
        /// <summary>
        /// Return the maximum of an array or maximum along an axis.
        /// 
        /// Notes
        /// 
        /// NaN values are propagated, that is if at least one item is NaN, the
        /// corresponding max value will be NaN as well. To ignore NaN values
        /// (MATLAB behavior), please use nanmax.
        /// 
        /// Don’t use amax for element-wise comparison of 2 arrays; when
        /// a.shape[0] is 2, maximum(a[0], a[1]) is faster than
        /// amax(a, axis=0).
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which to operate.  By default, flattened input is
        /// used.
        /// 
        /// If this is a tuple of ints, the maximum is selected over multiple axes,
        /// instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result.  Must
        /// be of the same shape and buffer length as the expected output.
        /// See doc.ufuncs (Section “Output arguments”) for more details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the amax method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <param name="initial">
        /// The minimum value of an output element. Must be present to allow
        /// computation on empty slice. See reduce for details.
        /// </param>
        /// <returns>
        /// Maximum of a. If axis is None, the result is a scalar value.
        /// If axis is given, the result is an array of dimension
        /// a.ndim - 1.
        /// </returns>
        public NDarray amax(int[] axis = null, NDarray @out = null, bool? keepdims = null, ValueType initial = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.amax(@this, axis:axis, @out:@out, keepdims:keepdims, initial:initial);
        }
        
        /// <summary>
        /// Return minimum of an array or minimum along an axis, ignoring any NaNs.
        /// When all-NaN slices are encountered a RuntimeWarning is raised and
        /// Nan is returned for that slice.
        /// 
        /// Notes
        /// 
        /// NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
        /// (IEEE 754). This means that Not a Number is not equivalent to infinity.
        /// Positive infinity is treated as a very large number and negative
        /// infinity is treated as a very small (i.e. negative) number.
        /// 
        /// If the input has a integer type the function is equivalent to np.min.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the minimum is computed. The default is to compute
        /// the minimum of the flattened array.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None; if provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.  See
        /// doc.ufuncs for details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// 
        /// If the value is anything but the default, then
        /// keepdims will be passed through to the min method
        /// of sub-classes of ndarray.  If the sub-classes methods
        /// does not implement keepdims any exceptions will be raised.
        /// </param>
        /// <returns>
        /// An array with the same shape as a, with the specified axis
        /// removed.  If a is a 0-d array, or if axis is None, an ndarray
        /// scalar is returned.  The same dtype as a is returned.
        /// </returns>
        public NDarray nanmin(int[] axis = null, NDarray @out = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanmin(@this, axis:axis, @out:@out, keepdims:keepdims);
        }
        
        /// <summary>
        /// Return the maximum of an array or maximum along an axis, ignoring any
        /// NaNs.  When all-NaN slices are encountered a RuntimeWarning is
        /// raised and NaN is returned for that slice.
        /// 
        /// Notes
        /// 
        /// NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
        /// (IEEE 754). This means that Not a Number is not equivalent to infinity.
        /// Positive infinity is treated as a very large number and negative
        /// infinity is treated as a very small (i.e. negative) number.
        /// 
        /// If the input has a integer type the function is equivalent to np.max.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the maximum is computed. The default is to compute
        /// the maximum of the flattened array.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None; if provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.  See
        /// doc.ufuncs for details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// 
        /// If the value is anything but the default, then
        /// keepdims will be passed through to the max method
        /// of sub-classes of ndarray.  If the sub-classes methods
        /// does not implement keepdims any exceptions will be raised.
        /// </param>
        /// <returns>
        /// An array with the same shape as a, with the specified axis removed.
        /// If a is a 0-d array, or if axis is None, an ndarray scalar is
        /// returned.  The same dtype as a is returned.
        /// </returns>
        public NDarray nanmax(int[] axis = null, NDarray @out = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanmax(@this, axis:axis, @out:@out, keepdims:keepdims);
        }
        
        /// <summary>
        /// Range of values (maximum - minimum) along an axis.
        /// 
        /// The name of the function comes from the acronym for ‘peak to peak’.
        /// </summary>
        /// <param name="axis">
        /// Axis along which to find the peaks.  By default, flatten the
        /// array.  axis may be negative, in
        /// which case it counts from the last to the first axis.
        /// 
        /// If this is a tuple of ints, a reduction is performed on multiple
        /// axes, instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type of the output values will be cast if necessary.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the ptp method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <returns>
        /// A new array holding the result, unless out was
        /// specified, in which case a reference to out is returned.
        /// </returns>
        public NDarray ptp(int[] axis = null, NDarray @out = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.ptp(@this, axis:axis, @out:@out, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the q-th percentile of the data along the specified axis.
        /// 
        /// Returns the q-th percentile(s) of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the q-th percentile of
        /// V is the value q/100 of the way from the minimum to the
        /// maximum in a sorted copy of V. The values and distances of
        /// the two nearest neighbors as well as the interpolation parameter
        /// will determine the percentile if the normalized ranking does not
        /// match the location of q exactly. This function is the same as
        /// the median if q=50, the same as the minimum if q=0 and the
        /// same as the maximum if q=100.
        /// </summary>
        /// <param name="q">
        /// Percentile or sequence of percentiles to compute, which must be between
        /// 0 and 100 inclusive.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the percentiles are computed. The
        /// default is to compute the percentile(s) along a flattened
        /// version of the array.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired percentile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left in
        /// the result as dimensions with size one. With this option, the
        /// result will broadcast correctly against the original array a.
        /// </param>
        /// <returns>
        /// If q is a single percentile and axis=None, then the result
        /// is a scalar. If multiple percentiles are given, first axis of
        /// the result corresponds to the percentiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public NDarray<double> percentile(NDarray<float> q, int[] axis, NDarray @out = null, bool? overwrite_input = null, string interpolation = "linear", bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.percentile(@this, q, axis:axis, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the q-th percentile of the data along the specified axis.
        /// 
        /// Returns the q-th percentile(s) of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the q-th percentile of
        /// V is the value q/100 of the way from the minimum to the
        /// maximum in a sorted copy of V. The values and distances of
        /// the two nearest neighbors as well as the interpolation parameter
        /// will determine the percentile if the normalized ranking does not
        /// match the location of q exactly. This function is the same as
        /// the median if q=50, the same as the minimum if q=0 and the
        /// same as the maximum if q=100.
        /// </summary>
        /// <param name="q">
        /// Percentile or sequence of percentiles to compute, which must be between
        /// 0 and 100 inclusive.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired percentile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <returns>
        /// If q is a single percentile and axis=None, then the result
        /// is a scalar. If multiple percentiles are given, first axis of
        /// the result corresponds to the percentiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public double percentile(NDarray<float> q, NDarray @out = null, bool? overwrite_input = null, string interpolation = "linear")
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.percentile(@this, q, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation);
        }
        
        /// <summary>
        /// Compute the qth percentile of the data along the specified axis,
        /// while ignoring nan values.
        /// 
        /// Returns the qth percentile(s) of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the q-th percentile of
        /// V is the value q/100 of the way from the minimum to the
        /// maximum in a sorted copy of V. The values and distances of
        /// the two nearest neighbors as well as the interpolation parameter
        /// will determine the percentile if the normalized ranking does not
        /// match the location of q exactly. This function is the same as
        /// the median if q=50, the same as the minimum if q=0 and the
        /// same as the maximum if q=100.
        /// </summary>
        /// <param name="q">
        /// Percentile or sequence of percentiles to compute, which must be between
        /// 0 and 100 inclusive.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the percentiles are computed. The
        /// default is to compute the percentile(s) along a flattened
        /// version of the array.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired percentile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left in
        /// the result as dimensions with size one. With this option, the
        /// result will broadcast correctly against the original array a.
        /// 
        /// If this is anything but the default value it will be passed
        /// through (in the special case of an empty array) to the
        /// mean function of the underlying array.  If the array is
        /// a sub-class and mean does not have the kwarg keepdims this
        /// will raise a RuntimeError.
        /// </param>
        /// <returns>
        /// If q is a single percentile and axis=None, then the result
        /// is a scalar. If multiple percentiles are given, first axis of
        /// the result corresponds to the percentiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public NDarray<double> nanpercentile(NDarray<float> q, int[] axis, NDarray @out = null, bool? overwrite_input = null, string interpolation = "linear", bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanpercentile(@this, q, axis:axis, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the qth percentile of the data along the specified axis,
        /// while ignoring nan values.
        /// 
        /// Returns the qth percentile(s) of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the q-th percentile of
        /// V is the value q/100 of the way from the minimum to the
        /// maximum in a sorted copy of V. The values and distances of
        /// the two nearest neighbors as well as the interpolation parameter
        /// will determine the percentile if the normalized ranking does not
        /// match the location of q exactly. This function is the same as
        /// the median if q=50, the same as the minimum if q=0 and the
        /// same as the maximum if q=100.
        /// </summary>
        /// <param name="q">
        /// Percentile or sequence of percentiles to compute, which must be between
        /// 0 and 100 inclusive.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired percentile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <returns>
        /// If q is a single percentile and axis=None, then the result
        /// is a scalar. If multiple percentiles are given, first axis of
        /// the result corresponds to the percentiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public double nanpercentile(NDarray<float> q, NDarray @out = null, bool? overwrite_input = null, string interpolation = "linear")
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanpercentile(@this, q, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation);
        }
        
        /// <summary>
        /// Compute the q-th quantile of the data along the specified axis.
        /// ..versionadded:: 1.15.0
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the q-th quantile of
        /// V is the value q of the way from the minimum to the
        /// maximum in a sorted copy of V. The values and distances of
        /// the two nearest neighbors as well as the interpolation parameter
        /// will determine the quantile if the normalized ranking does not
        /// match the location of q exactly. This function is the same as
        /// the median if q=0.5, the same as the minimum if q=0.0 and the
        /// same as the maximum if q=1.0.
        /// </summary>
        /// <param name="q">
        /// Quantile or sequence of quantiles to compute, which must be between
        /// 0 and 1 inclusive.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the quantiles are computed. The
        /// default is to compute the quantile(s) along a flattened
        /// version of the array.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired quantile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left in
        /// the result as dimensions with size one. With this option, the
        /// result will broadcast correctly against the original array a.
        /// </param>
        /// <returns>
        /// If q is a single quantile and axis=None, then the result
        /// is a scalar. If multiple quantiles are given, first axis of
        /// the result corresponds to the quantiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public NDarray<double> quantile(NDarray<float> q, int[] axis, NDarray @out = null, bool? overwrite_input = null, string interpolation = "linear", bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.quantile(@this, q, axis:axis, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the q-th quantile of the data along the specified axis.
        /// ..versionadded:: 1.15.0
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the q-th quantile of
        /// V is the value q of the way from the minimum to the
        /// maximum in a sorted copy of V. The values and distances of
        /// the two nearest neighbors as well as the interpolation parameter
        /// will determine the quantile if the normalized ranking does not
        /// match the location of q exactly. This function is the same as
        /// the median if q=0.5, the same as the minimum if q=0.0 and the
        /// same as the maximum if q=1.0.
        /// </summary>
        /// <param name="q">
        /// Quantile or sequence of quantiles to compute, which must be between
        /// 0 and 1 inclusive.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired quantile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <returns>
        /// If q is a single quantile and axis=None, then the result
        /// is a scalar. If multiple quantiles are given, first axis of
        /// the result corresponds to the quantiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public double quantile(NDarray<float> q, NDarray @out = null, bool? overwrite_input = null, string interpolation = "linear")
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.quantile(@this, q, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation);
        }
        
        /// <summary>
        /// Compute the qth quantile of the data along the specified axis,
        /// while ignoring nan values.
        /// Returns the qth quantile(s) of the array elements.
        /// .. versionadded:: 1.15.0
        /// </summary>
        /// <param name="q">
        /// Quantile or sequence of quantiles to compute, which must be between
        /// 0 and 1 inclusive.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the quantiles are computed. The
        /// default is to compute the quantile(s) along a flattened
        /// version of the array.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired quantile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left in
        /// the result as dimensions with size one. With this option, the
        /// result will broadcast correctly against the original array a.
        /// 
        /// If this is anything but the default value it will be passed
        /// through (in the special case of an empty array) to the
        /// mean function of the underlying array.  If the array is
        /// a sub-class and mean does not have the kwarg keepdims this
        /// will raise a RuntimeError.
        /// </param>
        /// <returns>
        /// If q is a single percentile and axis=None, then the result
        /// is a scalar. If multiple quantiles are given, first axis of
        /// the result corresponds to the quantiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public NDarray<double> nanquantile(NDarray<float> q, int[] axis, NDarray @out = null, bool? overwrite_input = null, string interpolation = "linear", bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanquantile(@this, q, axis:axis, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the qth quantile of the data along the specified axis,
        /// while ignoring nan values.
        /// Returns the qth quantile(s) of the array elements.
        /// .. versionadded:: 1.15.0
        /// </summary>
        /// <param name="q">
        /// Quantile or sequence of quantiles to compute, which must be between
        /// 0 and 1 inclusive.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired quantile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <returns>
        /// If q is a single percentile and axis=None, then the result
        /// is a scalar. If multiple quantiles are given, first axis of
        /// the result corresponds to the quantiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public double nanquantile(NDarray<float> q, NDarray @out = null, bool? overwrite_input = null, string interpolation = "linear")
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanquantile(@this, q, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation);
        }
        
        /// <summary>
        /// Compute the median along the specified axis.
        /// 
        /// Returns the median of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the median of V is the
        /// middle value of a sorted copy of V, V_sorted - i
        /// e., V_sorted[(N-1)/2], when N is odd, and the average of the
        /// two middle values of V_sorted when N is even.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the medians are computed. The default
        /// is to compute the median along a flattened version of the array.
        /// A sequence of axes is supported since version 1.9.0.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow use of memory of input array a for
        /// calculations. The input array will be modified by the call to
        /// median. This will save memory when you do not need to preserve
        /// the contents of the input array. Treat the input as undefined,
        /// but it will probably be fully or partially sorted. Default is
        /// False. If overwrite_input is True and a is not already an
        /// ndarray, an error will be raised.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original arr.
        /// </param>
        /// <returns>
        /// A new array holding the result. If the input contains integers
        /// or floats smaller than float64, then the output data-type is
        /// np.float64.  Otherwise, the data-type of the output is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public NDarray<double> median(int[] axis, NDarray @out = null, bool? overwrite_input = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.median(@this, axis:axis, @out:@out, overwrite_input:overwrite_input, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the median along the specified axis.
        /// 
        /// Returns the median of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the median of V is the
        /// middle value of a sorted copy of V, V_sorted - i
        /// e., V_sorted[(N-1)/2], when N is odd, and the average of the
        /// two middle values of V_sorted when N is even.
        /// </summary>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow use of memory of input array a for
        /// calculations. The input array will be modified by the call to
        /// median. This will save memory when you do not need to preserve
        /// the contents of the input array. Treat the input as undefined,
        /// but it will probably be fully or partially sorted. Default is
        /// False. If overwrite_input is True and a is not already an
        /// ndarray, an error will be raised.
        /// </param>
        /// <returns>
        /// A new array holding the result. If the input contains integers
        /// or floats smaller than float64, then the output data-type is
        /// np.float64.  Otherwise, the data-type of the output is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public double median(NDarray @out = null, bool? overwrite_input = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.median(@this, @out:@out, overwrite_input:overwrite_input);
        }
        
        /// <summary>
        /// Compute the weighted average along the specified axis.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which to average a.  The default,
        /// axis=None, will average over all of the elements of the input array.
        /// If axis is negative it counts from the last to the first axis.
        /// 
        /// If axis is a tuple of ints, averaging is performed on all of the axes
        /// specified in the tuple instead of a single axis or all the axes as
        /// before.
        /// </param>
        /// <param name="weights">
        /// An array of weights associated with the values in a. Each value in
        /// a contributes to the average according to its associated weight.
        /// The weights array can either be 1-D (in which case its length must be
        /// the size of a along the given axis) or of the same shape as a.
        /// If weights=None, then all data in a are assumed to have a
        /// weight equal to one.
        /// </param>
        /// <param name="returned">
        /// Default is False. If True, the tuple (average, sum_of_weights)
        /// is returned, otherwise only the average is returned.
        /// If weights=None, sum_of_weights is equivalent to the number of
        /// elements over which the average is taken.
        /// </param>
        /// <returns>
        /// Return the average along the specified axis. When returned is True,
        /// return a tuple with the average as the first element and the sum
        /// of the weights as the second element. sum_of_weights is of the
        /// same type as retval. The result dtype follows a genereal pattern.
        /// If weights is None, the result dtype will be that of a , or float64
        /// if a is integral. Otherwise, if weights is not None and a is non-
        /// integral, the result type will be the type of lowest precision capable of
        /// representing values of both a and weights. If a happens to be
        /// integral, the previous rules still applies but the result dtype will
        /// at least be float64.
        /// </returns>
        public NDarray<double> average(int[] axis, NDarray weights = null, bool? returned = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.average(@this, axis:axis, weights:weights, returned:returned);
        }
        
        /// <summary>
        /// Compute the weighted average along the specified axis.
        /// </summary>
        /// <param name="weights">
        /// An array of weights associated with the values in a. Each value in
        /// a contributes to the average according to its associated weight.
        /// The weights array can either be 1-D (in which case its length must be
        /// the size of a along the given axis) or of the same shape as a.
        /// If weights=None, then all data in a are assumed to have a
        /// weight equal to one.
        /// </param>
        /// <param name="returned">
        /// Default is False. If True, the tuple (average, sum_of_weights)
        /// is returned, otherwise only the average is returned.
        /// If weights=None, sum_of_weights is equivalent to the number of
        /// elements over which the average is taken.
        /// </param>
        /// <returns>
        /// Return the average along the specified axis. When returned is True,
        /// return a tuple with the average as the first element and the sum
        /// of the weights as the second element. sum_of_weights is of the
        /// same type as retval. The result dtype follows a genereal pattern.
        /// If weights is None, the result dtype will be that of a , or float64
        /// if a is integral. Otherwise, if weights is not None and a is non-
        /// integral, the result type will be the type of lowest precision capable of
        /// representing values of both a and weights. If a happens to be
        /// integral, the previous rules still applies but the result dtype will
        /// at least be float64.
        /// </returns>
        public double average(NDarray weights = null, bool? returned = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.average(@this, weights:weights, returned:returned);
        }
        
        /// <summary>
        /// Compute the arithmetic mean along the specified axis.
        /// 
        /// Returns the average of the array elements.  The average is taken over
        /// the flattened array by default, otherwise over the specified axis.
        /// float64 intermediate and return values are used for integer inputs.
        /// 
        /// Notes
        /// 
        /// The arithmetic mean is the sum of the elements along the axis divided
        /// by the number of elements.
        /// 
        /// Note that for floating-point input, the mean is computed using the
        /// same precision the input has.  Depending on the input data, this can
        /// cause the results to be inaccurate, especially for float32 (see
        /// example below).  Specifying a higher-precision accumulator using the
        /// dtype keyword can alleviate this issue.
        /// 
        /// By default, float16 results are computed using float32 intermediates
        /// for extra precision.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the means are computed. The default is to
        /// compute the mean of the flattened array.
        /// 
        /// If this is a tuple of ints, a mean is performed over multiple axes,
        /// instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the mean.  For integer inputs, the default
        /// is float64; for floating point inputs, it is the same as the
        /// input dtype.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None; if provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.
        /// See doc.ufuncs for details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the mean method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <returns>
        /// If out=None, returns a new array containing the mean values,
        /// otherwise a reference to the output array is returned.
        /// </returns>
        public NDarray<double> mean(int[] axis, Dtype dtype = null, NDarray @out = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.mean(@this, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the arithmetic mean along the specified axis.
        /// 
        /// Returns the average of the array elements.  The average is taken over
        /// the flattened array by default, otherwise over the specified axis.
        /// float64 intermediate and return values are used for integer inputs.
        /// 
        /// Notes
        /// 
        /// The arithmetic mean is the sum of the elements along the axis divided
        /// by the number of elements.
        /// 
        /// Note that for floating-point input, the mean is computed using the
        /// same precision the input has.  Depending on the input data, this can
        /// cause the results to be inaccurate, especially for float32 (see
        /// example below).  Specifying a higher-precision accumulator using the
        /// dtype keyword can alleviate this issue.
        /// 
        /// By default, float16 results are computed using float32 intermediates
        /// for extra precision.
        /// </summary>
        /// <param name="dtype">
        /// Type to use in computing the mean.  For integer inputs, the default
        /// is float64; for floating point inputs, it is the same as the
        /// input dtype.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None; if provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.
        /// See doc.ufuncs for details.
        /// </param>
        /// <returns>
        /// If out=None, returns a new array containing the mean values,
        /// otherwise a reference to the output array is returned.
        /// </returns>
        public double mean(Dtype dtype = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.mean(@this, dtype:dtype, @out:@out);
        }
        
        /// <summary>
        /// Compute the standard deviation along the specified axis.
        /// 
        /// Returns the standard deviation, a measure of the spread of a distribution,
        /// of the array elements. The standard deviation is computed for the
        /// flattened array by default, otherwise over the specified axis.
        /// 
        /// Notes
        /// 
        /// The standard deviation is the square root of the average of the squared
        /// deviations from the mean, i.e., std = sqrt(mean(abs(x - x.mean())**2)).
        /// 
        /// The average squared deviation is normally calculated as
        /// x.sum() / N, where N = len(x).  If, however, ddof is specified,
        /// the divisor N - ddof is used instead. In standard statistical
        /// practice, ddof=1 provides an unbiased estimator of the variance
        /// of the infinite population. ddof=0 provides a maximum likelihood
        /// estimate of the variance for normally distributed variables. The
        /// standard deviation computed in this function is the square root of
        /// the estimated variance, so even with ddof=1, it will not be an
        /// unbiased estimate of the standard deviation per se.
        /// 
        /// Note that, for complex numbers, std takes the absolute
        /// value before squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the std is computed using the same
        /// precision the input has. Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example below).
        /// Specifying a higher-accuracy accumulator using the dtype keyword can
        /// alleviate this issue.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the standard deviation is computed. The
        /// default is to compute the standard deviation of the flattened array.
        /// 
        /// If this is a tuple of ints, a standard deviation is performed over
        /// multiple axes, instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the standard deviation. For arrays of
        /// integer type the default is float64, for arrays of float types it is
        /// the same as the array type.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output but the type (of the calculated
        /// values) will be cast if necessary.
        /// </param>
        /// <param name="ddof">
        /// Means Delta Degrees of Freedom.  The divisor used in calculations
        /// is N - ddof, where N represents the number of elements.
        /// By default ddof is zero.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the std method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <returns>
        /// If out is None, return a new array containing the standard deviation,
        /// otherwise return a reference to the output array.
        /// </returns>
        public NDarray<double> std(int[] axis, Dtype dtype = null, NDarray @out = null, int? ddof = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.std(@this, axis:axis, dtype:dtype, @out:@out, ddof:ddof, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the standard deviation along the specified axis.
        /// 
        /// Returns the standard deviation, a measure of the spread of a distribution,
        /// of the array elements. The standard deviation is computed for the
        /// flattened array by default, otherwise over the specified axis.
        /// 
        /// Notes
        /// 
        /// The standard deviation is the square root of the average of the squared
        /// deviations from the mean, i.e., std = sqrt(mean(abs(x - x.mean())**2)).
        /// 
        /// The average squared deviation is normally calculated as
        /// x.sum() / N, where N = len(x).  If, however, ddof is specified,
        /// the divisor N - ddof is used instead. In standard statistical
        /// practice, ddof=1 provides an unbiased estimator of the variance
        /// of the infinite population. ddof=0 provides a maximum likelihood
        /// estimate of the variance for normally distributed variables. The
        /// standard deviation computed in this function is the square root of
        /// the estimated variance, so even with ddof=1, it will not be an
        /// unbiased estimate of the standard deviation per se.
        /// 
        /// Note that, for complex numbers, std takes the absolute
        /// value before squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the std is computed using the same
        /// precision the input has. Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example below).
        /// Specifying a higher-accuracy accumulator using the dtype keyword can
        /// alleviate this issue.
        /// </summary>
        /// <param name="dtype">
        /// Type to use in computing the standard deviation. For arrays of
        /// integer type the default is float64, for arrays of float types it is
        /// the same as the array type.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output but the type (of the calculated
        /// values) will be cast if necessary.
        /// </param>
        /// <param name="ddof">
        /// Means Delta Degrees of Freedom.  The divisor used in calculations
        /// is N - ddof, where N represents the number of elements.
        /// By default ddof is zero.
        /// </param>
        /// <returns>
        /// If out is None, return a new array containing the standard deviation,
        /// otherwise return a reference to the output array.
        /// </returns>
        public double std(Dtype dtype = null, NDarray @out = null, int? ddof = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.std(@this, dtype:dtype, @out:@out, ddof:ddof);
        }
        
        /// <summary>
        /// Compute the variance along the specified axis.
        /// 
        /// Returns the variance of the array elements, a measure of the spread of a
        /// distribution.  The variance is computed for the flattened array by
        /// default, otherwise over the specified axis.
        /// 
        /// Notes
        /// 
        /// The variance is the average of the squared deviations from the mean,
        /// i.e.,  var = mean(abs(x - x.mean())**2).
        /// 
        /// The mean is normally calculated as x.sum() / N, where N = len(x).
        /// If, however, ddof is specified, the divisor N - ddof is used
        /// instead.  In standard statistical practice, ddof=1 provides an
        /// unbiased estimator of the variance of a hypothetical infinite population.
        /// ddof=0 provides a maximum likelihood estimate of the variance for
        /// normally distributed variables.
        /// 
        /// Note that for complex numbers, the absolute value is taken before
        /// squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the variance is computed using the same
        /// precision the input has.  Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example
        /// below).  Specifying a higher-accuracy accumulator using the dtype
        /// keyword can alleviate this issue.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the variance is computed.  The default is to
        /// compute the variance of the flattened array.
        /// 
        /// If this is a tuple of ints, a variance is performed over multiple axes,
        /// instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the variance.  For arrays of integer type
        /// the default is float32; for arrays of float types it is the same as
        /// the array type.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  It must have
        /// the same shape as the expected output, but the type is cast if
        /// necessary.
        /// </param>
        /// <param name="ddof">
        /// “Delta Degrees of Freedom”: the divisor used in the calculation is
        /// N - ddof, where N represents the number of elements. By
        /// default ddof is zero.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the var method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <returns>
        /// If out=None, returns a new array containing the variance;
        /// otherwise, a reference to the output array is returned.
        /// </returns>
        public NDarray<double> @var(int[] axis, Dtype dtype = null, NDarray @out = null, int? ddof = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.@var(@this, axis:axis, dtype:dtype, @out:@out, ddof:ddof, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the variance along the specified axis.
        /// 
        /// Returns the variance of the array elements, a measure of the spread of a
        /// distribution.  The variance is computed for the flattened array by
        /// default, otherwise over the specified axis.
        /// 
        /// Notes
        /// 
        /// The variance is the average of the squared deviations from the mean,
        /// i.e.,  var = mean(abs(x - x.mean())**2).
        /// 
        /// The mean is normally calculated as x.sum() / N, where N = len(x).
        /// If, however, ddof is specified, the divisor N - ddof is used
        /// instead.  In standard statistical practice, ddof=1 provides an
        /// unbiased estimator of the variance of a hypothetical infinite population.
        /// ddof=0 provides a maximum likelihood estimate of the variance for
        /// normally distributed variables.
        /// 
        /// Note that for complex numbers, the absolute value is taken before
        /// squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the variance is computed using the same
        /// precision the input has.  Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example
        /// below).  Specifying a higher-accuracy accumulator using the dtype
        /// keyword can alleviate this issue.
        /// </summary>
        /// <param name="dtype">
        /// Type to use in computing the variance.  For arrays of integer type
        /// the default is float32; for arrays of float types it is the same as
        /// the array type.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  It must have
        /// the same shape as the expected output, but the type is cast if
        /// necessary.
        /// </param>
        /// <param name="ddof">
        /// “Delta Degrees of Freedom”: the divisor used in the calculation is
        /// N - ddof, where N represents the number of elements. By
        /// default ddof is zero.
        /// </param>
        /// <returns>
        /// If out=None, returns a new array containing the variance;
        /// otherwise, a reference to the output array is returned.
        /// </returns>
        public double @var(Dtype dtype = null, NDarray @out = null, int? ddof = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.@var(@this, dtype:dtype, @out:@out, ddof:ddof);
        }
        
        /// <summary>
        /// Compute the median along the specified axis, while ignoring NaNs.
        /// 
        /// Returns the median of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the median of V is the
        /// middle value of a sorted copy of V, V_sorted - i.e.,
        /// V_sorted[(N-1)/2], when N is odd and the average of the two
        /// middle values of V_sorted when N is even.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the medians are computed. The default
        /// is to compute the median along a flattened version of the array.
        /// A sequence of axes is supported since version 1.9.0.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow use of memory of input array a for
        /// calculations. The input array will be modified by the call to
        /// median. This will save memory when you do not need to preserve
        /// the contents of the input array. Treat the input as undefined,
        /// but it will probably be fully or partially sorted. Default is
        /// False. If overwrite_input is True and a is not already an
        /// ndarray, an error will be raised.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// 
        /// If this is anything but the default value it will be passed
        /// through (in the special case of an empty array) to the
        /// mean function of the underlying array.  If the array is
        /// a sub-class and mean does not have the kwarg keepdims this
        /// will raise a RuntimeError.
        /// </param>
        /// <returns>
        /// A new array holding the result. If the input contains integers
        /// or floats smaller than float64, then the output data-type is
        /// np.float64.  Otherwise, the data-type of the output is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public NDarray<double> nanmedian(int[] axis, NDarray @out = null, bool? overwrite_input = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanmedian(@this, axis:axis, @out:@out, overwrite_input:overwrite_input, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the median along the specified axis, while ignoring NaNs.
        /// 
        /// Returns the median of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the median of V is the
        /// middle value of a sorted copy of V, V_sorted - i.e.,
        /// V_sorted[(N-1)/2], when N is odd and the average of the two
        /// middle values of V_sorted when N is even.
        /// </summary>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow use of memory of input array a for
        /// calculations. The input array will be modified by the call to
        /// median. This will save memory when you do not need to preserve
        /// the contents of the input array. Treat the input as undefined,
        /// but it will probably be fully or partially sorted. Default is
        /// False. If overwrite_input is True and a is not already an
        /// ndarray, an error will be raised.
        /// </param>
        /// <returns>
        /// A new array holding the result. If the input contains integers
        /// or floats smaller than float64, then the output data-type is
        /// np.float64.  Otherwise, the data-type of the output is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public double nanmedian(NDarray @out = null, bool? overwrite_input = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanmedian(@this, @out:@out, overwrite_input:overwrite_input);
        }
        
        /// <summary>
        /// Compute the arithmetic mean along the specified axis, ignoring NaNs.
        /// 
        /// Returns the average of the array elements.  The average is taken over
        /// the flattened array by default, otherwise over the specified axis.
        /// float64 intermediate and return values are used for integer inputs.
        /// 
        /// For all-NaN slices, NaN is returned and a RuntimeWarning is raised.
        /// 
        /// Notes
        /// 
        /// The arithmetic mean is the sum of the non-NaN elements along the axis
        /// divided by the number of non-NaN elements.
        /// 
        /// Note that for floating-point input, the mean is computed using the same
        /// precision the input has.  Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32.  Specifying a
        /// higher-precision accumulator using the dtype keyword can alleviate
        /// this issue.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the means are computed. The default is to compute
        /// the mean of the flattened array.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the mean.  For integer inputs, the default
        /// is float64; for inexact inputs, it is the same as the input
        /// dtype.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None; if provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.  See
        /// doc.ufuncs for details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// 
        /// If the value is anything but the default, then
        /// keepdims will be passed through to the mean or sum methods
        /// of sub-classes of ndarray.  If the sub-classes methods
        /// does not implement keepdims any exceptions will be raised.
        /// </param>
        /// <returns>
        /// If out=None, returns a new array containing the mean values,
        /// otherwise a reference to the output array is returned. Nan is
        /// returned for slices that contain only NaNs.
        /// </returns>
        public NDarray<double> nanmean(int[] axis, Dtype dtype = null, NDarray @out = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanmean(@this, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the arithmetic mean along the specified axis, ignoring NaNs.
        /// 
        /// Returns the average of the array elements.  The average is taken over
        /// the flattened array by default, otherwise over the specified axis.
        /// float64 intermediate and return values are used for integer inputs.
        /// 
        /// For all-NaN slices, NaN is returned and a RuntimeWarning is raised.
        /// 
        /// Notes
        /// 
        /// The arithmetic mean is the sum of the non-NaN elements along the axis
        /// divided by the number of non-NaN elements.
        /// 
        /// Note that for floating-point input, the mean is computed using the same
        /// precision the input has.  Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32.  Specifying a
        /// higher-precision accumulator using the dtype keyword can alleviate
        /// this issue.
        /// </summary>
        /// <param name="dtype">
        /// Type to use in computing the mean.  For integer inputs, the default
        /// is float64; for inexact inputs, it is the same as the input
        /// dtype.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None; if provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.  See
        /// doc.ufuncs for details.
        /// </param>
        /// <returns>
        /// If out=None, returns a new array containing the mean values,
        /// otherwise a reference to the output array is returned. Nan is
        /// returned for slices that contain only NaNs.
        /// </returns>
        public double nanmean(Dtype dtype = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanmean(@this, dtype:dtype, @out:@out);
        }
        
        /// <summary>
        /// Compute the standard deviation along the specified axis, while
        /// ignoring NaNs.
        /// 
        /// Returns the standard deviation, a measure of the spread of a
        /// distribution, of the non-NaN array elements. The standard deviation is
        /// computed for the flattened array by default, otherwise over the
        /// specified axis.
        /// 
        /// For all-NaN slices or slices with zero degrees of freedom, NaN is
        /// returned and a RuntimeWarning is raised.
        /// 
        /// Notes
        /// 
        /// The standard deviation is the square root of the average of the squared
        /// deviations from the mean: std = sqrt(mean(abs(x - x.mean())**2)).
        /// 
        /// The average squared deviation is normally calculated as
        /// x.sum() / N, where N = len(x).  If, however, ddof is
        /// specified, the divisor N - ddof is used instead. In standard
        /// statistical practice, ddof=1 provides an unbiased estimator of the
        /// variance of the infinite population. ddof=0 provides a maximum
        /// likelihood estimate of the variance for normally distributed variables.
        /// The standard deviation computed in this function is the square root of
        /// the estimated variance, so even with ddof=1, it will not be an
        /// unbiased estimate of the standard deviation per se.
        /// 
        /// Note that, for complex numbers, std takes the absolute value before
        /// squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the std is computed using the same
        /// precision the input has. Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example
        /// below).  Specifying a higher-accuracy accumulator using the dtype
        /// keyword can alleviate this issue.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the standard deviation is computed. The default is
        /// to compute the standard deviation of the flattened array.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the standard deviation. For arrays of
        /// integer type the default is float64, for arrays of float types it
        /// is the same as the array type.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output but the type (of the
        /// calculated values) will be cast if necessary.
        /// </param>
        /// <param name="ddof">
        /// Means Delta Degrees of Freedom.  The divisor used in calculations
        /// is N - ddof, where N represents the number of non-NaN
        /// elements.  By default ddof is zero.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// 
        /// If this value is anything but the default it is passed through
        /// as-is to the relevant functions of the sub-classes.  If these
        /// functions do not have a keepdims kwarg, a RuntimeError will
        /// be raised.
        /// </param>
        /// <returns>
        /// If out is None, return a new array containing the standard
        /// deviation, otherwise return a reference to the output array. If
        /// ddof is &gt;= the number of non-NaN elements in a slice or the slice
        /// contains only NaNs, then the result for that slice is NaN.
        /// </returns>
        public NDarray<double> nanstd(int[] axis, Dtype dtype = null, NDarray @out = null, int? ddof = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanstd(@this, axis:axis, dtype:dtype, @out:@out, ddof:ddof, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the standard deviation along the specified axis, while
        /// ignoring NaNs.
        /// 
        /// Returns the standard deviation, a measure of the spread of a
        /// distribution, of the non-NaN array elements. The standard deviation is
        /// computed for the flattened array by default, otherwise over the
        /// specified axis.
        /// 
        /// For all-NaN slices or slices with zero degrees of freedom, NaN is
        /// returned and a RuntimeWarning is raised.
        /// 
        /// Notes
        /// 
        /// The standard deviation is the square root of the average of the squared
        /// deviations from the mean: std = sqrt(mean(abs(x - x.mean())**2)).
        /// 
        /// The average squared deviation is normally calculated as
        /// x.sum() / N, where N = len(x).  If, however, ddof is
        /// specified, the divisor N - ddof is used instead. In standard
        /// statistical practice, ddof=1 provides an unbiased estimator of the
        /// variance of the infinite population. ddof=0 provides a maximum
        /// likelihood estimate of the variance for normally distributed variables.
        /// The standard deviation computed in this function is the square root of
        /// the estimated variance, so even with ddof=1, it will not be an
        /// unbiased estimate of the standard deviation per se.
        /// 
        /// Note that, for complex numbers, std takes the absolute value before
        /// squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the std is computed using the same
        /// precision the input has. Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example
        /// below).  Specifying a higher-accuracy accumulator using the dtype
        /// keyword can alleviate this issue.
        /// </summary>
        /// <param name="dtype">
        /// Type to use in computing the standard deviation. For arrays of
        /// integer type the default is float64, for arrays of float types it
        /// is the same as the array type.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output but the type (of the
        /// calculated values) will be cast if necessary.
        /// </param>
        /// <param name="ddof">
        /// Means Delta Degrees of Freedom.  The divisor used in calculations
        /// is N - ddof, where N represents the number of non-NaN
        /// elements.  By default ddof is zero.
        /// </param>
        /// <returns>
        /// If out is None, return a new array containing the standard
        /// deviation, otherwise return a reference to the output array. If
        /// ddof is &gt;= the number of non-NaN elements in a slice or the slice
        /// contains only NaNs, then the result for that slice is NaN.
        /// </returns>
        public double nanstd(Dtype dtype = null, NDarray @out = null, int? ddof = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanstd(@this, dtype:dtype, @out:@out, ddof:ddof);
        }
        
        /// <summary>
        /// Compute the variance along the specified axis, while ignoring NaNs.
        /// 
        /// Returns the variance of the array elements, a measure of the spread of
        /// a distribution.  The variance is computed for the flattened array by
        /// default, otherwise over the specified axis.
        /// 
        /// For all-NaN slices or slices with zero degrees of freedom, NaN is
        /// returned and a RuntimeWarning is raised.
        /// 
        /// Notes
        /// 
        /// The variance is the average of the squared deviations from the mean,
        /// i.e.,  var = mean(abs(x - x.mean())**2).
        /// 
        /// The mean is normally calculated as x.sum() / N, where N = len(x).
        /// If, however, ddof is specified, the divisor N - ddof is used
        /// instead.  In standard statistical practice, ddof=1 provides an
        /// unbiased estimator of the variance of a hypothetical infinite
        /// population.  ddof=0 provides a maximum likelihood estimate of the
        /// variance for normally distributed variables.
        /// 
        /// Note that for complex numbers, the absolute value is taken before
        /// squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the variance is computed using the same
        /// precision the input has.  Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example
        /// below).  Specifying a higher-accuracy accumulator using the dtype
        /// keyword can alleviate this issue.
        /// 
        /// For this function to work on sub-classes of ndarray, they must define
        /// sum with the kwarg keepdims
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the variance is computed.  The default is to compute
        /// the variance of the flattened array.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the variance.  For arrays of integer type
        /// the default is float32; for arrays of float types it is the same as
        /// the array type.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  It must have
        /// the same shape as the expected output, but the type is cast if
        /// necessary.
        /// </param>
        /// <param name="ddof">
        /// “Delta Degrees of Freedom”: the divisor used in the calculation is
        /// N - ddof, where N represents the number of non-NaN
        /// elements. By default ddof is zero.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// </param>
        /// <returns>
        /// If out is None, return a new array containing the variance,
        /// otherwise return a reference to the output array. If ddof is &gt;= the
        /// number of non-NaN elements in a slice or the slice contains only
        /// NaNs, then the result for that slice is NaN.
        /// </returns>
        public NDarray<double> nanvar(int[] axis, Dtype dtype = null, NDarray @out = null, int? ddof = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanvar(@this, axis:axis, dtype:dtype, @out:@out, ddof:ddof, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the variance along the specified axis, while ignoring NaNs.
        /// 
        /// Returns the variance of the array elements, a measure of the spread of
        /// a distribution.  The variance is computed for the flattened array by
        /// default, otherwise over the specified axis.
        /// 
        /// For all-NaN slices or slices with zero degrees of freedom, NaN is
        /// returned and a RuntimeWarning is raised.
        /// 
        /// Notes
        /// 
        /// The variance is the average of the squared deviations from the mean,
        /// i.e.,  var = mean(abs(x - x.mean())**2).
        /// 
        /// The mean is normally calculated as x.sum() / N, where N = len(x).
        /// If, however, ddof is specified, the divisor N - ddof is used
        /// instead.  In standard statistical practice, ddof=1 provides an
        /// unbiased estimator of the variance of a hypothetical infinite
        /// population.  ddof=0 provides a maximum likelihood estimate of the
        /// variance for normally distributed variables.
        /// 
        /// Note that for complex numbers, the absolute value is taken before
        /// squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the variance is computed using the same
        /// precision the input has.  Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example
        /// below).  Specifying a higher-accuracy accumulator using the dtype
        /// keyword can alleviate this issue.
        /// 
        /// For this function to work on sub-classes of ndarray, they must define
        /// sum with the kwarg keepdims
        /// </summary>
        /// <param name="dtype">
        /// Type to use in computing the variance.  For arrays of integer type
        /// the default is float32; for arrays of float types it is the same as
        /// the array type.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  It must have
        /// the same shape as the expected output, but the type is cast if
        /// necessary.
        /// </param>
        /// <param name="ddof">
        /// “Delta Degrees of Freedom”: the divisor used in the calculation is
        /// N - ddof, where N represents the number of non-NaN
        /// elements. By default ddof is zero.
        /// </param>
        /// <returns>
        /// If out is None, return a new array containing the variance,
        /// otherwise return a reference to the output array. If ddof is &gt;= the
        /// number of non-NaN elements in a slice or the slice contains only
        /// NaNs, then the result for that slice is NaN.
        /// </returns>
        public double nanvar(Dtype dtype = null, NDarray @out = null, int? ddof = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanvar(@this, dtype:dtype, @out:@out, ddof:ddof);
        }
        
        /// <summary>
        /// Return Pearson product-moment correlation coefficients.
        /// 
        /// Please refer to the documentation for cov for more detail.  The
        /// relationship between the correlation coefficient matrix, R, and the
        /// covariance matrix, C, is
        /// 
        /// The values of R are between -1 and 1, inclusive.
        /// 
        /// Notes
        /// 
        /// Due to floating point rounding the resulting array may not be Hermitian,
        /// the diagonal elements may not be 1, and the elements may not satisfy the
        /// inequality abs(a) &lt;= 1. The real and imaginary parts are clipped to the
        /// interval [-1,  1] in an attempt to improve on that situation but is not
        /// much help in the complex case.
        /// 
        /// This function accepts but discards arguments bias and ddof.  This is
        /// for backwards compatibility with previous versions of this function.  These
        /// arguments had no effect on the return values of the function and can be
        /// safely ignored in this and previous versions of numpy.
        /// </summary>
        /// <param name="y">
        /// An additional set of variables and observations. y has the same
        /// shape as x.
        /// </param>
        /// <param name="rowvar">
        /// If rowvar is True (default), then each row represents a
        /// variable, with observations in the columns. Otherwise, the relationship
        /// is transposed: each column represents a variable, while the rows
        /// contain observations.
        /// </param>
        /// <returns>
        /// The correlation coefficient matrix of the variables.
        /// </returns>
        public NDarray corrcoef(NDarray y = null, bool? rowvar = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.corrcoef(@this, y:y, rowvar:rowvar);
        }
        
        /// <summary>
        /// Cross-correlation of two 1-dimensional sequences.
        /// 
        /// This function computes the correlation as generally defined in signal
        /// processing texts:
        /// 
        /// with a and v sequences being zero-padded where necessary and conj being
        /// the conjugate.
        /// 
        /// Notes
        /// 
        /// The definition of correlation above is not unique and sometimes correlation
        /// may be defined differently. Another common definition is:
        /// 
        /// which is related to c_{av}[k] by c'_{av}[k] = c_{av}[-k].
        /// </summary>
        /// <param name="a">
        /// Input sequences.
        /// </param>
        /// <param name="mode">
        /// Refer to the convolve docstring.  Note that the default
        /// is ‘valid’, unlike convolve, which uses ‘full’.
        /// </param>
        /// <returns>
        /// Discrete cross-correlation of a and v.
        /// </returns>
        public NDarray correlate(NDarray a, string mode = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.correlate(@this, a, mode:mode);
        }
        
        /// <summary>
        /// Estimate a covariance matrix, given data and weights.
        /// 
        /// Covariance indicates the level to which two variables vary together.
        /// If we examine N-dimensional samples, ,
        /// then the covariance matrix element  is the covariance of
        ///  and . The element  is the variance
        /// of .
        /// 
        /// See the notes for an outline of the algorithm.
        /// 
        /// Notes
        /// 
        /// Assume that the observations are in the columns of the observation
        /// array m and let f = fweights and a = aweights for brevity. The
        /// steps to compute the weighted covariance are as follows:
        /// 
        /// Note that when a == 1, the normalization factor
        /// v1 / (v1**2 - ddof * v2) goes over to 1 / (np.sum(f) - ddof)
        /// as it should.
        /// </summary>
        /// <param name="y">
        /// An additional set of variables and observations. y has the same form
        /// as that of m.
        /// </param>
        /// <param name="rowvar">
        /// If rowvar is True (default), then each row represents a
        /// variable, with observations in the columns. Otherwise, the relationship
        /// is transposed: each column represents a variable, while the rows
        /// contain observations.
        /// </param>
        /// <param name="bias">
        /// Default normalization (False) is by (N - 1), where N is the
        /// number of observations given (unbiased estimate). If bias is True,
        /// then normalization is by N. These values can be overridden by using
        /// the keyword ddof in numpy versions &gt;= 1.5.
        /// </param>
        /// <param name="ddof">
        /// If not None the default value implied by bias is overridden.
        /// Note that ddof=1 will return the unbiased estimate, even if both
        /// fweights and aweights are specified, and ddof=0 will return
        /// the simple average. See the notes for the details. The default value
        /// is None.
        /// </param>
        /// <param name="fweights">
        /// 1-D array of integer frequency weights; the number of times each
        /// observation vector should be repeated.
        /// </param>
        /// <param name="aweights">
        /// 1-D array of observation vector weights. These relative weights are
        /// typically large for observations considered “important” and smaller for
        /// observations considered less “important”. If ddof=0 the array of
        /// weights can be used to assign probabilities to observation vectors.
        /// </param>
        /// <returns>
        /// The covariance matrix of the variables.
        /// </returns>
        public NDarray cov(NDarray y = null, bool? rowvar = null, bool? bias = null, int? ddof = null, NDarray fweights = null, NDarray aweights = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.cov(@this, y:y, rowvar:rowvar, bias:bias, ddof:ddof, fweights:fweights, aweights:aweights);
        }
        
        /// <summary>
        /// Compute the histogram of a set of data.
        /// 
        /// Notes
        /// 
        /// All but the last (righthand-most) bin is half-open.  In other words,
        /// if bins is:
        /// 
        /// then the first bin is [1, 2) (including 1, but excluding 2) and
        /// the second [2, 3).  The last bin, however, is [3, 4], which
        /// includes 4.
        /// </summary>
        /// <param name="bins">
        /// If bins is an int, it defines the number of equal-width
        /// bins in the given range (10, by default). If bins is a
        /// sequence, it defines a monotonically increasing array of bin edges,
        /// including the rightmost edge, allowing for non-uniform bin widths.
        /// 
        /// If bins is a string, it defines the method used to calculate the
        /// optimal bin width, as defined by histogram_bin_edges.
        /// </param>
        /// <param name="range">
        /// The lower and upper range of the bins.  If not provided, range
        /// is simply (a.min(), a.max()).  Values outside the range are
        /// ignored. The first element of the range must be less than or
        /// equal to the second. range affects the automatic bin
        /// computation as well. While bin width is computed to be optimal
        /// based on the actual data within range, the bin count will fill
        /// the entire range including portions containing no data.
        /// </param>
        /// <param name="normed">
        /// This is equivalent to the density argument, but produces incorrect
        /// results for unequal bin widths. It should not be used.
        /// </param>
        /// <param name="weights">
        /// An array of weights, of the same shape as a.  Each value in
        /// a only contributes its associated weight towards the bin count
        /// (instead of 1). If density is True, the weights are
        /// normalized, so that the integral of the density over the range
        /// remains 1.
        /// </param>
        /// <param name="density">
        /// If False, the result will contain the number of samples in
        /// each bin. If True, the result is the value of the
        /// probability density function at the bin, normalized such that
        /// the integral over the range is 1. Note that the sum of the
        /// histogram values will not be equal to 1 unless bins of unity
        /// width are chosen; it is not a probability mass function.
        /// 
        /// Overrides the normed keyword if given.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// hist
        /// The values of the histogram. See density and weights for a
        /// description of the possible semantics.
        /// bin_edges
        /// Return the bin edges (length(hist)+1).
        /// </returns>
        public (NDarray, NDarray) histogram(int? bins = null, (float, float)? range = null, bool? normed = null, NDarray weights = null, bool? density = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogram(@this, bins:bins, range:range, normed:normed, weights:weights, density:density);
        }
        
        /// <summary>
        /// Compute the histogram of a set of data.
        /// 
        /// Notes
        /// 
        /// All but the last (righthand-most) bin is half-open.  In other words,
        /// if bins is:
        /// 
        /// then the first bin is [1, 2) (including 1, but excluding 2) and
        /// the second [2, 3).  The last bin, however, is [3, 4], which
        /// includes 4.
        /// </summary>
        /// <param name="bins">
        /// If bins is an int, it defines the number of equal-width
        /// bins in the given range (10, by default). If bins is a
        /// sequence, it defines a monotonically increasing array of bin edges,
        /// including the rightmost edge, allowing for non-uniform bin widths.
        /// 
        /// If bins is a string, it defines the method used to calculate the
        /// optimal bin width, as defined by histogram_bin_edges.
        /// </param>
        /// <param name="range">
        /// The lower and upper range of the bins.  If not provided, range
        /// is simply (a.min(), a.max()).  Values outside the range are
        /// ignored. The first element of the range must be less than or
        /// equal to the second. range affects the automatic bin
        /// computation as well. While bin width is computed to be optimal
        /// based on the actual data within range, the bin count will fill
        /// the entire range including portions containing no data.
        /// </param>
        /// <param name="normed">
        /// This is equivalent to the density argument, but produces incorrect
        /// results for unequal bin widths. It should not be used.
        /// </param>
        /// <param name="weights">
        /// An array of weights, of the same shape as a.  Each value in
        /// a only contributes its associated weight towards the bin count
        /// (instead of 1). If density is True, the weights are
        /// normalized, so that the integral of the density over the range
        /// remains 1.
        /// </param>
        /// <param name="density">
        /// If False, the result will contain the number of samples in
        /// each bin. If True, the result is the value of the
        /// probability density function at the bin, normalized such that
        /// the integral over the range is 1. Note that the sum of the
        /// histogram values will not be equal to 1 unless bins of unity
        /// width are chosen; it is not a probability mass function.
        /// 
        /// Overrides the normed keyword if given.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// hist
        /// The values of the histogram. See density and weights for a
        /// description of the possible semantics.
        /// bin_edges
        /// Return the bin edges (length(hist)+1).
        /// </returns>
        public (NDarray, NDarray) histogram(NDarray bins = null, (float, float)? range = null, bool? normed = null, NDarray weights = null, bool? density = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogram(@this, bins:bins, range:range, normed:normed, weights:weights, density:density);
        }
        
        /// <summary>
        /// Compute the histogram of a set of data.
        /// 
        /// Notes
        /// 
        /// All but the last (righthand-most) bin is half-open.  In other words,
        /// if bins is:
        /// 
        /// then the first bin is [1, 2) (including 1, but excluding 2) and
        /// the second [2, 3).  The last bin, however, is [3, 4], which
        /// includes 4.
        /// </summary>
        /// <param name="bins">
        /// If bins is an int, it defines the number of equal-width
        /// bins in the given range (10, by default). If bins is a
        /// sequence, it defines a monotonically increasing array of bin edges,
        /// including the rightmost edge, allowing for non-uniform bin widths.
        /// 
        /// If bins is a string, it defines the method used to calculate the
        /// optimal bin width, as defined by histogram_bin_edges.
        /// </param>
        /// <param name="range">
        /// The lower and upper range of the bins.  If not provided, range
        /// is simply (a.min(), a.max()).  Values outside the range are
        /// ignored. The first element of the range must be less than or
        /// equal to the second. range affects the automatic bin
        /// computation as well. While bin width is computed to be optimal
        /// based on the actual data within range, the bin count will fill
        /// the entire range including portions containing no data.
        /// </param>
        /// <param name="normed">
        /// This is equivalent to the density argument, but produces incorrect
        /// results for unequal bin widths. It should not be used.
        /// </param>
        /// <param name="weights">
        /// An array of weights, of the same shape as a.  Each value in
        /// a only contributes its associated weight towards the bin count
        /// (instead of 1). If density is True, the weights are
        /// normalized, so that the integral of the density over the range
        /// remains 1.
        /// </param>
        /// <param name="density">
        /// If False, the result will contain the number of samples in
        /// each bin. If True, the result is the value of the
        /// probability density function at the bin, normalized such that
        /// the integral over the range is 1. Note that the sum of the
        /// histogram values will not be equal to 1 unless bins of unity
        /// width are chosen; it is not a probability mass function.
        /// 
        /// Overrides the normed keyword if given.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// hist
        /// The values of the histogram. See density and weights for a
        /// description of the possible semantics.
        /// bin_edges
        /// Return the bin edges (length(hist)+1).
        /// </returns>
        public (NDarray, NDarray) histogram(List<string> bins = null, (float, float)? range = null, bool? normed = null, NDarray weights = null, bool? density = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogram(@this, bins:bins, range:range, normed:normed, weights:weights, density:density);
        }
        
        /// <summary>
        /// Compute the bi-dimensional histogram of two data samples.
        /// 
        /// Notes
        /// 
        /// When normed is True, then the returned histogram is the sample
        /// density, defined such that the sum over bins of the product
        /// bin_value * bin_area is 1.
        /// 
        /// Please note that the histogram does not follow the Cartesian convention
        /// where x values are on the abscissa and y values on the ordinate
        /// axis.  Rather, x is histogrammed along the first dimension of the
        /// array (vertical), and y along the second dimension of the array
        /// (horizontal).  This ensures compatibility with histogramdd.
        /// </summary>
        /// <param name="y">
        /// An array containing the y coordinates of the points to be
        /// histogrammed.
        /// </param>
        /// <param name="bins">
        /// The bin specification:
        /// </param>
        /// <param name="range">
        /// The leftmost and rightmost edges of the bins along each dimension
        /// (if not specified explicitly in the bins parameters):
        /// [[xmin, xmax], [ymin, ymax]]. All values outside of this range
        /// will be considered outliers and not tallied in the histogram.
        /// </param>
        /// <param name="density">
        /// If False, the default, returns the number of samples in each bin.
        /// If True, returns the probability density function at the bin,
        /// bin_count / sample_count / bin_area.
        /// </param>
        /// <param name="normed">
        /// An alias for the density argument that behaves identically. To avoid
        /// confusion with the broken normed argument to histogram, density
        /// should be preferred.
        /// </param>
        /// <param name="weights">
        /// An array of values w_i weighing each sample (x_i, y_i).
        /// Weights are normalized to 1 if normed is True. If normed is
        /// False, the values of the returned histogram are equal to the sum of
        /// the weights belonging to the samples falling into each bin.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// H
        /// The bi-dimensional histogram of samples x and y. Values in x
        /// are histogrammed along the first dimension and values in y are
        /// histogrammed along the second dimension.
        /// xedges
        /// The bin edges along the first dimension.
        /// yedges
        /// The bin edges along the second dimension.
        /// </returns>
        public (NDarray, NDarray, NDarray) histogram2d(NDarray y, int? bins = null, (float, float)? range = null, bool? density = null, bool? normed = null, NDarray weights = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogram2d(@this, y, bins:bins, range:range, density:density, normed:normed, weights:weights);
        }
        
        /// <summary>
        /// Compute the bi-dimensional histogram of two data samples.
        /// 
        /// Notes
        /// 
        /// When normed is True, then the returned histogram is the sample
        /// density, defined such that the sum over bins of the product
        /// bin_value * bin_area is 1.
        /// 
        /// Please note that the histogram does not follow the Cartesian convention
        /// where x values are on the abscissa and y values on the ordinate
        /// axis.  Rather, x is histogrammed along the first dimension of the
        /// array (vertical), and y along the second dimension of the array
        /// (horizontal).  This ensures compatibility with histogramdd.
        /// </summary>
        /// <param name="y">
        /// An array containing the y coordinates of the points to be
        /// histogrammed.
        /// </param>
        /// <param name="bins">
        /// The bin specification:
        /// </param>
        /// <param name="range">
        /// The leftmost and rightmost edges of the bins along each dimension
        /// (if not specified explicitly in the bins parameters):
        /// [[xmin, xmax], [ymin, ymax]]. All values outside of this range
        /// will be considered outliers and not tallied in the histogram.
        /// </param>
        /// <param name="density">
        /// If False, the default, returns the number of samples in each bin.
        /// If True, returns the probability density function at the bin,
        /// bin_count / sample_count / bin_area.
        /// </param>
        /// <param name="normed">
        /// An alias for the density argument that behaves identically. To avoid
        /// confusion with the broken normed argument to histogram, density
        /// should be preferred.
        /// </param>
        /// <param name="weights">
        /// An array of values w_i weighing each sample (x_i, y_i).
        /// Weights are normalized to 1 if normed is True. If normed is
        /// False, the values of the returned histogram are equal to the sum of
        /// the weights belonging to the samples falling into each bin.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// H
        /// The bi-dimensional histogram of samples x and y. Values in x
        /// are histogrammed along the first dimension and values in y are
        /// histogrammed along the second dimension.
        /// xedges
        /// The bin edges along the first dimension.
        /// yedges
        /// The bin edges along the second dimension.
        /// </returns>
        public (NDarray, NDarray, NDarray) histogram2d(NDarray y, NDarray bins = null, (float, float)? range = null, bool? density = null, bool? normed = null, NDarray weights = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogram2d(@this, y, bins:bins, range:range, density:density, normed:normed, weights:weights);
        }
        
        /// <summary>
        /// Compute the bi-dimensional histogram of two data samples.
        /// 
        /// Notes
        /// 
        /// When normed is True, then the returned histogram is the sample
        /// density, defined such that the sum over bins of the product
        /// bin_value * bin_area is 1.
        /// 
        /// Please note that the histogram does not follow the Cartesian convention
        /// where x values are on the abscissa and y values on the ordinate
        /// axis.  Rather, x is histogrammed along the first dimension of the
        /// array (vertical), and y along the second dimension of the array
        /// (horizontal).  This ensures compatibility with histogramdd.
        /// </summary>
        /// <param name="y">
        /// An array containing the y coordinates of the points to be
        /// histogrammed.
        /// </param>
        /// <param name="bins">
        /// The bin specification:
        /// </param>
        /// <param name="range">
        /// The leftmost and rightmost edges of the bins along each dimension
        /// (if not specified explicitly in the bins parameters):
        /// [[xmin, xmax], [ymin, ymax]]. All values outside of this range
        /// will be considered outliers and not tallied in the histogram.
        /// </param>
        /// <param name="density">
        /// If False, the default, returns the number of samples in each bin.
        /// If True, returns the probability density function at the bin,
        /// bin_count / sample_count / bin_area.
        /// </param>
        /// <param name="normed">
        /// An alias for the density argument that behaves identically. To avoid
        /// confusion with the broken normed argument to histogram, density
        /// should be preferred.
        /// </param>
        /// <param name="weights">
        /// An array of values w_i weighing each sample (x_i, y_i).
        /// Weights are normalized to 1 if normed is True. If normed is
        /// False, the values of the returned histogram are equal to the sum of
        /// the weights belonging to the samples falling into each bin.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// H
        /// The bi-dimensional histogram of samples x and y. Values in x
        /// are histogrammed along the first dimension and values in y are
        /// histogrammed along the second dimension.
        /// xedges
        /// The bin edges along the first dimension.
        /// yedges
        /// The bin edges along the second dimension.
        /// </returns>
        public (NDarray, NDarray, NDarray) histogram2d(NDarray y, List<string> bins = null, (float, float)? range = null, bool? density = null, bool? normed = null, NDarray weights = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogram2d(@this, y, bins:bins, range:range, density:density, normed:normed, weights:weights);
        }
        
        /// <summary>
        /// Compute the multidimensional histogram of some data.
        /// </summary>
        /// <param name="bins">
        /// The bin specification:
        /// </param>
        /// <param name="range">
        /// A sequence of length D, each an optional (lower, upper) tuple giving
        /// the outer bin edges to be used if the edges are not given explicitly in
        /// bins.
        /// An entry of None in the sequence results in the minimum and maximum
        /// values being used for the corresponding dimension.
        /// The default, None, is equivalent to passing a tuple of D None values.
        /// </param>
        /// <param name="density">
        /// If False, the default, returns the number of samples in each bin.
        /// If True, returns the probability density function at the bin,
        /// bin_count / sample_count / bin_volume.
        /// </param>
        /// <param name="normed">
        /// An alias for the density argument that behaves identically. To avoid
        /// confusion with the broken normed argument to histogram, density
        /// should be preferred.
        /// </param>
        /// <param name="weights">
        /// An array of values w_i weighing each sample (x_i, y_i, z_i, …).
        /// Weights are normalized to 1 if normed is True. If normed is False,
        /// the values of the returned histogram are equal to the sum of the
        /// weights belonging to the samples falling into each bin.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// H
        /// The multidimensional histogram of sample x. See normed and weights
        /// for the different possible semantics.
        /// edges
        /// A list of D arrays describing the bin edges for each dimension.
        /// </returns>
        public (NDarray, NDarray) histogramdd(int? bins = null, (float, float)? range = null, bool? density = null, bool? normed = null, NDarray weights = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogramdd(@this, bins:bins, range:range, density:density, normed:normed, weights:weights);
        }
        
        /// <summary>
        /// Compute the multidimensional histogram of some data.
        /// </summary>
        /// <param name="bins">
        /// The bin specification:
        /// </param>
        /// <param name="range">
        /// A sequence of length D, each an optional (lower, upper) tuple giving
        /// the outer bin edges to be used if the edges are not given explicitly in
        /// bins.
        /// An entry of None in the sequence results in the minimum and maximum
        /// values being used for the corresponding dimension.
        /// The default, None, is equivalent to passing a tuple of D None values.
        /// </param>
        /// <param name="density">
        /// If False, the default, returns the number of samples in each bin.
        /// If True, returns the probability density function at the bin,
        /// bin_count / sample_count / bin_volume.
        /// </param>
        /// <param name="normed">
        /// An alias for the density argument that behaves identically. To avoid
        /// confusion with the broken normed argument to histogram, density
        /// should be preferred.
        /// </param>
        /// <param name="weights">
        /// An array of values w_i weighing each sample (x_i, y_i, z_i, …).
        /// Weights are normalized to 1 if normed is True. If normed is False,
        /// the values of the returned histogram are equal to the sum of the
        /// weights belonging to the samples falling into each bin.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// H
        /// The multidimensional histogram of sample x. See normed and weights
        /// for the different possible semantics.
        /// edges
        /// A list of D arrays describing the bin edges for each dimension.
        /// </returns>
        public (NDarray, NDarray) histogramdd(NDarray bins = null, (float, float)? range = null, bool? density = null, bool? normed = null, NDarray weights = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogramdd(@this, bins:bins, range:range, density:density, normed:normed, weights:weights);
        }
        
        /// <summary>
        /// Compute the multidimensional histogram of some data.
        /// </summary>
        /// <param name="bins">
        /// The bin specification:
        /// </param>
        /// <param name="range">
        /// A sequence of length D, each an optional (lower, upper) tuple giving
        /// the outer bin edges to be used if the edges are not given explicitly in
        /// bins.
        /// An entry of None in the sequence results in the minimum and maximum
        /// values being used for the corresponding dimension.
        /// The default, None, is equivalent to passing a tuple of D None values.
        /// </param>
        /// <param name="density">
        /// If False, the default, returns the number of samples in each bin.
        /// If True, returns the probability density function at the bin,
        /// bin_count / sample_count / bin_volume.
        /// </param>
        /// <param name="normed">
        /// An alias for the density argument that behaves identically. To avoid
        /// confusion with the broken normed argument to histogram, density
        /// should be preferred.
        /// </param>
        /// <param name="weights">
        /// An array of values w_i weighing each sample (x_i, y_i, z_i, …).
        /// Weights are normalized to 1 if normed is True. If normed is False,
        /// the values of the returned histogram are equal to the sum of the
        /// weights belonging to the samples falling into each bin.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// H
        /// The multidimensional histogram of sample x. See normed and weights
        /// for the different possible semantics.
        /// edges
        /// A list of D arrays describing the bin edges for each dimension.
        /// </returns>
        public (NDarray, NDarray) histogramdd(List<string> bins = null, (float, float)? range = null, bool? density = null, bool? normed = null, NDarray weights = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogramdd(@this, bins:bins, range:range, density:density, normed:normed, weights:weights);
        }
        
        /// <summary>
        /// Count number of occurrences of each value in array of non-negative ints.
        /// 
        /// The number of bins (of size 1) is one larger than the largest value in
        /// x. If minlength is specified, there will be at least this number
        /// of bins in the output array (though it will be longer if necessary,
        /// depending on the contents of x).
        /// Each bin gives the number of occurrences of its index value in x.
        /// If weights is specified the input array is weighted by it, i.e. if a
        /// value n is found at position i, out[n] += weight[i] instead
        /// of out[n] += 1.
        /// </summary>
        /// <param name="weights">
        /// Weights, array of the same shape as x.
        /// </param>
        /// <param name="minlength">
        /// A minimum number of bins for the output array.
        /// </param>
        /// <returns>
        /// The result of binning the input array.
        /// The length of out is equal to np.amax(x)+1.
        /// </returns>
        public NDarray bincount(NDarray weights = null, int? minlength = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.bincount(@this, weights:weights, minlength:minlength);
        }
        
        /// <summary>
        /// Function to calculate only the edges of the bins used by the histogram function.
        /// 
        /// Notes
        /// 
        /// The methods to estimate the optimal number of bins are well founded
        /// in literature, and are inspired by the choices R provides for
        /// histogram visualisation. Note that having the number of bins
        /// proportional to  is asymptotically optimal, which is
        /// why it appears in most estimators. These are simply plug-in methods
        /// that give good starting points for number of bins. In the equations
        /// below,  is the binwidth and  is the number of
        /// bins. All estimators that compute bin counts are recast to bin width
        /// using the ptp of the data. The final bin count is obtained from
        /// np.round(np.ceil(range / h)).
        /// </summary>
        /// <param name="bins">
        /// If bins is an int, it defines the number of equal-width
        /// bins in the given range (10, by default). If bins is a
        /// sequence, it defines the bin edges, including the rightmost
        /// edge, allowing for non-uniform bin widths.
        /// 
        /// If bins is a string from the list below, histogram_bin_edges will use
        /// the method chosen to calculate the optimal bin width and
        /// consequently the number of bins (see Notes for more detail on
        /// the estimators) from the data that falls within the requested
        /// range. While the bin width will be optimal for the actual data
        /// in the range, the number of bins will be computed to fill the
        /// entire range, including the empty portions. For visualisation,
        /// using the ‘auto’ option is suggested. Weighted data is not
        /// supported for automated bin size selection.
        /// </param>
        /// <param name="range">
        /// The lower and upper range of the bins.  If not provided, range
        /// is simply (a.min(), a.max()).  Values outside the range are
        /// ignored. The first element of the range must be less than or
        /// equal to the second. range affects the automatic bin
        /// computation as well. While bin width is computed to be optimal
        /// based on the actual data within range, the bin count will fill
        /// the entire range including portions containing no data.
        /// </param>
        /// <param name="weights">
        /// An array of weights, of the same shape as a.  Each value in
        /// a only contributes its associated weight towards the bin count
        /// (instead of 1). This is currently not used by any of the bin estimators,
        /// but may be in the future.
        /// </param>
        /// <returns>
        /// The edges to pass into histogram
        /// </returns>
        public NDarray<float> histogram_bin_edges(int? bins = null, (float, float)? range = null, NDarray weights = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogram_bin_edges(@this, bins:bins, range:range, weights:weights);
        }
        
        /// <summary>
        /// Function to calculate only the edges of the bins used by the histogram function.
        /// 
        /// Notes
        /// 
        /// The methods to estimate the optimal number of bins are well founded
        /// in literature, and are inspired by the choices R provides for
        /// histogram visualisation. Note that having the number of bins
        /// proportional to  is asymptotically optimal, which is
        /// why it appears in most estimators. These are simply plug-in methods
        /// that give good starting points for number of bins. In the equations
        /// below,  is the binwidth and  is the number of
        /// bins. All estimators that compute bin counts are recast to bin width
        /// using the ptp of the data. The final bin count is obtained from
        /// np.round(np.ceil(range / h)).
        /// </summary>
        /// <param name="bins">
        /// If bins is an int, it defines the number of equal-width
        /// bins in the given range (10, by default). If bins is a
        /// sequence, it defines the bin edges, including the rightmost
        /// edge, allowing for non-uniform bin widths.
        /// 
        /// If bins is a string from the list below, histogram_bin_edges will use
        /// the method chosen to calculate the optimal bin width and
        /// consequently the number of bins (see Notes for more detail on
        /// the estimators) from the data that falls within the requested
        /// range. While the bin width will be optimal for the actual data
        /// in the range, the number of bins will be computed to fill the
        /// entire range, including the empty portions. For visualisation,
        /// using the ‘auto’ option is suggested. Weighted data is not
        /// supported for automated bin size selection.
        /// </param>
        /// <param name="range">
        /// The lower and upper range of the bins.  If not provided, range
        /// is simply (a.min(), a.max()).  Values outside the range are
        /// ignored. The first element of the range must be less than or
        /// equal to the second. range affects the automatic bin
        /// computation as well. While bin width is computed to be optimal
        /// based on the actual data within range, the bin count will fill
        /// the entire range including portions containing no data.
        /// </param>
        /// <param name="weights">
        /// An array of weights, of the same shape as a.  Each value in
        /// a only contributes its associated weight towards the bin count
        /// (instead of 1). This is currently not used by any of the bin estimators,
        /// but may be in the future.
        /// </param>
        /// <returns>
        /// The edges to pass into histogram
        /// </returns>
        public NDarray<float> histogram_bin_edges(NDarray bins = null, (float, float)? range = null, NDarray weights = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogram_bin_edges(@this, bins:bins, range:range, weights:weights);
        }
        
        /// <summary>
        /// Function to calculate only the edges of the bins used by the histogram function.
        /// 
        /// Notes
        /// 
        /// The methods to estimate the optimal number of bins are well founded
        /// in literature, and are inspired by the choices R provides for
        /// histogram visualisation. Note that having the number of bins
        /// proportional to  is asymptotically optimal, which is
        /// why it appears in most estimators. These are simply plug-in methods
        /// that give good starting points for number of bins. In the equations
        /// below,  is the binwidth and  is the number of
        /// bins. All estimators that compute bin counts are recast to bin width
        /// using the ptp of the data. The final bin count is obtained from
        /// np.round(np.ceil(range / h)).
        /// </summary>
        /// <param name="bins">
        /// If bins is an int, it defines the number of equal-width
        /// bins in the given range (10, by default). If bins is a
        /// sequence, it defines the bin edges, including the rightmost
        /// edge, allowing for non-uniform bin widths.
        /// 
        /// If bins is a string from the list below, histogram_bin_edges will use
        /// the method chosen to calculate the optimal bin width and
        /// consequently the number of bins (see Notes for more detail on
        /// the estimators) from the data that falls within the requested
        /// range. While the bin width will be optimal for the actual data
        /// in the range, the number of bins will be computed to fill the
        /// entire range, including the empty portions. For visualisation,
        /// using the ‘auto’ option is suggested. Weighted data is not
        /// supported for automated bin size selection.
        /// </param>
        /// <param name="range">
        /// The lower and upper range of the bins.  If not provided, range
        /// is simply (a.min(), a.max()).  Values outside the range are
        /// ignored. The first element of the range must be less than or
        /// equal to the second. range affects the automatic bin
        /// computation as well. While bin width is computed to be optimal
        /// based on the actual data within range, the bin count will fill
        /// the entire range including portions containing no data.
        /// </param>
        /// <param name="weights">
        /// An array of weights, of the same shape as a.  Each value in
        /// a only contributes its associated weight towards the bin count
        /// (instead of 1). This is currently not used by any of the bin estimators,
        /// but may be in the future.
        /// </param>
        /// <returns>
        /// The edges to pass into histogram
        /// </returns>
        public NDarray<float> histogram_bin_edges(List<string> bins = null, (float, float)? range = null, NDarray weights = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogram_bin_edges(@this, bins:bins, range:range, weights:weights);
        }
        
        /// <summary>
        /// Return the indices of the bins to which each value in input array belongs.
        /// 
        /// If values in x are beyond the bounds of bins, 0 or len(bins) is
        /// returned as appropriate.
        /// 
        /// Notes
        /// 
        /// If values in x are such that they fall outside the bin range,
        /// attempting to index bins with the indices that digitize returns
        /// will result in an IndexError.
        /// 
        /// np.digitize is  implemented in terms of np.searchsorted. This means
        /// that a binary search is used to bin the values, which scales much better
        /// for larger number of bins than the previous linear search. It also removes
        /// the requirement for the input array to be 1-dimensional.
        /// 
        /// For monotonically _increasing_ bins, the following are equivalent:
        /// 
        /// Note that as the order of the arguments are reversed, the side must be too.
        /// The searchsorted call is marginally faster, as it does not do any
        /// monotonicity checks. Perhaps more importantly, it supports all dtypes.
        /// </summary>
        /// <param name="bins">
        /// Array of bins. It has to be 1-dimensional and monotonic.
        /// </param>
        /// <param name="right">
        /// Indicating whether the intervals include the right or the left bin
        /// edge. Default behavior is (right==False) indicating that the interval
        /// does not include the right edge. The left bin end is open in this
        /// case, i.e., bins[i-1] &lt;= x &lt; bins[i] is the default behavior for
        /// monotonically increasing bins.
        /// </param>
        /// <returns>
        /// Output array of indices, of same shape as x.
        /// </returns>
        public NDarray digitize(NDarray bins, bool? right = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.digitize(@this, bins, right:right);
        }
        
    }
}
