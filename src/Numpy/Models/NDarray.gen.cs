// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Python.Runtime;
using Python.Included;
using Numpy.Models;

namespace Numpy
{
    public partial class NDarray
    {
        
        /// <summary>
        /// Copy an element of an array to a standard Python scalar and return it.
        /// 
        /// Notes
        /// 
        /// When the data type of a is longdouble or clongdouble, item() returns
        /// a scalar array object because there is no available Python scalar that
        /// would not lose information. Void arrays return a buffer object for item(),
        /// unless fields are defined, in which case a tuple is returned.
        /// 
        /// item is very similar to a[args], except, instead of an array scalar,
        /// a standard Python scalar is returned. This can be useful for speeding up
        /// access to elements of the array and doing arithmetic on elements of the
        /// array using Python’s optimized math.
        /// </summary>
        /// <returns>
        /// A copy of the specified element of the array as a suitable
        /// Python scalar
        /// </returns>
        public T item<T>(params int[] args)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                args,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("item", pyargs, kwargs);
            return ToCsharp<T>(py);
        }
        
        /// <summary>
        /// Return the array as a (possibly nested) list.
        /// 
        /// Return a copy of the array data as a (nested) Python list.
        /// Data items are converted to the nearest compatible Python type.
        /// 
        /// Notes
        /// 
        /// The array may be recreated, a = np.array(a.tolist()).
        /// </summary>
        /// <returns>
        /// The possibly nested list of array elements.
        /// </returns>
        public List<T> tolist<T>()
        {
            //auto-generated code, do not change
            var __self__=self;
            dynamic py = __self__.InvokeMethod("tolist");
            return ToCsharp<List<T>>(py);
        }
        
        /// <summary>
        /// Write array to a file as text or binary (default).
        /// 
        /// Data is always written in ‘C’ order, independent of the order of a.
        /// The data produced by this method can be recovered using the function
        /// fromfile().
        /// 
        /// Notes
        /// 
        /// This is a convenience function for quick storage of array data.
        /// Information on endianness and precision is lost, so this method is not a
        /// good choice for files intended to archive data or transport data between
        /// machines with different endianness. Some of these problems can be overcome
        /// by outputting the data as text files, at the expense of speed and file
        /// size.
        /// 
        /// When fid is a file object, array contents are directly written to the
        /// file, bypassing the file object’s write method. As a result, tofile
        /// cannot be used with files objects supporting compression (e.g., GzipFile)
        /// or file-like objects that do not support fileno() (e.g., BytesIO).
        /// </summary>
        /// <param name="fid">
        /// An open file object, or a string containing a filename.
        /// </param>
        /// <param name="sep">
        /// Separator between array items for text output.
        /// If “” (empty), a binary file is written, equivalent to
        /// file.write(a.tobytes()).
        /// </param>
        /// <param name="format">
        /// Format string for text file output.
        /// Each entry in the array is formatted to text by first converting
        /// it to the closest Python type, and then using “format” % item.
        /// </param>
        public void tofile(string fid, string sep, string format)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                fid,
                sep,
                format,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("tofile", pyargs, kwargs);
        }
        
        /// <summary>
        /// Dump a pickle of the array to the specified file.
        /// The array can be read back with pickle.load or numpy.load.
        /// </summary>
        /// <param name="file">
        /// A string naming the dump file.
        /// </param>
        public void dump(string file)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                file,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("dump", pyargs, kwargs);
        }
        
        /// <summary>
        /// Returns the pickle of the array as a string.
        /// pickle.loads or numpy.loads will convert the string back to an array.
        /// </summary>
        public void dumps()
        {
            //auto-generated code, do not change
            var __self__=self;
            dynamic py = __self__.InvokeMethod("dumps");
        }
        
        /// <summary>
        /// Copy of the array, cast to a specified type.
        /// 
        /// Notes
        /// 
        /// Starting in NumPy 1.9, astype method now returns an error if the string
        /// dtype to cast to is not long enough in ‘safe’ casting mode to hold the max
        /// value of integer/float array that is being casted. Previously the casting
        /// was allowed even if the result was truncated.
        /// </summary>
        /// <param name="dtype">
        /// Typecode or data-type to which the array is cast.
        /// </param>
        /// <param name="order">
        /// Controls the memory layout order of the result.
        /// ‘C’ means C order, ‘F’ means Fortran order, ‘A’
        /// means ‘F’ order if all the arrays are Fortran contiguous,
        /// ‘C’ order otherwise, and ‘K’ means as close to the
        /// order the array elements appear in memory as possible.
        /// Default is ‘K’.
        /// </param>
        /// <param name="casting">
        /// Controls what kind of data casting may occur. Defaults to ‘unsafe’
        /// for backwards compatibility.
        /// </param>
        /// <param name="subok">
        /// If True, then sub-classes will be passed-through (default), otherwise
        /// the returned array will be forced to be a base-class array.
        /// </param>
        /// <param name="copy">
        /// By default, astype always returns a newly allocated array. If this
        /// is set to false, and the dtype, order, and subok
        /// requirements are satisfied, the input array is returned instead
        /// of a copy.
        /// </param>
        /// <returns>
        /// Unless copy is False and the other conditions for returning the input
        /// array are satisfied (see description for copy input parameter), arr_t
        /// is a new array of the same shape as the input array, with dtype, order
        /// given by dtype, order.
        /// </returns>
        public NDarray astype(Dtype dtype, string order = null, string casting = null, bool? subok = null, bool? copy = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                dtype,
            });
            var kwargs=new PyDict();
            if (order!=null) kwargs["order"]=ToPython(order);
            if (casting!=null) kwargs["casting"]=ToPython(casting);
            if (subok!=null) kwargs["subok"]=ToPython(subok);
            if (copy!=null) kwargs["copy"]=ToPython(copy);
            dynamic py = __self__.InvokeMethod("astype", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Swap the bytes of the array elements
        /// 
        /// Toggle between low-endian and big-endian data representation by
        /// returning a byteswapped array, optionally swapped in-place.
        /// </summary>
        /// <param name="inplace">
        /// If True, swap bytes in-place, default is False.
        /// </param>
        /// <returns>
        /// The byteswapped array. If inplace is True, this is
        /// a view to self.
        /// </returns>
        public NDarray byteswap(bool? inplace = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (inplace!=null) kwargs["inplace"]=ToPython(inplace);
            dynamic py = __self__.InvokeMethod("byteswap", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Return a copy of the array.
        /// </summary>
        /// <param name="order">
        /// Controls the memory layout of the copy. ‘C’ means C-order,
        /// ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous,
        /// ‘C’ otherwise. ‘K’ means match the layout of a as closely
        /// as possible. (Note that this function and numpy.copy are very
        /// similar, but have different default values for their order=
        /// arguments.)
        /// </param>
        public void copy(string order = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (order!=null) kwargs["order"]=ToPython(order);
            dynamic py = __self__.InvokeMethod("copy", pyargs, kwargs);
        }
        
        /// <summary>
        /// Returns a field of the given array as a certain type.
        /// 
        /// A field is a view of the array data with a given data-type. The values in
        /// the view are determined by the given type and the offset into the current
        /// array in bytes. The offset needs to be such that the view dtype fits in the
        /// array dtype; for example an array of dtype complex128 has 16-byte elements.
        /// If taking a view with a 32-bit integer (4 bytes), the offset needs to be
        /// between 0 and 12 bytes.
        /// </summary>
        /// <param name="dtype">
        /// The data type of the view. The dtype size of the view can not be larger
        /// than that of the array itself.
        /// </param>
        /// <param name="offset">
        /// Number of bytes to skip before beginning the element view.
        /// </param>
        public void getfield(Dtype dtype, int offset)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                dtype,
                offset,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("getfield", pyargs, kwargs);
        }
        
        /// <summary>
        /// Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),
        /// respectively.
        /// 
        /// These Boolean-valued flags affect how numpy interprets the memory
        /// area used by a (see Notes below). The ALIGNED flag can only
        /// be set to True if the data is actually aligned according to the type.
        /// The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set
        /// to True. The flag WRITEABLE can only be set to True if the array owns its
        /// own memory, or the ultimate owner of the memory exposes a writeable buffer
        /// interface, or is a string. (The exception for string is made so that
        /// unpickling can be done without copying memory.)
        /// 
        /// Notes
        /// 
        /// Array flags provide information about how the memory area used
        /// for the array is to be interpreted. There are 7 Boolean flags
        /// in use, only four of which can be changed by the user:
        /// WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.
        /// 
        /// WRITEABLE (W) the data area can be written to;
        /// 
        /// ALIGNED (A) the data and strides are aligned appropriately for the hardware
        /// (as determined by the compiler);
        /// 
        /// UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;
        /// 
        /// WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced
        /// by .base). When the C-API function PyArray_ResolveWritebackIfCopy is
        /// called, the base array will be updated with the contents of this array.
        /// 
        /// All flags can be accessed using the single (upper case) letter as well
        /// as the full name.
        /// </summary>
        /// <param name="write">
        /// Describes whether or not a can be written to.
        /// </param>
        /// <param name="align">
        /// Describes whether or not a is aligned properly for its type.
        /// </param>
        /// <param name="uic">
        /// Describes whether or not a is a copy of another “base” array.
        /// </param>
        public void setflags(bool? write = null, bool? align = null, bool? uic = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (write!=null) kwargs["write"]=ToPython(write);
            if (align!=null) kwargs["align"]=ToPython(align);
            if (uic!=null) kwargs["uic"]=ToPython(uic);
            dynamic py = __self__.InvokeMethod("setflags", pyargs, kwargs);
        }
        
        /// <summary>
        /// Fill the array with a scalar value.
        /// </summary>
        /// <param name="@value">
        /// All elements of a will be assigned this value.
        /// </param>
        public void fill(ValueType @value)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                @value,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("fill", pyargs, kwargs);
        }
        
        /// <summary>
        /// Returns a view of the array with axes transposed.
        /// 
        /// For a 1-D array, this has no effect. (To change between column and
        /// row vectors, first cast the 1-D array into a matrix object.)
        /// For a 2-D array, this is the usual matrix transpose.
        /// For an n-D array, if axes are given, their order indicates how the
        /// axes are permuted (see Examples). If axes are not provided and
        /// a.shape = (i[0], i[1], ... i[n-2], i[n-1]), then
        /// a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0]).
        /// </summary>
        /// <returns>
        /// View of a, with axes suitably permuted.
        /// </returns>
        public NDarray transpose(int[] axes = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                axes,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("transpose", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Return a copy of the array collapsed into one dimension.
        /// </summary>
        /// <param name="order">
        /// ‘C’ means to flatten in row-major (C-style) order.
        /// ‘F’ means to flatten in column-major (Fortran-
        /// style) order. ‘A’ means to flatten in column-major
        /// order if a is Fortran contiguous in memory,
        /// row-major order otherwise. ‘K’ means to flatten
        /// a in the order the elements occur in memory.
        /// The default is ‘C’.
        /// </param>
        /// <returns>
        /// A copy of the input array, flattened to one dimension.
        /// </returns>
        public NDarray flatten(string order = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (order!=null) kwargs["order"]=ToPython(order);
            dynamic py = __self__.InvokeMethod("flatten", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Sort an array, in-place.
        /// 
        /// Notes
        /// 
        /// See sort for notes on the different sorting algorithms.
        /// </summary>
        /// <param name="axis">
        /// Axis along which to sort. Default is -1, which means sort along the
        /// last axis.
        /// </param>
        /// <param name="kind">
        /// Sorting algorithm. Default is ‘quicksort’.
        /// </param>
        /// <param name="order">
        /// When a is an array with fields defined, this argument specifies
        /// which fields to compare first, second, etc.  A single field can
        /// be specified as a string, and not all fields need be specified,
        /// but unspecified fields will still be used, in the order in which
        /// they come up in the dtype, to break ties.
        /// </param>
        public void sort(int? axis = null, string kind = null, string order = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (axis!=null) kwargs["axis"]=ToPython(axis);
            if (kind!=null) kwargs["kind"]=ToPython(kind);
            if (order!=null) kwargs["order"]=ToPython(order);
            dynamic py = __self__.InvokeMethod("sort", pyargs, kwargs);
        }
        
        /// <summary>
        /// Rearranges the elements in the array in such a way that the value of the
        /// element in kth position is in the position it would be in a sorted array.
        /// All elements smaller than the kth element are moved before this element and
        /// all equal or greater are moved behind it. The ordering of the elements in
        /// the two partitions is undefined.
        /// 
        /// Notes
        /// 
        /// See np.partition for notes on the different algorithms.
        /// </summary>
        /// <param name="kth">
        /// Element index to partition by. The kth element value will be in its
        /// final sorted position and all smaller elements will be moved before it
        /// and all equal or greater elements behind it.
        /// The order of all elements in the partitions is undefined.
        /// If provided with a sequence of kth it will partition all elements
        /// indexed by kth of them into their sorted position at once.
        /// </param>
        /// <param name="axis">
        /// Axis along which to sort. Default is -1, which means sort along the
        /// last axis.
        /// </param>
        /// <param name="kind">
        /// Selection algorithm. Default is ‘introselect’.
        /// </param>
        /// <param name="order">
        /// When a is an array with fields defined, this argument specifies
        /// which fields to compare first, second, etc. A single field can
        /// be specified as a string, and not all fields need to be specified,
        /// but unspecified fields will still be used, in the order in which
        /// they come up in the dtype, to break ties.
        /// </param>
        public void partition(int[] kth, int? axis = null, string kind = null, string order = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                kth,
            });
            var kwargs=new PyDict();
            if (axis!=null) kwargs["axis"]=ToPython(axis);
            if (kind!=null) kwargs["kind"]=ToPython(kind);
            if (order!=null) kwargs["order"]=ToPython(order);
            dynamic py = __self__.InvokeMethod("partition", pyargs, kwargs);
        }
        
        /// <summary>
        /// For unpickling.
        /// 
        /// The state argument must be a sequence that contains the following
        /// elements:
        /// </summary>
        /// <param name="version">
        /// optional pickle version. If omitted defaults to 0.
        /// </param>
        /// <param name="rawdata">
        /// a binary string with the data (or a list if ‘a’ is an object array)
        /// </param>
        public void __setstate__(int version, Shape shape, Dtype dtype, bool isFortran, string rawdata)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                version,
                shape,
                dtype,
                isFortran,
                rawdata,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("__setstate__", pyargs, kwargs);
        }
        
        /// <summary>
        /// Gives a new shape to an array without changing its data.
        /// 
        /// Notes
        /// 
        /// It is not always possible to change the shape of an array without
        /// copying the data. If you want an error to be raised when the data is copied,
        /// you should assign the new shape to the shape attribute of the array:
        /// 
        /// The order keyword gives the index ordering both for fetching the values
        /// from a, and then placing the values into the output array.
        /// For example, let’s say you have an array:
        /// 
        /// You can think of reshaping as first raveling the array (using the given
        /// index order), then inserting the elements from the raveled array into the
        /// new array using the same kind of index ordering as was used for the
        /// raveling.
        /// </summary>
        /// <param name="newshape">
        /// The new shape should be compatible with the original shape. If
        /// an integer, then the result will be a 1-D array of that length.
        /// One shape dimension can be -1. In this case, the value is
        /// inferred from the length of the array and remaining dimensions.
        /// </param>
        /// <param name="order">
        /// Read the elements of a using this index order, and place the
        /// elements into the reshaped array using this index order.  ‘C’
        /// means to read / write the elements using C-like index order,
        /// with the last axis index changing fastest, back to the first
        /// axis index changing slowest. ‘F’ means to read / write the
        /// elements using Fortran-like index order, with the first index
        /// changing fastest, and the last index changing slowest. Note that
        /// the ‘C’ and ‘F’ options take no account of the memory layout of
        /// the underlying array, and only refer to the order of indexing.
        /// ‘A’ means to read / write the elements in Fortran-like index
        /// order if a is Fortran contiguous in memory, C-like order
        /// otherwise.
        /// </param>
        /// <returns>
        /// This will be a new view object if possible; otherwise, it will
        /// be a copy.  Note there is no guarantee of the memory layout (C- or
        /// Fortran- contiguous) of the returned array.
        /// </returns>
        public NDarray reshape(Shape newshape, string order = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.reshape(@this, newshape, order:order);
        }
        
        /// <summary>
        /// Return a contiguous flattened array.
        /// 
        /// A 1-D array, containing the elements of the input, is returned.  A copy is
        /// made only if needed.
        /// 
        /// As of NumPy 1.10, the returned array will have the same type as the input
        /// array. (for example, a masked array will be returned for a masked array
        /// input)
        /// 
        /// Notes
        /// 
        /// In row-major, C-style order, in two dimensions, the row index
        /// varies the slowest, and the column index the quickest.  This can
        /// be generalized to multiple dimensions, where row-major order
        /// implies that the index along the first axis varies slowest, and
        /// the index along the last quickest.  The opposite holds for
        /// column-major, Fortran-style index ordering.
        /// 
        /// When a view is desired in as many cases as possible, arr.reshape(-1)
        /// may be preferable.
        /// </summary>
        /// <param name="order">
        /// The elements of a are read using this index order. ‘C’ means
        /// to index the elements in row-major, C-style order,
        /// with the last axis index changing fastest, back to the first
        /// axis index changing slowest.  ‘F’ means to index the elements
        /// in column-major, Fortran-style order, with the
        /// first index changing fastest, and the last index changing
        /// slowest. Note that the ‘C’ and ‘F’ options take no account of
        /// the memory layout of the underlying array, and only refer to
        /// the order of axis indexing.  ‘A’ means to read the elements in
        /// Fortran-like index order if a is Fortran contiguous in
        /// memory, C-like order otherwise.  ‘K’ means to read the
        /// elements in the order they occur in memory, except for
        /// reversing the data when strides are negative.  By default, ‘C’
        /// index order is used.
        /// </param>
        /// <returns>
        /// y is an array of the same subtype as a, with shape (a.size,).
        /// Note that matrices are special cased for backward compatibility, if a
        /// is a matrix, then y is a 1-D ndarray.
        /// </returns>
        public NDarray ravel(string order = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.ravel(@this, order:order);
        }
        
        /// <summary>
        /// Move axes of an array to new positions.
        /// 
        /// Other axes remain in their original order.
        /// </summary>
        /// <param name="source">
        /// Original positions of the axes to move. These must be unique.
        /// </param>
        /// <param name="destination">
        /// Destination positions for each of the original axes. These must also be
        /// unique.
        /// </param>
        /// <returns>
        /// Array with moved axes. This array is a view of the input array.
        /// </returns>
        public NDarray moveaxis(int[] source, int[] destination)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.moveaxis(@this, source, destination);
        }
        
        /// <summary>
        /// Roll the specified axis backwards, until it lies in a given position.
        /// 
        /// This function continues to be supported for backward compatibility, but you
        /// should prefer moveaxis. The moveaxis function was added in NumPy
        /// 1.11.
        /// </summary>
        /// <param name="axis">
        /// The axis to roll backwards.  The positions of the other axes do not
        /// change relative to one another.
        /// </param>
        /// <param name="start">
        /// The axis is rolled until it lies before this position.  The default,
        /// 0, results in a “complete” roll.
        /// </param>
        /// <returns>
        /// For NumPy &gt;= 1.10.0 a view of a is always returned. For earlier
        /// NumPy versions a view of a is returned only if the order of the
        /// axes is changed, otherwise the input array is returned.
        /// </returns>
        public NDarray rollaxis(int axis, int? start = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.rollaxis(@this, axis, start:start);
        }
        
        /// <summary>
        /// Interchange two axes of an array.
        /// </summary>
        /// <param name="axis1">
        /// First axis.
        /// </param>
        /// <param name="axis2">
        /// Second axis.
        /// </param>
        /// <returns>
        /// For NumPy &gt;= 1.10.0, if a is an ndarray, then a view of a is
        /// returned; otherwise a new array is created. For earlier NumPy
        /// versions a view of a is returned only if the order of the
        /// axes is changed, otherwise the input array is returned.
        /// </returns>
        public NDarray swapaxes(int axis1, int axis2)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.swapaxes(@this, axis1, axis2);
        }
        
        /// <summary>
        /// Broadcast an array to a new shape.
        /// 
        /// Notes
        /// </summary>
        /// <param name="shape">
        /// The shape of the desired array.
        /// </param>
        /// <param name="subok">
        /// If True, then sub-classes will be passed-through, otherwise
        /// the returned array will be forced to be a base-class array (default).
        /// </param>
        /// <returns>
        /// A readonly view on the original array with the given shape. It is
        /// typically not contiguous. Furthermore, more than one element of a
        /// broadcasted array may refer to a single memory location.
        /// </returns>
        public NDarray broadcast_to(Shape shape, bool? subok = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.broadcast_to(@this, shape, subok:subok);
        }
        
        /// <summary>
        /// Expand the shape of an array.
        /// 
        /// Insert a new axis that will appear at the axis position in the expanded
        /// array shape.
        /// </summary>
        /// <param name="axis">
        /// Position in the expanded axes where the new axis is placed.
        /// </param>
        /// <returns>
        /// Output array. The number of dimensions is one greater than that of
        /// the input array.
        /// </returns>
        public NDarray expand_dims(int axis)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.expand_dims(@this, axis);
        }
        
        /// <summary>
        /// Remove single-dimensional entries from the shape of an array.
        /// </summary>
        /// <param name="axis">
        /// Selects a subset of the single-dimensional entries in the
        /// shape. If an axis is selected with shape entry greater than
        /// one, an error is raised.
        /// </param>
        /// <returns>
        /// The input array, but with all or a subset of the
        /// dimensions of length 1 removed. This is always a itself
        /// or a view into a.
        /// </returns>
        public NDarray squeeze(int[] axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.squeeze(@this, axis:axis);
        }
        
        /// <summary>
        /// Return an array converted to a float type.
        /// </summary>
        /// <param name="dtype">
        /// Float type code to coerce input array a.  If dtype is one of the
        /// ‘int’ dtypes, it is replaced with float64.
        /// </param>
        /// <returns>
        /// The input a as a float ndarray.
        /// </returns>
        public NDarray asfarray(Dtype dtype = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.asfarray(@this, dtype:dtype);
        }
        
        /// <summary>
        /// Return an array (ndim &gt;= 1) laid out in Fortran order in memory.
        /// </summary>
        /// <param name="dtype">
        /// By default, the data-type is inferred from the input data.
        /// </param>
        /// <returns>
        /// The input a in Fortran, or column-major, order.
        /// </returns>
        public NDarray asfortranarray(Dtype dtype = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.asfortranarray(@this, dtype:dtype);
        }
        
        /// <summary>
        /// Convert the input to an array, checking for NaNs or Infs.
        /// </summary>
        /// <param name="dtype">
        /// By default, the data-type is inferred from the input data.
        /// </param>
        /// <param name="order">
        /// Whether to use row-major (C-style) or
        /// column-major (Fortran-style) memory representation.
        /// Defaults to ‘C’.
        /// </param>
        /// <returns>
        /// Array interpretation of a.  No copy is performed if the input
        /// is already an ndarray.  If a is a subclass of ndarray, a base
        /// class ndarray is returned.
        /// </returns>
        public NDarray asarray_chkfinite(Dtype dtype = null, string order = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.asarray_chkfinite(@this, dtype:dtype, order:order);
        }
        
      
        /// <summary>
        /// Return an ndarray of the provided type that satisfies requirements.
        /// 
        /// This function is useful to be sure that an array with the correct flags
        /// is returned for passing to compiled code (perhaps through ctypes).
        /// 
        /// Notes
        /// 
        /// The returned array will be guaranteed to have the listed requirements
        /// by making a copy if needed.
        /// </summary>
        /// <param name="dtype">
        /// The required data-type. If None preserve the current dtype. If your
        /// application requires the data to be in native byteorder, include
        /// a byteorder specification as a part of the dtype specification.
        /// </param>
        /// <param name="requirements">
        /// The requirements list can be any of the following
        /// </param>
        public NDarray require(Dtype dtype, string[] requirements)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.require(@this, dtype, requirements);
        }
        
        /// <summary>
        /// Split an array into multiple sub-arrays.
        /// </summary>
        /// <param name="indices_or_sections">
        /// If indices_or_sections is an integer, N, the array will be divided
        /// into N equal arrays along axis.  If such a split is not possible,
        /// an error is raised.
        /// 
        /// If indices_or_sections is a 1-D array of sorted integers, the entries
        /// indicate where along axis the array is split.  For example,
        /// [2, 3] would, for axis=0, result in
        /// 
        /// If an index exceeds the dimension of the array along axis,
        /// an empty sub-array is returned correspondingly.
        /// </param>
        /// <param name="axis">
        /// The axis along which to split, default is 0.
        /// </param>
        /// <returns>
        /// A list of sub-arrays.
        /// </returns>
        public NDarray[] split(int[] indices_or_sections, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.split(@this, indices_or_sections, axis:axis);
        }
        
        /// <summary>
        /// Construct an array by repeating A the number of times given by reps.
        /// 
        /// If reps has length d, the result will have dimension of
        /// max(d, A.ndim).
        /// 
        /// If A.ndim &lt; d, A is promoted to be d-dimensional by prepending new
        /// axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,
        /// or shape (1, 1, 3) for 3-D replication. If this is not the desired
        /// behavior, promote A to d-dimensions manually before calling this
        /// function.
        /// 
        /// If A.ndim &gt; d, reps is promoted to A.ndim by pre-pending 1’s to it.
        /// Thus for an A of shape (2, 3, 4, 5), a reps of (2, 2) is treated as
        /// (1, 1, 2, 2).
        /// 
        /// Note : Although tile may be used for broadcasting, it is strongly
        /// recommended to use numpy’s broadcasting operations and functions.
        /// </summary>
        /// <param name="reps">
        /// The number of repetitions of A along each axis.
        /// </param>
        /// <returns>
        /// The tiled output array.
        /// </returns>
        public NDarray tile(NDarray reps)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.tile(@this, reps);
        }
        
        /// <summary>
        /// Repeat elements of an array.
        /// </summary>
        /// <param name="repeats">
        /// The number of repetitions for each element.  repeats is broadcasted
        /// to fit the shape of the given axis.
        /// </param>
        /// <param name="axis">
        /// The axis along which to repeat values.  By default, use the
        /// flattened input array, and return a flat output array.
        /// </param>
        /// <returns>
        /// Output array which has the same shape as a, except along
        /// the given axis.
        /// </returns>
        public NDarray repeat(int[] repeats, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.repeat(@this, repeats, axis:axis);
        }
        
        /// <summary>
        /// Return a new array with sub-arrays along an axis deleted. For a one
        /// dimensional array, this returns those entries not returned by
        /// arr[obj].
        /// 
        /// Notes
        /// 
        /// Often it is preferable to use a boolean mask. For example:
        /// 
        /// Is equivalent to np.delete(arr, [0,2,4], axis=0), but allows further
        /// use of mask.
        /// </summary>
        /// <param name="obj">
        /// Indicate which sub-arrays to remove.
        /// </param>
        /// <param name="axis">
        /// The axis along which to delete the subarray defined by obj.
        /// If axis is None, obj is applied to the flattened array.
        /// </param>
        /// <returns>
        /// A copy of arr with the elements specified by obj removed. Note
        /// that delete does not occur in-place. If axis is None, out is
        /// a flattened array.
        /// </returns>
        public NDarray delete(Slice obj, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.delete(@this, obj, axis:axis);
        }
        
        /// <summary>
        /// Insert values along the given axis before the given indices.
        /// 
        /// Notes
        /// 
        /// Note that for higher dimensional inserts obj=0 behaves very different
        /// from obj=[0] just like arr[:,0,:] = values is different from
        /// arr[:,[0],:] = values.
        /// </summary>
        /// <param name="obj">
        /// Object that defines the index or indices before which values is
        /// inserted.
        /// 
        /// Support for multiple insertions when obj is a single scalar or a
        /// sequence with one element (similar to calling insert multiple
        /// times).
        /// </param>
        /// <param name="values">
        /// Values to insert into arr. If the type of values is different
        /// from that of arr, values is converted to the type of arr.
        /// values should be shaped so that arr[...,obj,...] = values
        /// is legal.
        /// </param>
        /// <param name="axis">
        /// Axis along which to insert values.  If axis is None then arr
        /// is flattened first.
        /// </param>
        /// <returns>
        /// A copy of arr with values inserted.  Note that insert
        /// does not occur in-place: a new array is returned. If
        /// axis is None, out is a flattened array.
        /// </returns>
        public NDarray insert(int obj, NDarray values, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.insert(@this, obj, values, axis:axis);
        }
        
        /// <summary>
        /// Append values to the end of an array.
        /// </summary>
        /// <param name="values">
        /// These values are appended to a copy of arr.  It must be of the
        /// correct shape (the same shape as arr, excluding axis).  If
        /// axis is not specified, values can be any shape and will be
        /// flattened before use.
        /// </param>
        /// <param name="axis">
        /// The axis along which values are appended.  If axis is not
        /// given, both arr and values are flattened before use.
        /// </param>
        /// <returns>
        /// A copy of arr with values appended to axis.  Note that
        /// append does not occur in-place: a new array is allocated and
        /// filled.  If axis is None, out is a flattened array.
        /// </returns>
        public NDarray append(NDarray values, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.append(@this, values, axis:axis);
        }
        
        /// <summary>
        /// Trim the leading and/or trailing zeros from a 1-D array or sequence.
        /// </summary>
        /// <param name="trim">
        /// A string with ‘f’ representing trim from front and ‘b’ to trim from
        /// back. Default is ‘fb’, trim zeros from both front and back of the
        /// array.
        /// </param>
        /// <returns>
        /// The result of trimming the input. The input data type is preserved.
        /// </returns>
        public NDarray trim_zeros(string trim = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.trim_zeros(@this, trim:trim);
        }
        
        /// <summary>
        /// Find the unique elements of an array.
        /// 
        /// Returns the sorted unique elements of an array. There are three optional
        /// outputs in addition to the unique elements:
        /// 
        /// Notes
        /// 
        /// When an axis is specified the subarrays indexed by the axis are sorted.
        /// This is done by making the specified axis the first dimension of the array
        /// and then flattening the subarrays in C order. The flattened subarrays are
        /// then viewed as a structured type with each element given a label, with the
        /// effect that we end up with a 1-D array of structured types that can be
        /// treated in the same way as any other 1-D array. The result is that the
        /// flattened subarrays are sorted in lexicographic order starting with the
        /// first element.
        /// </summary>
        /// <param name="return_index">
        /// If True, also return the indices of ar (along the specified axis,
        /// if provided, or in the flattened array) that result in the unique array.
        /// </param>
        /// <param name="return_inverse">
        /// If True, also return the indices of the unique array (for the specified
        /// axis, if provided) that can be used to reconstruct ar.
        /// </param>
        /// <param name="return_counts">
        /// If True, also return the number of times each unique item appears
        /// in ar.
        /// </param>
        /// <param name="axis">
        /// The axis to operate on. If None, ar will be flattened. If an integer,
        /// the subarrays indexed by the given axis will be flattened and treated
        /// as the elements of a 1-D array with the dimension of the given axis,
        /// see the notes for more details.  Object arrays or structured arrays
        /// that contain objects are not supported if the axis kwarg is used. The
        /// default is None.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// unique
        /// The sorted unique values.
        /// unique_indices
        /// The indices of the first occurrences of the unique values in the
        /// original array. Only provided if return_index is True.
        /// unique_inverse
        /// The indices to reconstruct the original array from the
        /// unique array. Only provided if return_inverse is True.
        /// unique_counts
        /// The number of times each of the unique values comes up in the
        /// original array. Only provided if return_counts is True.
        /// </returns>
        public (NDarray, NDarray, NDarray, NDarray) unique(bool? return_index = null, bool? return_inverse = null, bool? return_counts = null, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.unique(@this, return_index:return_index, return_inverse:return_inverse, return_counts:return_counts, axis:axis);
        }
        
        /// <summary>
        /// Reverse the order of elements in an array along the given axis.
        /// 
        /// The shape of the array is preserved, but the elements are reordered.
        /// 
        /// Notes
        /// 
        /// flip(m, 0) is equivalent to flipud(m).
        /// 
        /// flip(m, 1) is equivalent to fliplr(m).
        /// 
        /// flip(m, n) corresponds to m[...,::-1,...] with ::-1 at position n.
        /// 
        /// flip(m) corresponds to m[::-1,::-1,...,::-1] with ::-1 at all
        /// positions.
        /// 
        /// flip(m, (0, 1)) corresponds to m[::-1,::-1,...] with ::-1 at
        /// position 0 and position 1.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which to flip over. The default,
        /// axis=None, will flip over all of the axes of the input array.
        /// If axis is negative it counts from the last to the first axis.
        /// 
        /// If axis is a tuple of ints, flipping is performed on all of the axes
        /// specified in the tuple.
        /// </param>
        /// <returns>
        /// A view of m with the entries of axis reversed.  Since a view is
        /// returned, this operation is done in constant time.
        /// </returns>
        public NDarray flip(int[] axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.flip(@this, axis:axis);
        }
        
        /// <summary>
        /// Flip array in the left/right direction.
        /// 
        /// Flip the entries in each row in the left/right direction.
        /// Columns are preserved, but appear in a different order than before.
        /// 
        /// Notes
        /// 
        /// Equivalent to m[:,::-1]. Requires the array to be at least 2-D.
        /// </summary>
        /// <returns>
        /// A view of m with the columns reversed.  Since a view
        /// is returned, this operation is .
        /// </returns>
        public NDarray fliplr()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.fliplr(@this);
        }
        
        /// <summary>
        /// Flip array in the up/down direction.
        /// 
        /// Flip the entries in each column in the up/down direction.
        /// Rows are preserved, but appear in a different order than before.
        /// 
        /// Notes
        /// 
        /// Equivalent to m[::-1,...].
        /// Does not require the array to be two-dimensional.
        /// </summary>
        /// <returns>
        /// A view of m with the rows reversed.  Since a view is
        /// returned, this operation is .
        /// </returns>
        public NDarray flipud()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.flipud(@this);
        }
        
        /// <summary>
        /// Roll array elements along a given axis.
        /// 
        /// Elements that roll beyond the last position are re-introduced at
        /// the first.
        /// 
        /// Notes
        /// 
        /// Supports rolling over multiple dimensions simultaneously.
        /// </summary>
        /// <param name="shift">
        /// The number of places by which elements are shifted.  If a tuple,
        /// then axis must be a tuple of the same size, and each of the
        /// given axes is shifted by the corresponding number.  If an int
        /// while axis is a tuple of ints, then the same value is used for
        /// all given axes.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which elements are shifted.  By default, the
        /// array is flattened before shifting, after which the original
        /// shape is restored.
        /// </param>
        /// <returns>
        /// Output array, with the same shape as a.
        /// </returns>
        public NDarray roll(int[] shift, int[] axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.roll(@this, shift, axis:axis);
        }
        
        /// <summary>
        /// Rotate an array by 90 degrees in the plane specified by axes.
        /// 
        /// Rotation direction is from the first towards the second axis.
        /// 
        /// Notes
        /// 
        /// rot90(m, k=1, axes=(1,0)) is the reverse of rot90(m, k=1, axes=(0,1))
        /// rot90(m, k=1, axes=(1,0)) is equivalent to rot90(m, k=-1, axes=(0,1))
        /// </summary>
        /// <param name="k">
        /// Number of times the array is rotated by 90 degrees.
        /// </param>
        /// <param name="axes">
        /// The array is rotated in the plane defined by the axes.
        /// Axes must be different.
        /// </param>
        /// <returns>
        /// A rotated view of m.
        /// </returns>
        public NDarray rot90(int k, int[] axes = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.rot90(@this, k, axes);
        }
        
        /// <summary>
        /// Packs the elements of a binary-valued array into bits in a uint8 array.
        /// 
        /// The result is padded to full bytes by inserting zero bits at the end.
        /// </summary>
        /// <param name="axis">
        /// The dimension over which bit-packing is done.
        /// None implies packing the flattened array.
        /// </param>
        /// <returns>
        /// Array of type uint8 whose elements represent bits corresponding to the
        /// logical (0 or nonzero) value of the input elements. The shape of
        /// packed has the same number of dimensions as the input (unless axis
        /// is None, in which case the output is 1-D).
        /// </returns>
        public NDarray packbits(int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.packbits(@this, axis:axis);
        }
        
        /// <summary>
        /// Unpacks elements of a uint8 array into a binary-valued output array.
        /// 
        /// Each element of myarray represents a bit-field that should be unpacked
        /// into a binary-valued output array. The shape of the output array is either
        /// 1-D (if axis is None) or the same shape as the input array with unpacking
        /// done along the axis specified.
        /// </summary>
        /// <param name="axis">
        /// The dimension over which bit-unpacking is done.
        /// None implies unpacking the flattened array.
        /// </param>
        /// <returns>
        /// The elements are binary-valued (0 or 1).
        /// </returns>
        public NDarray unpackbits(int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.unpackbits(@this, axis:axis);
        }
        
        /// <summary>
        /// Cholesky decomposition.
        /// 
        /// Return the Cholesky decomposition, L * L.H, of the square matrix a,
        /// where L is lower-triangular and .H is the conjugate transpose operator
        /// (which is the ordinary transpose if a is real-valued).  a must be
        /// Hermitian (symmetric if real-valued) and positive-definite.  Only L is
        /// actually returned.
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// The Cholesky decomposition is often used as a fast way of solving
        /// 
        /// (when A is both Hermitian/symmetric and positive-definite).
        /// 
        /// First, we solve for  in
        /// 
        /// and then for  in
        /// </summary>
        /// <returns>
        /// Upper or lower-triangular Cholesky factor of a.  Returns a
        /// matrix object if a is a matrix object.
        /// </returns>
        public NDarray cholesky()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.cholesky(@this);
        }
        
        /// <summary>
        /// Compute the determinant of an array.
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// The determinant is computed via LU factorization using the LAPACK
        /// routine z/dgetrf.
        /// </summary>
        /// <returns>
        /// Determinant of a.
        /// </returns>
        public NDarray det()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.det(@this);
        }
        
        /// <summary>
        /// Compute the eigenvalues and right eigenvectors of a square array.
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// This is implemented using the _geev LAPACK routines which compute
        /// the eigenvalues and eigenvectors of general square arrays.
        /// 
        /// The number w is an eigenvalue of a if there exists a vector
        /// v such that dot(a,v) = w * v. Thus, the arrays a, w, and
        /// v satisfy the equations dot(a[:,:], v[:,i]) = w[i] * v[:,i]
        /// for .
        /// 
        /// The array v of eigenvectors may not be of maximum rank, that is, some
        /// of the columns may be linearly dependent, although round-off error may
        /// obscure that fact. If the eigenvalues are all different, then theoretically
        /// the eigenvectors are linearly independent. Likewise, the (complex-valued)
        /// matrix of eigenvectors v is unitary if the matrix a is normal, i.e.,
        /// if dot(a, a.H) = dot(a.H, a), where a.H denotes the conjugate
        /// transpose of a.
        /// 
        /// Finally, it is emphasized that v consists of the right (as in
        /// right-hand side) eigenvectors of a.  A vector y satisfying
        /// dot(y.T, a) = z * y.T for some number z is called a left
        /// eigenvector of a, and, in general, the left and right eigenvectors
        /// of a matrix are not necessarily the (perhaps conjugate) transposes
        /// of each other.
        /// 
        /// References
        /// 
        /// G. Strang, Linear Algebra and Its Applications, 2nd Ed., Orlando, FL,
        /// Academic Press, Inc., 1980, Various pp.
        /// </summary>
        /// <returns>
        /// A tuple of:
        /// w
        /// The eigenvalues, each repeated according to its multiplicity.
        /// The eigenvalues are not necessarily ordered. The resulting
        /// array will be of complex type, unless the imaginary part is
        /// zero in which case it will be cast to a real type. When a
        /// is real the resulting eigenvalues will be real (0 imaginary
        /// part) or occur in conjugate pairs
        /// v
        /// The normalized (unit “length”) eigenvectors, such that the
        /// column v[:,i] is the eigenvector corresponding to the
        /// eigenvalue w[i].
        /// </returns>
        public (NDarray, NDarray) eig()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.eig(@this);
        }
        
        /// <summary>
        /// Return the eigenvalues and eigenvectors of a complex Hermitian
        /// (conjugate symmetric) or a real symmetric matrix.
        /// 
        /// Returns two objects, a 1-D array containing the eigenvalues of a, and
        /// a 2-D square array or matrix (depending on the input type) of the
        /// corresponding eigenvectors (in columns).
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// The eigenvalues/eigenvectors are computed using LAPACK routines _syevd,
        /// _heevd
        /// 
        /// The eigenvalues of real symmetric or complex Hermitian matrices are
        /// always real. [1] The array v of (column) eigenvectors is unitary
        /// and a, w, and v satisfy the equations
        /// dot(a, v[:, i]) = w[i] * v[:, i].
        /// 
        /// References
        /// </summary>
        /// <param name="UPLO">
        /// Specifies whether the calculation is done with the lower triangular
        /// part of a (‘L’, default) or the upper triangular part (‘U’).
        /// Irrespective of this value only the real parts of the diagonal will
        /// be considered in the computation to preserve the notion of a Hermitian
        /// matrix. It therefore follows that the imaginary part of the diagonal
        /// will always be treated as zero.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// w
        /// The eigenvalues in ascending order, each repeated according to
        /// its multiplicity.
        /// v
        /// The column v[:, i] is the normalized eigenvector corresponding
        /// to the eigenvalue w[i].  Will return a matrix object if a is
        /// a matrix object.
        /// </returns>
        public (NDarray, NDarray) eigh(string UPLO = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.eigh(@this, UPLO:UPLO);
        }
        
        /// <summary>
        /// Compute the eigenvalues of a general matrix.
        /// 
        /// Main difference between eigvals and eig: the eigenvectors aren’t
        /// returned.
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// This is implemented using the _geev LAPACK routines which compute
        /// the eigenvalues and eigenvectors of general square arrays.
        /// </summary>
        /// <returns>
        /// The eigenvalues, each repeated according to its multiplicity.
        /// They are not necessarily ordered, nor are they necessarily
        /// real for real matrices.
        /// </returns>
        public NDarray eigvals()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.eigvals(@this);
        }
        
        /// <summary>
        /// Compute the eigenvalues of a complex Hermitian or real symmetric matrix.
        /// 
        /// Main difference from eigh: the eigenvectors are not computed.
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// The eigenvalues are computed using LAPACK routines _syevd, _heevd
        /// </summary>
        /// <param name="UPLO">
        /// Specifies whether the calculation is done with the lower triangular
        /// part of a (‘L’, default) or the upper triangular part (‘U’).
        /// Irrespective of this value only the real parts of the diagonal will
        /// be considered in the computation to preserve the notion of a Hermitian
        /// matrix. It therefore follows that the imaginary part of the diagonal
        /// will always be treated as zero.
        /// </param>
        /// <returns>
        /// The eigenvalues in ascending order, each repeated according to
        /// its multiplicity.
        /// </returns>
        public NDarray eigvalsh(string UPLO = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.eigvalsh(@this, UPLO:UPLO);
        }
        
        /// <summary>
        /// Compute the (multiplicative) inverse of a matrix.
        /// 
        /// Given a square matrix a, return the matrix ainv satisfying
        /// dot(a, ainv) = dot(ainv, a) = eye(a.shape[0]).
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// </summary>
        /// <returns>
        /// (Multiplicative) inverse of the matrix a.
        /// </returns>
        public NDarray inv()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.inv(@this);
        }
        
        /// <summary>
        /// Return the least-squares solution to a linear matrix equation.
        /// 
        /// Solves the equation a x = b by computing a vector x that
        /// minimizes the Euclidean 2-norm || b - a x ||^2.  The equation may
        /// be under-, well-, or over- determined (i.e., the number of
        /// linearly independent rows of a can be less than, equal to, or
        /// greater than its number of linearly independent columns).  If a
        /// is square and of full rank, then x (but for round-off error) is
        /// the “exact” solution of the equation.
        /// 
        /// Notes
        /// 
        /// If b is a matrix, then all array results are returned as matrices.
        /// </summary>
        /// <param name="b">
        /// Ordinate or “dependent variable” values. If b is two-dimensional,
        /// the least-squares solution is calculated for each of the K columns
        /// of b.
        /// </param>
        /// <param name="rcond">
        /// Cut-off ratio for small singular values of a.
        /// For the purposes of rank determination, singular values are treated
        /// as zero if they are smaller than rcond times the largest singular
        /// value of a.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// x
        /// Least-squares solution. If b is two-dimensional,
        /// the solutions are in the K columns of x.
        /// residuals
        /// Sums of residuals; squared Euclidean 2-norm for each column in
        /// b - a*x.
        /// If the rank of a is &lt; N or M &lt;= N, this is an empty array.
        /// If b is 1-dimensional, this is a (1,) shape array.
        /// Otherwise the shape is (K,).
        /// rank
        /// Rank of matrix a.
        /// s
        /// Singular values of a.
        /// </returns>
        public (NDarray, NDarray, int, NDarray) lstsq(NDarray b, float? rcond = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.lstsq(@this, b, rcond:rcond);
        }
        
        /// <summary>
        /// Compute the (Moore-Penrose) pseudo-inverse of a matrix.
        /// 
        /// Calculate the generalized inverse of a matrix using its
        /// singular-value decomposition (SVD) and including all
        /// large singular values.
        /// 
        /// Notes
        /// 
        /// The pseudo-inverse of a matrix A, denoted , is
        /// defined as: “the matrix that ‘solves’ [the least-squares problem]
        /// ,” i.e., if  is said solution, then
        ///  is that matrix such that .
        /// 
        /// It can be shown that if  is the singular
        /// value decomposition of A, then
        /// , where  are
        /// orthogonal matrices,  is a diagonal matrix consisting
        /// of A’s so-called singular values, (followed, typically, by
        /// zeros), and then  is simply the diagonal matrix
        /// consisting of the reciprocals of A’s singular values
        /// (again, followed by zeros). [1]
        /// 
        /// References
        /// </summary>
        /// <param name="rcond">
        /// Cutoff for small singular values.
        /// Singular values smaller (in modulus) than
        /// rcond * largest_singular_value (again, in modulus)
        /// are set to zero. Broadcasts against the stack of matrices
        /// </param>
        /// <returns>
        /// The pseudo-inverse of a. If a is a matrix instance, then so
        /// is B.
        /// </returns>
        public NDarray pinv(NDarray rcond)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.pinv(@this, rcond);
        }
        
        /// <summary>
        /// Solve a linear matrix equation, or system of linear scalar equations.
        /// 
        /// Computes the “exact” solution, x, of the well-determined, i.e., full
        /// rank, linear matrix equation ax = b.
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// The solutions are computed using LAPACK routine _gesv
        /// 
        /// a must be square and of full-rank, i.e., all rows (or, equivalently,
        /// columns) must be linearly independent; if either is not true, use
        /// lstsq for the least-squares best “solution” of the
        /// system/equation.
        /// 
        /// References
        /// </summary>
        /// <param name="b">
        /// Ordinate or “dependent variable” values.
        /// </param>
        /// <returns>
        /// Solution to the system a x = b.  Returned shape is identical to b.
        /// </returns>
        public NDarray solve(NDarray b)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.solve(@this, b);
        }
        
        /// <summary>
        /// Singular Value Decomposition.
        /// 
        /// When a is a 2D array, it is factorized as u &#64; np.diag(s) &#64; vh
        /// = (u * s) &#64; vh, where u and vh are 2D unitary arrays and s is a 1D
        /// array of a’s singular values. When a is higher-dimensional, SVD is
        /// applied in stacked mode as explained below.
        /// 
        /// Notes
        /// 
        /// The decomposition is performed using LAPACK routine _gesdd.
        /// 
        /// SVD is usually described for the factorization of a 2D matrix .
        /// The higher-dimensional case will be discussed below. In the 2D case, SVD is
        /// written as , where , ,
        ///  and . The 1D array s
        /// contains the singular values of a and u and vh are unitary. The rows
        /// of vh are the eigenvectors of  and the columns of u are
        /// the eigenvectors of . In both cases the corresponding
        /// (possibly non-zero) eigenvalues are given by s**2.
        /// 
        /// If a has more than two dimensions, then broadcasting rules apply, as
        /// explained in Linear algebra on several matrices at once. This means that SVD is
        /// working in “stacked” mode: it iterates over all indices of the first
        /// a.ndim - 2 dimensions and for each combination SVD is applied to the
        /// last two indices. The matrix a can be reconstructed from the
        /// decomposition with either (u * s[..., None, :]) &#64; vh or
        /// u &#64; (s[..., None] * vh). (The &#64; operator can be replaced by the
        /// function np.matmul for python versions below 3.5.)
        /// 
        /// If a is a matrix object (as opposed to an ndarray), then so are
        /// all the return values.
        /// </summary>
        /// <param name="full_matrices">
        /// If True (default), u and vh have the shapes (..., M, M) and
        /// (..., N, N), respectively.  Otherwise, the shapes are
        /// (..., M, K) and (..., K, N), respectively, where
        /// K = min(M, N).
        /// </param>
        /// <param name="compute_uv">
        /// Whether or not to compute u and vh in addition to s.  True
        /// by default.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// u
        /// Unitary array(s). The first a.ndim - 2 dimensions have the same
        /// size as those of the input a. The size of the last two dimensions
        /// depends on the value of full_matrices. Only returned when
        /// compute_uv is True.
        /// s
        /// Vector(s) with the singular values, within each vector sorted in
        /// descending order. The first a.ndim - 2 dimensions have the same
        /// size as those of the input a.
        /// vh
        /// Unitary array(s). The first a.ndim - 2 dimensions have the same
        /// size as those of the input a. The size of the last two dimensions
        /// depends on the value of full_matrices. Only returned when
        /// compute_uv is True.
        /// </returns>
        public (NDarray, NDarray, NDarray) svd(bool? full_matrices = null, bool? compute_uv = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.svd(@this, full_matrices:full_matrices, compute_uv:compute_uv);
        }
        
        /// <summary>
        /// Compute the one-dimensional discrete Fourier Transform.
        /// 
        /// This function computes the one-dimensional n-point discrete Fourier
        /// Transform (DFT) with the efficient Fast Fourier Transform (FFT)
        /// algorithm [CT].
        /// 
        /// Notes
        /// 
        /// FFT (Fast Fourier Transform) refers to a way the discrete Fourier
        /// Transform (DFT) can be calculated efficiently, by using symmetries in the
        /// calculated terms.  The symmetry is highest when n is a power of 2, and
        /// the transform is therefore most efficient for these sizes.
        /// 
        /// The DFT is defined, with the conventions used in this implementation, in
        /// the documentation for the numpy.fft module.
        /// 
        /// References
        /// </summary>
        /// <param name="n">
        /// Length of the transformed axis of the output.
        /// If n is smaller than the length of the input, the input is cropped.
        /// If it is larger, the input is padded with zeros.  If n is not given,
        /// the length of the input along the axis specified by axis is used.
        /// </param>
        /// <param name="axis">
        /// Axis over which to compute the FFT.  If not given, the last axis is
        /// used.
        /// </param>
        /// <param name="norm">
        /// Normalization mode (see numpy.fft). Default is None.
        /// </param>
        /// <returns>
        /// The truncated or zero-padded input, transformed along the axis
        /// indicated by axis, or the last one if axis is not specified.
        /// </returns>
        public NDarray fft(int? n = null, int? axis = null, string norm = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.fft(@this, n:n, axis:axis, norm:norm);
        }
        
        /// <summary>
        /// Compute the 2-dimensional discrete Fourier Transform
        /// 
        /// This function computes the n-dimensional discrete Fourier Transform
        /// over any axes in an M-dimensional array by means of the
        /// Fast Fourier Transform (FFT).  By default, the transform is computed over
        /// the last two axes of the input array, i.e., a 2-dimensional FFT.
        /// 
        /// Notes
        /// 
        /// fft2 is just fftn with a different default for axes.
        /// 
        /// The output, analogously to fft, contains the term for zero frequency in
        /// the low-order corner of the transformed axes, the positive frequency terms
        /// in the first half of these axes, the term for the Nyquist frequency in the
        /// middle of the axes and the negative frequency terms in the second half of
        /// the axes, in order of decreasingly negative frequency.
        /// 
        /// See fftn for details and a plotting example, and numpy.fft for
        /// definitions and conventions used.
        /// </summary>
        /// <param name="s">
        /// Shape (length of each transformed axis) of the output
        /// (s[0] refers to axis 0, s[1] to axis 1, etc.).
        /// This corresponds to n for fft(x, n).
        /// Along each axis, if the given shape is smaller than that of the input,
        /// the input is cropped.  If it is larger, the input is padded with zeros.
        /// if s is not given, the shape of the input along the axes specified
        /// by axes is used.
        /// </param>
        /// <param name="axes">
        /// Axes over which to compute the FFT.  If not given, the last two
        /// axes are used.  A repeated index in axes means the transform over
        /// that axis is performed multiple times.  A one-element sequence means
        /// that a one-dimensional FFT is performed.
        /// </param>
        /// <param name="norm">
        /// Normalization mode (see numpy.fft). Default is None.
        /// </param>
        /// <returns>
        /// The truncated or zero-padded input, transformed along the axes
        /// indicated by axes, or the last two axes if axes is not given.
        /// </returns>
        public NDarray fft2(int[] s = null, int[] axes = null, string norm = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.fft2(@this, s:s, axes:axes, norm:norm);
        }
        
        /// <summary>
        /// Compute the N-dimensional discrete Fourier Transform.
        /// 
        /// This function computes the N-dimensional discrete Fourier Transform over
        /// any number of axes in an M-dimensional array by means of the Fast Fourier
        /// Transform (FFT).
        /// 
        /// Notes
        /// 
        /// The output, analogously to fft, contains the term for zero frequency in
        /// the low-order corner of all axes, the positive frequency terms in the
        /// first half of all axes, the term for the Nyquist frequency in the middle
        /// of all axes and the negative frequency terms in the second half of all
        /// axes, in order of decreasingly negative frequency.
        /// 
        /// See numpy.fft for details, definitions and conventions used.
        /// </summary>
        /// <param name="s">
        /// Shape (length of each transformed axis) of the output
        /// (s[0] refers to axis 0, s[1] to axis 1, etc.).
        /// This corresponds to n for fft(x, n).
        /// Along any axis, if the given shape is smaller than that of the input,
        /// the input is cropped.  If it is larger, the input is padded with zeros.
        /// if s is not given, the shape of the input along the axes specified
        /// by axes is used.
        /// </param>
        /// <param name="axes">
        /// Axes over which to compute the FFT.  If not given, the last len(s)
        /// axes are used, or all axes if s is also not specified.
        /// Repeated indices in axes means that the transform over that axis is
        /// performed multiple times.
        /// </param>
        /// <param name="norm">
        /// Normalization mode (see numpy.fft). Default is None.
        /// </param>
        /// <returns>
        /// The truncated or zero-padded input, transformed along the axes
        /// indicated by axes, or by a combination of s and a,
        /// as explained in the parameters section above.
        /// </returns>
        public NDarray fftn(int[] s = null, int[] axes = null, string norm = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.fftn(@this, s:s, axes:axes, norm:norm);
        }
        
        /// <summary>
        /// Compute the one-dimensional inverse discrete Fourier Transform.
        /// 
        /// This function computes the inverse of the one-dimensional n-point
        /// discrete Fourier transform computed by fft.  In other words,
        /// ifft(fft(a)) == a to within numerical accuracy.
        /// For a general description of the algorithm and definitions,
        /// see numpy.fft.
        /// 
        /// The input should be ordered in the same way as is returned by fft,
        /// i.e.,
        /// 
        /// For an even number of input points, A[n//2] represents the sum of
        /// the values at the positive and negative Nyquist frequencies, as the two
        /// are aliased together. See numpy.fft for details.
        /// 
        /// Notes
        /// 
        /// If the input parameter n is larger than the size of the input, the input
        /// is padded by appending zeros at the end.  Even though this is the common
        /// approach, it might lead to surprising results.  If a different padding is
        /// desired, it must be performed before calling ifft.
        /// </summary>
        /// <param name="n">
        /// Length of the transformed axis of the output.
        /// If n is smaller than the length of the input, the input is cropped.
        /// If it is larger, the input is padded with zeros.  If n is not given,
        /// the length of the input along the axis specified by axis is used.
        /// See notes about padding issues.
        /// </param>
        /// <param name="axis">
        /// Axis over which to compute the inverse DFT.  If not given, the last
        /// axis is used.
        /// </param>
        /// <param name="norm">
        /// Normalization mode (see numpy.fft). Default is None.
        /// </param>
        /// <returns>
        /// The truncated or zero-padded input, transformed along the axis
        /// indicated by axis, or the last one if axis is not specified.
        /// </returns>
        public NDarray ifft(int? n = null, int? axis = null, string norm = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.ifft(@this, n:n, axis:axis, norm:norm);
        }
        
        /// <summary>
        /// Compute the 2-dimensional inverse discrete Fourier Transform.
        /// 
        /// This function computes the inverse of the 2-dimensional discrete Fourier
        /// Transform over any number of axes in an M-dimensional array by means of
        /// the Fast Fourier Transform (FFT).  In other words, ifft2(fft2(a)) == a
        /// to within numerical accuracy.  By default, the inverse transform is
        /// computed over the last two axes of the input array.
        /// 
        /// The input, analogously to ifft, should be ordered in the same way as is
        /// returned by fft2, i.e. it should have the term for zero frequency
        /// in the low-order corner of the two axes, the positive frequency terms in
        /// the first half of these axes, the term for the Nyquist frequency in the
        /// middle of the axes and the negative frequency terms in the second half of
        /// both axes, in order of decreasingly negative frequency.
        /// 
        /// Notes
        /// 
        /// ifft2 is just ifftn with a different default for axes.
        /// 
        /// See ifftn for details and a plotting example, and numpy.fft for
        /// definition and conventions used.
        /// 
        /// Zero-padding, analogously with ifft, is performed by appending zeros to
        /// the input along the specified dimension.  Although this is the common
        /// approach, it might lead to surprising results.  If another form of zero
        /// padding is desired, it must be performed before ifft2 is called.
        /// </summary>
        /// <param name="s">
        /// Shape (length of each axis) of the output (s[0] refers to axis 0,
        /// s[1] to axis 1, etc.).  This corresponds to n for ifft(x, n).
        /// Along each axis, if the given shape is smaller than that of the input,
        /// the input is cropped.  If it is larger, the input is padded with zeros.
        /// if s is not given, the shape of the input along the axes specified
        /// by axes is used.  See notes for issue on ifft zero padding.
        /// </param>
        /// <param name="axes">
        /// Axes over which to compute the FFT.  If not given, the last two
        /// axes are used.  A repeated index in axes means the transform over
        /// that axis is performed multiple times.  A one-element sequence means
        /// that a one-dimensional FFT is performed.
        /// </param>
        /// <param name="norm">
        /// Normalization mode (see numpy.fft). Default is None.
        /// </param>
        /// <returns>
        /// The truncated or zero-padded input, transformed along the axes
        /// indicated by axes, or the last two axes if axes is not given.
        /// </returns>
        public NDarray ifft2(int[] s = null, int[] axes = null, string norm = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.ifft2(@this, s:s, axes:axes, norm:norm);
        }
        
        /// <summary>
        /// Compute the N-dimensional inverse discrete Fourier Transform.
        /// 
        /// This function computes the inverse of the N-dimensional discrete
        /// Fourier Transform over any number of axes in an M-dimensional array by
        /// means of the Fast Fourier Transform (FFT).  In other words,
        /// ifftn(fftn(a)) == a to within numerical accuracy.
        /// For a description of the definitions and conventions used, see numpy.fft.
        /// 
        /// The input, analogously to ifft, should be ordered in the same way as is
        /// returned by fftn, i.e. it should have the term for zero frequency
        /// in all axes in the low-order corner, the positive frequency terms in the
        /// first half of all axes, the term for the Nyquist frequency in the middle
        /// of all axes and the negative frequency terms in the second half of all
        /// axes, in order of decreasingly negative frequency.
        /// 
        /// Notes
        /// 
        /// See numpy.fft for definitions and conventions used.
        /// 
        /// Zero-padding, analogously with ifft, is performed by appending zeros to
        /// the input along the specified dimension.  Although this is the common
        /// approach, it might lead to surprising results.  If another form of zero
        /// padding is desired, it must be performed before ifftn is called.
        /// </summary>
        /// <param name="s">
        /// Shape (length of each transformed axis) of the output
        /// (s[0] refers to axis 0, s[1] to axis 1, etc.).
        /// This corresponds to n for ifft(x, n).
        /// Along any axis, if the given shape is smaller than that of the input,
        /// the input is cropped.  If it is larger, the input is padded with zeros.
        /// if s is not given, the shape of the input along the axes specified
        /// by axes is used.  See notes for issue on ifft zero padding.
        /// </param>
        /// <param name="axes">
        /// Axes over which to compute the IFFT.  If not given, the last len(s)
        /// axes are used, or all axes if s is also not specified.
        /// Repeated indices in axes means that the inverse transform over that
        /// axis is performed multiple times.
        /// </param>
        /// <param name="norm">
        /// Normalization mode (see numpy.fft). Default is None.
        /// </param>
        /// <returns>
        /// The truncated or zero-padded input, transformed along the axes
        /// indicated by axes, or by a combination of s or a,
        /// as explained in the parameters section above.
        /// </returns>
        public NDarray ifftn(int[] s = null, int[] axes = null, string norm = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.ifftn(@this, s:s, axes:axes, norm:norm);
        }
        
        /// <summary>
        /// Modified Bessel function of the first kind, order 0.
        /// 
        /// Usually denoted .  This function does broadcast, but will not
        /// “up-cast” int dtype arguments unless accompanied by at least one float or
        /// complex dtype argument (see Raises below).
        /// 
        /// Notes
        /// 
        /// We use the algorithm published by Clenshaw [1] and referenced by
        /// Abramowitz and Stegun [2], for which the function domain is
        /// partitioned into the two intervals [0,8] and (8,inf), and Chebyshev
        /// polynomial expansions are employed in each interval. Relative error on
        /// the domain [0,30] using IEEE arithmetic is documented [3] as having a
        /// peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).
        /// 
        /// References
        /// </summary>
        /// <returns>
        /// The modified Bessel function evaluated at each of the elements of x.
        /// </returns>
        public NDarray i0()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.i0(@this);
        }
        
        /// <summary>
        /// Unwrap by changing deltas between values to 2*pi complement.
        /// 
        /// Unwrap radian phase p by changing absolute jumps greater than
        /// discont to their 2*pi complement along the given axis.
        /// 
        /// Notes
        /// 
        /// If the discontinuity in p is smaller than pi, but larger than
        /// discont, no unwrapping is done because taking the 2*pi complement
        /// would only make the discontinuity larger.
        /// </summary>
        /// <param name="discont">
        /// Maximum discontinuity between values, default is pi.
        /// </param>
        /// <param name="axis">
        /// Axis along which unwrap will operate, default is the last axis.
        /// </param>
        /// <returns>
        /// Output array.
        /// </returns>
        public NDarray unwrap(float? discont = null, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.unwrap(@this, discont:discont, axis:axis);
        }
        
        /// <summary>
        /// Evenly round to the given number of decimals.
        /// 
        /// Notes
        /// 
        /// For values exactly halfway between rounded decimal values, NumPy
        /// rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,
        /// -0.5 and 0.5 round to 0.0, etc. Results may also be surprising due
        /// to the inexact representation of decimal fractions in the IEEE
        /// floating point standard [1] and errors introduced when scaling
        /// by powers of ten.
        /// 
        /// References
        /// </summary>
        /// <param name="decimals">
        /// Number of decimal places to round to (default: 0).  If
        /// decimals is negative, it specifies the number of positions to
        /// the left of the decimal point.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output, but the type of the output
        /// values will be cast if necessary. See doc.ufuncs (Section
        /// “Output arguments”) for details.
        /// </param>
        /// <returns>
        /// An array of the same type as a, containing the rounded values.
        /// Unless out was specified, a new array is created.  A reference to
        /// the result is returned.
        /// 
        /// The real and imaginary parts of complex numbers are rounded
        /// separately.  The result of rounding a float is a float.
        /// </returns>
        public NDarray around(int? decimals = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.around(@this, decimals:decimals, @out:@out);
        }
        
        /// <summary>
        /// Round to nearest integer towards zero.
        /// 
        /// Round an array of floats element-wise to nearest integer towards zero.
        /// The rounded values are returned as floats.
        /// </summary>
        /// <param name="y">
        /// Output array
        /// </param>
        /// <returns>
        /// The array of rounded numbers
        /// </returns>
        public NDarray fix(NDarray y = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.fix(@this, y:y);
        }
        
        /// <summary>
        /// Return the product of array elements over a given axis.
        /// 
        /// Notes
        /// 
        /// Arithmetic is modular when using integer types, and no error is
        /// raised on overflow.  That means that, on a 32-bit platform:
        /// 
        /// The product of an empty array is the neutral element 1:
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which a product is performed.  The default,
        /// axis=None, will calculate the product of all the elements in the
        /// input array. If axis is negative it counts from the last to the
        /// first axis.
        /// 
        /// If axis is a tuple of ints, a product is performed on all of the
        /// axes specified in the tuple instead of a single axis or all the
        /// axes as before.
        /// </param>
        /// <param name="dtype">
        /// The type of the returned array, as well as of the accumulator in
        /// which the elements are multiplied.  The dtype of a is used by
        /// default unless a has an integer dtype of less precision than the
        /// default platform integer.  In that case, if a is signed then the
        /// platform integer is used while if a is unsigned then an unsigned
        /// integer of the same precision as the platform integer is used.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output, but the type of the output
        /// values will be cast if necessary.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left in the
        /// result as dimensions with size one. With this option, the result
        /// will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the prod method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <param name="initial">
        /// The starting value for this product. See reduce for details.
        /// </param>
        /// <returns>
        /// An array shaped as a but with the specified axis removed.
        /// Returns a reference to out if specified.
        /// </returns>
        public NDarray prod(int[] axis = null, Dtype dtype = null, NDarray @out = null, bool? keepdims = null, ValueType initial = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.prod(@this, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims, initial:initial);
        }
        
        /// <summary>
        /// Sum of array elements over a given axis.
        /// 
        /// Notes
        /// 
        /// Arithmetic is modular when using integer types, and no error is
        /// raised on overflow.
        /// 
        /// The sum of an empty array is the neutral element 0:
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which a sum is performed.  The default,
        /// axis=None, will sum all of the elements of the input array.  If
        /// axis is negative it counts from the last to the first axis.
        /// 
        /// If axis is a tuple of ints, a sum is performed on all of the axes
        /// specified in the tuple instead of a single axis or all the axes as
        /// before.
        /// </param>
        /// <param name="dtype">
        /// The type of the returned array and of the accumulator in which the
        /// elements are summed.  The dtype of a is used by default unless a
        /// has an integer dtype of less precision than the default platform
        /// integer.  In that case, if a is signed then the platform integer
        /// is used while if a is unsigned then an unsigned integer of the
        /// same precision as the platform integer is used.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output, but the type of the output
        /// values will be cast if necessary.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the sum method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <param name="initial">
        /// Starting value for the sum. See reduce for details.
        /// </param>
        /// <returns>
        /// An array with the same shape as a, with the specified
        /// axis removed.   If a is a 0-d array, or if axis is None, a scalar
        /// is returned.  If an output array is specified, a reference to
        /// out is returned.
        /// </returns>
        public NDarray sum(int[] axis = null, Dtype dtype = null, NDarray @out = null, bool? keepdims = null, ValueType initial = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.sum(@this, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims, initial:initial);
        }
        
        /// <summary>
        /// Return the product of array elements over a given axis treating Not a
        /// Numbers (NaNs) as ones.
        /// 
        /// One is returned for slices that are all-NaN or empty.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the product is computed. The default is to compute
        /// the product of the flattened array.
        /// </param>
        /// <param name="dtype">
        /// The type of the returned array and of the accumulator in which the
        /// elements are summed.  By default, the dtype of a is used.  An
        /// exception is when a has an integer type with less precision than
        /// the platform (u)intp. In that case, the default will be either
        /// (u)int32 or (u)int64 depending on whether the platform is 32 or 64
        /// bits. For inexact inputs, dtype must be inexact.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None. If provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.  See
        /// doc.ufuncs for details. The casting of NaN to integer can yield
        /// unexpected results.
        /// </param>
        /// <param name="keepdims">
        /// If True, the axes which are reduced are left in the result as
        /// dimensions with size one. With this option, the result will
        /// broadcast correctly against the original arr.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which case it is returned.
        /// </returns>
        public NDarray nanprod(int[] axis = null, Dtype dtype = null, NDarray @out = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanprod(@this, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims);
        }
        
        /// <summary>
        /// Return the sum of array elements over a given axis treating Not a
        /// Numbers (NaNs) as zero.
        /// 
        /// In NumPy versions &lt;= 1.9.0 Nan is returned for slices that are all-NaN or
        /// empty. In later versions zero is returned.
        /// 
        /// Notes
        /// 
        /// If both positive and negative infinity are present, the sum will be Not
        /// A Number (NaN).
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the sum is computed. The default is to compute the
        /// sum of the flattened array.
        /// </param>
        /// <param name="dtype">
        /// The type of the returned array and of the accumulator in which the
        /// elements are summed.  By default, the dtype of a is used.  An
        /// exception is when a has an integer type with less precision than
        /// the platform (u)intp. In that case, the default will be either
        /// (u)int32 or (u)int64 depending on whether the platform is 32 or 64
        /// bits. For inexact inputs, dtype must be inexact.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None. If provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.  See
        /// doc.ufuncs for details. The casting of NaN to integer can yield
        /// unexpected results.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// 
        /// If the value is anything but the default, then
        /// keepdims will be passed through to the mean or sum methods
        /// of sub-classes of ndarray.  If the sub-classes methods
        /// does not implement keepdims any exceptions will be raised.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which it is returned. The result has the same
        /// size as a, and the same shape as a if axis is not None
        /// or a is a 1-d array.
        /// </returns>
        public NDarray nansum(int[] axis = null, Dtype dtype = null, NDarray @out = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nansum(@this, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims);
        }
        
        /// <summary>
        /// Return the cumulative product of elements along a given axis.
        /// 
        /// Notes
        /// 
        /// Arithmetic is modular when using integer types, and no error is
        /// raised on overflow.
        /// </summary>
        /// <param name="axis">
        /// Axis along which the cumulative product is computed.  By default
        /// the input is flattened.
        /// </param>
        /// <param name="dtype">
        /// Type of the returned array, as well as of the accumulator in which
        /// the elements are multiplied.  If dtype is not specified, it
        /// defaults to the dtype of a, unless a has an integer dtype with
        /// a precision less than that of the default platform integer.  In
        /// that case, the default platform integer is used instead.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output
        /// but the type of the resulting values will be cast if necessary.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which case a reference to out is returned.
        /// </returns>
        public NDarray cumprod(int? axis = null, Dtype dtype = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.cumprod(@this, axis:axis, dtype:dtype, @out:@out);
        }
        
        /// <summary>
        /// Return the cumulative sum of the elements along a given axis.
        /// 
        /// Notes
        /// 
        /// Arithmetic is modular when using integer types, and no error is
        /// raised on overflow.
        /// </summary>
        /// <param name="axis">
        /// Axis along which the cumulative sum is computed. The default
        /// (None) is to compute the cumsum over the flattened array.
        /// </param>
        /// <param name="dtype">
        /// Type of the returned array and of the accumulator in which the
        /// elements are summed.  If dtype is not specified, it defaults
        /// to the dtype of a, unless a has an integer dtype with a
        /// precision less than that of the default platform integer.  In
        /// that case, the default platform integer is used.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output
        /// but the type will be cast if necessary. See doc.ufuncs
        /// (Section “Output arguments”) for more details.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which case a reference to out is returned. The
        /// result has the same size as a, and the same shape as a if
        /// axis is not None or a is a 1-d array.
        /// </returns>
        public NDarray cumsum(int? axis = null, Dtype dtype = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.cumsum(@this, axis:axis, dtype:dtype, @out:@out);
        }
        
        /// <summary>
        /// Return the cumulative product of array elements over a given axis treating Not a
        /// Numbers (NaNs) as one.  The cumulative product does not change when NaNs are
        /// encountered and leading NaNs are replaced by ones.
        /// 
        /// Ones are returned for slices that are all-NaN or empty.
        /// </summary>
        /// <param name="axis">
        /// Axis along which the cumulative product is computed.  By default
        /// the input is flattened.
        /// </param>
        /// <param name="dtype">
        /// Type of the returned array, as well as of the accumulator in which
        /// the elements are multiplied.  If dtype is not specified, it
        /// defaults to the dtype of a, unless a has an integer dtype with
        /// a precision less than that of the default platform integer.  In
        /// that case, the default platform integer is used instead.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output
        /// but the type of the resulting values will be cast if necessary.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which case it is returned.
        /// </returns>
        public NDarray nancumprod(int? axis = null, Dtype dtype = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nancumprod(@this, axis:axis, dtype:dtype, @out:@out);
        }
        
        /// <summary>
        /// Return the cumulative sum of array elements over a given axis treating Not a
        /// Numbers (NaNs) as zero.  The cumulative sum does not change when NaNs are
        /// encountered and leading NaNs are replaced by zeros.
        /// 
        /// Zeros are returned for slices that are all-NaN or empty.
        /// </summary>
        /// <param name="axis">
        /// Axis along which the cumulative sum is computed. The default
        /// (None) is to compute the cumsum over the flattened array.
        /// </param>
        /// <param name="dtype">
        /// Type of the returned array and of the accumulator in which the
        /// elements are summed.  If dtype is not specified, it defaults
        /// to the dtype of a, unless a has an integer dtype with a
        /// precision less than that of the default platform integer.  In
        /// that case, the default platform integer is used.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output
        /// but the type will be cast if necessary. See doc.ufuncs
        /// (Section “Output arguments”) for more details.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which it is returned. The result has the same
        /// size as a, and the same shape as a if axis is not None
        /// or a is a 1-d array.
        /// </returns>
        public NDarray nancumsum(int? axis = null, Dtype dtype = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nancumsum(@this, axis:axis, dtype:dtype, @out:@out);
        }
        
        /// <summary>
        /// Calculate the n-th discrete difference along the given axis.
        /// 
        /// The first difference is given by out[n] = a[n+1] - a[n] along
        /// the given axis, higher differences are calculated by using diff
        /// recursively.
        /// 
        /// Notes
        /// 
        /// Type is preserved for boolean arrays, so the result will contain
        /// False when consecutive elements are the same and True when they
        /// differ.
        /// 
        /// For unsigned integer arrays, the results will also be unsigned. This
        /// should not be surprising, as the result is consistent with
        /// calculating the difference directly:
        /// 
        /// If this is not desirable, then the array should be cast to a larger
        /// integer type first:
        /// </summary>
        /// <param name="n">
        /// The number of times values are differenced. If zero, the input
        /// is returned as-is.
        /// </param>
        /// <param name="axis">
        /// The axis along which the difference is taken, default is the
        /// last axis.
        /// </param>
        /// <param name="prepend">
        /// Values to prepend or append to “a” along axis prior to
        /// performing the difference.  Scalar values are expanded to
        /// arrays with length 1 in the direction of axis and the shape
        /// of the input array in along all other axes.  Otherwise the
        /// dimension and shape must match “a” except along axis.
        /// </param>
        /// <returns>
        /// The n-th differences. The shape of the output is the same as a
        /// except along axis where the dimension is smaller by n. The
        /// type of the output is the same as the type of the difference
        /// between any two elements of a. This is the same as the type of
        /// a in most cases. A notable exception is datetime64, which
        /// results in a timedelta64 output array.
        /// </returns>
        public NDarray diff(int? n = null, int? axis = null, NDarray prepend = null, NDarray append = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.diff(@this, n:n, axis:axis, prepend:prepend, append:append);
        }
        
        /// <summary>
        /// The differences between consecutive elements of an array.
        /// 
        /// Notes
        /// 
        /// When applied to masked arrays, this function drops the mask information
        /// if the to_begin and/or to_end parameters are used.
        /// </summary>
        /// <param name="to_end">
        /// Number(s) to append at the end of the returned differences.
        /// </param>
        /// <param name="to_begin">
        /// Number(s) to prepend at the beginning of the returned differences.
        /// </param>
        /// <returns>
        /// The differences. Loosely, this is ary.flat[1:] - ary.flat[:-1].
        /// </returns>
        public NDarray ediff1d(NDarray to_end = null, NDarray to_begin = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.ediff1d(@this, to_end:to_end, to_begin:to_begin);
        }
        
        /// <summary>
        /// Return the gradient of an N-dimensional array.
        /// 
        /// The gradient is computed using second order accurate central differences
        /// in the interior points and either first or second order accurate one-sides
        /// (forward or backwards) differences at the boundaries.
        /// The returned gradient hence has the same shape as the input array.
        /// 
        /// Notes
        /// 
        /// Assuming that  (i.e.,  has at least 3 continuous
        /// derivatives) and let  be a non-homogeneous stepsize, we
        /// minimize the “consistency error”  between the true gradient
        /// and its estimate from a linear combination of the neighboring grid-points:
        /// 
        /// By substituting  and 
        /// with their Taylor series expansion, this translates into solving
        /// the following the linear system:
        /// 
        /// The resulting approximation of  is the following:
        /// 
        /// It is worth noting that if 
        /// (i.e., data are evenly spaced)
        /// we find the standard second order approximation:
        /// 
        /// With a similar procedure the forward/backward approximations used for
        /// boundaries can be derived.
        /// 
        /// References
        /// </summary>
        /// <param name="varargs">
        /// Spacing between f values. Default unitary spacing for all dimensions.
        /// Spacing can be specified using:
        /// 
        /// If axis is given, the number of varargs must equal the number of axes.
        /// Default: 1.
        /// </param>
        /// <param name="edge_order">
        /// Gradient is calculated using N-th order accurate differences
        /// at the boundaries. Default: 1.
        /// </param>
        /// <param name="axis">
        /// Gradient is calculated only along the given axis or axes
        /// The default (axis = None) is to calculate the gradient for all the axes
        /// of the input array. axis may be negative, in which case it counts from
        /// the last to the first axis.
        /// </param>
        /// <returns>
        /// A set of ndarrays (or a single ndarray if there is only one dimension)
        /// corresponding to the derivatives of f with respect to each dimension.
        /// Each derivative has the same shape as f.
        /// </returns>
        public NDarray gradient(NDarray varargs = null, int? edge_order = null, int[] axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.gradient(@this, varargs:varargs, edge_order:edge_order, axis:axis);
        }
        
        /// <summary>
        /// Return the cross product of two (arrays of) vectors.
        /// 
        /// The cross product of a and b in  is a vector perpendicular
        /// to both a and b.  If a and b are arrays of vectors, the vectors
        /// are defined by the last axis of a and b by default, and these axes
        /// can have dimensions 2 or 3.  Where the dimension of either a or b is
        /// 2, the third component of the input vector is assumed to be zero and the
        /// cross product calculated accordingly.  In cases where both input vectors
        /// have dimension 2, the z-component of the cross product is returned.
        /// 
        /// Notes
        /// 
        /// Supports full broadcasting of the inputs.
        /// </summary>
        /// <param name="b">
        /// Components of the second vector(s).
        /// </param>
        /// <param name="axisa">
        /// Axis of a that defines the vector(s).  By default, the last axis.
        /// </param>
        /// <param name="axisb">
        /// Axis of b that defines the vector(s).  By default, the last axis.
        /// </param>
        /// <param name="axisc">
        /// Axis of c containing the cross product vector(s).  Ignored if
        /// both input vectors have dimension 2, as the return is scalar.
        /// By default, the last axis.
        /// </param>
        /// <param name="axis">
        /// If defined, the axis of a, b and c that defines the vector(s)
        /// and cross product(s).  Overrides axisa, axisb and axisc.
        /// </param>
        /// <returns>
        /// Vector cross product(s).
        /// </returns>
        public NDarray cross(NDarray b, int? axisa = null, int? axisb = null, int? axisc = null, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.cross(@this, b, axisa:axisa, axisb:axisb, axisc:axisc, axis:axis);
        }
        
        /// <summary>
        /// Integrate along the given axis using the composite trapezoidal rule.
        /// 
        /// Integrate y (x) along given axis.
        /// 
        /// Notes
        /// 
        /// Image [2] illustrates trapezoidal rule – y-axis locations of points
        /// will be taken from y array, by default x-axis distances between
        /// points will be 1.0, alternatively they can be provided with x array
        /// or with dx scalar.  Return value will be equal to combined area under
        /// the red lines.
        /// 
        /// References
        /// </summary>
        /// <param name="x">
        /// The sample points corresponding to the y values. If x is None,
        /// the sample points are assumed to be evenly spaced dx apart. The
        /// default is None.
        /// </param>
        /// <param name="dx">
        /// The spacing between sample points when x is None. The default is 1.
        /// </param>
        /// <param name="axis">
        /// The axis along which to integrate.
        /// </param>
        /// <returns>
        /// Definite integral as approximated by trapezoidal rule.
        /// </returns>
        public float trapz(NDarray x = null, ValueType dx = null, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.trapz(@this, x:x, dx:dx, axis:axis);
        }
        
        /// <summary>
        /// Return the sinc function.
        /// 
        /// The sinc function is .
        /// 
        /// Notes
        /// 
        /// sinc(0) is the limit value 1.
        /// 
        /// The name sinc is short for “sine cardinal” or “sinus cardinalis”.
        /// 
        /// The sinc function is used in various signal processing applications,
        /// including in anti-aliasing, in the construction of a Lanczos resampling
        /// filter, and in interpolation.
        /// 
        /// For bandlimited interpolation of discrete-time signals, the ideal
        /// interpolation kernel is proportional to the sinc function.
        /// 
        /// References
        /// </summary>
        /// <returns>
        /// sinc(x), which has the same shape as the input.
        /// </returns>
        public NDarray sinc()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.sinc(@this);
        }
        
        /// <summary>
        /// Return the angle of the complex argument.
        /// </summary>
        /// <param name="deg">
        /// Return angle in degrees if True, radians if False (default).
        /// </param>
        /// <returns>
        /// The counterclockwise angle from the positive real axis on
        /// the complex plane, with dtype as numpy.float64.
        /// </returns>
        public NDarray angle(bool? deg = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.angle(@this, deg:deg);
        }
        
        /// <summary>
        /// Return the real part of the complex argument.
        /// </summary>
        /// <returns>
        /// The real component of the complex argument. If val is real, the type
        /// of val is used for the output.  If val has complex elements, the
        /// returned type is float.
        /// </returns>
        public NDarray real()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.real(@this);
        }
        
        /// <summary>
        /// Return the imaginary part of the complex argument.
        /// </summary>
        /// <returns>
        /// The imaginary component of the complex argument. If val is real,
        /// the type of val is used for the output.  If val has complex
        /// elements, the returned type is float.
        /// </returns>
        public NDarray imag()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.imag(@this);
        }
        
        /// <summary>
        /// Returns the discrete, linear convolution of two one-dimensional sequences.
        /// 
        /// The convolution operator is often seen in signal processing, where it
        /// models the effect of a linear time-invariant system on a signal [1].  In
        /// probability theory, the sum of two independent random variables is
        /// distributed according to the convolution of their individual
        /// distributions.
        /// 
        /// If v is longer than a, the arrays are swapped before computation.
        /// 
        /// Notes
        /// 
        /// The discrete convolution operation is defined as
        /// 
        /// It can be shown that a convolution  in time/space
        /// is equivalent to the multiplication  in the Fourier
        /// domain, after appropriate padding (padding is necessary to prevent
        /// circular convolution).  Since multiplication is more efficient (faster)
        /// than convolution, the function scipy.signal.fftconvolve exploits the
        /// FFT to calculate the convolution of large data-sets.
        /// 
        /// References
        /// </summary>
        /// <param name="v">
        /// Second one-dimensional input array.
        /// </param>
        /// <returns>
        /// Discrete, linear convolution of a and v.
        /// </returns>
        public NDarray convolve(NDarray v, string mode = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.convolve(@this, v, mode:mode);
        }
        
        /// <summary>
        /// Clip (limit) the values in an array.
        /// 
        /// Given an interval, values outside the interval are clipped to
        /// the interval edges.  For example, if an interval of [0, 1]
        /// is specified, values smaller than 0 become 0, and values larger
        /// than 1 become 1.
        /// </summary>
        /// <param name="a_min">
        /// Minimum value. If None, clipping is not performed on lower
        /// interval edge. Not more than one of a_min and a_max may be
        /// None.
        /// </param>
        /// <param name="a_max">
        /// Maximum value. If None, clipping is not performed on upper
        /// interval edge. Not more than one of a_min and a_max may be
        /// None. If a_min or a_max are array_like, then the three
        /// arrays will be broadcasted to match their shapes.
        /// </param>
        /// <param name="@out">
        /// The results will be placed in this array. It may be the input
        /// array for in-place clipping.  out must be of the right shape
        /// to hold the output.  Its type is preserved.
        /// </param>
        /// <returns>
        /// An array with the elements of a, but where values
        /// &lt; a_min are replaced with a_min, and those &gt; a_max
        /// with a_max.
        /// </returns>
        public NDarray clip(NDarray a_min, NDarray a_max, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.clip(@this, a_min, a_max, @out:@out);
        }
        
        /// <summary>
        /// Replace NaN with zero and infinity with large finite numbers.
        /// 
        /// If x is inexact, NaN is replaced by zero, and infinity and -infinity
        /// replaced by the respectively largest and most negative finite floating
        /// point values representable by x.dtype.
        /// 
        /// For complex dtypes, the above is applied to each of the real and
        /// imaginary components of x separately.
        /// 
        /// If x is not inexact, then no replacements are made.
        /// 
        /// Notes
        /// 
        /// NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
        /// (IEEE 754). This means that Not a Number is not equivalent to infinity.
        /// </summary>
        /// <param name="copy">
        /// Whether to create a copy of x (True) or to replace values
        /// in-place (False). The in-place operation only occurs if
        /// casting to an array does not require a copy.
        /// Default is True.
        /// </param>
        /// <returns>
        /// x, with the non-finite values replaced. If copy is False, this may
        /// be x itself.
        /// </returns>
        public NDarray nan_to_num(bool? copy = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nan_to_num(@this, copy:copy);
        }
        
        /// <summary>
        /// If complex input returns a real array if complex parts are close to zero.
        /// 
        /// “Close to zero” is defined as tol * (machine epsilon of the type for
        /// a).
        /// 
        /// Notes
        /// 
        /// Machine epsilon varies from machine to machine and between data types
        /// but Python floats on most platforms have a machine epsilon equal to
        /// 2.2204460492503131e-16.  You can use ‘np.finfo(float).eps’ to print
        /// out the machine epsilon for floats.
        /// </summary>
        /// <param name="tol">
        /// Tolerance in machine epsilons for the complex part of the elements
        /// in the array.
        /// </param>
        /// <returns>
        /// If a is real, the type of a is used for the output.  If a
        /// has complex elements, the returned type is float.
        /// </returns>
        public NDarray real_if_close(float tol)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.real_if_close(@this, tol);
        }
        
        /*
        /// <summary>
        /// One-dimensional linear interpolation.
        /// 
        /// Returns the one-dimensional piecewise linear interpolant to a function
        /// with given discrete data points (xp, fp), evaluated at x.
        /// 
        /// Notes
        /// 
        /// Does not check that the x-coordinate sequence xp is increasing.
        /// If xp is not increasing, the results are nonsense.
        /// A simple check for increasing is:
        /// </summary>
        /// <param name="xp">
        /// The x-coordinates of the data points, must be increasing if argument
        /// period is not specified. Otherwise, xp is internally sorted after
        /// normalizing the periodic boundaries with xp = xp % period.
        /// </param>
        /// <param name="fp">
        /// The y-coordinates of the data points, same length as xp.
        /// </param>
        /// <param name="left">
        /// Value to return for x &lt; xp[0], default is fp[0].
        /// </param>
        /// <param name="right">
        /// Value to return for x &gt; xp[-1], default is fp[-1].
        /// </param>
        /// <param name="period">
        /// A period for the x-coordinates. This parameter allows the proper
        /// interpolation of angular x-coordinates. Parameters left and right
        /// are ignored if period is specified.
        /// </param>
        /// <returns>
        /// The interpolated values, same shape as x.
        /// </returns>
        public float or complex (corresponding to fp) or ndarray interp(1-D sequence of floats xp, 1-D sequence of float or complex fp, optional float or complex corresponding to fp left = null, optional float or complex corresponding to fp right = null, None or float period = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.interp(@this, xp, fp, left:left, right:right, period:period);
        }
        */
        
    }
}
