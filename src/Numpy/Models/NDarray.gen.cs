// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Python.Runtime;
using Python.Included;
using Numpy.Models;

namespace Numpy
{
    public partial class NDarray
    {
        
        /// <summary>
        /// Copy an element of an array to a standard Python scalar and return it.
        /// 
        /// Notes
        /// 
        /// When the data type of a is longdouble or clongdouble, item() returns
        /// a scalar array object because there is no available Python scalar that
        /// would not lose information. Void arrays return a buffer object for item(),
        /// unless fields are defined, in which case a tuple is returned.
        /// 
        /// item is very similar to a[args], except, instead of an array scalar,
        /// a standard Python scalar is returned. This can be useful for speeding up
        /// access to elements of the array and doing arithmetic on elements of the
        /// array using Python’s optimized math.
        /// </summary>
        /// <returns>
        /// A copy of the specified element of the array as a suitable
        /// Python scalar
        /// </returns>
        public T item<T>(params int[] args)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                args,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("item", pyargs, kwargs);
            return ToCsharp<T>(py);
        }
        
        /// <summary>
        /// Return the array as a (possibly nested) list.
        /// 
        /// Return a copy of the array data as a (nested) Python list.
        /// Data items are converted to the nearest compatible Python type.
        /// 
        /// Notes
        /// 
        /// The array may be recreated, a = np.array(a.tolist()).
        /// </summary>
        /// <returns>
        /// The possibly nested list of array elements.
        /// </returns>
        public List<T> tolist<T>()
        {
            //auto-generated code, do not change
            var __self__=self;
            dynamic py = __self__.InvokeMethod("tolist");
            return ToCsharp<List<T>>(py);
        }
        
        /// <summary>
        /// Write array to a file as text or binary (default).
        /// 
        /// Data is always written in ‘C’ order, independent of the order of a.
        /// The data produced by this method can be recovered using the function
        /// fromfile().
        /// 
        /// Notes
        /// 
        /// This is a convenience function for quick storage of array data.
        /// Information on endianness and precision is lost, so this method is not a
        /// good choice for files intended to archive data or transport data between
        /// machines with different endianness. Some of these problems can be overcome
        /// by outputting the data as text files, at the expense of speed and file
        /// size.
        /// 
        /// When fid is a file object, array contents are directly written to the
        /// file, bypassing the file object’s write method. As a result, tofile
        /// cannot be used with files objects supporting compression (e.g., GzipFile)
        /// or file-like objects that do not support fileno() (e.g., BytesIO).
        /// </summary>
        /// <param name="fid">
        /// An open file object, or a string containing a filename.
        /// </param>
        /// <param name="sep">
        /// Separator between array items for text output.
        /// If “” (empty), a binary file is written, equivalent to
        /// file.write(a.tobytes()).
        /// </param>
        /// <param name="format">
        /// Format string for text file output.
        /// Each entry in the array is formatted to text by first converting
        /// it to the closest Python type, and then using “format” % item.
        /// </param>
        public void tofile(string fid, string sep, string format)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                fid,
                sep,
                format,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("tofile", pyargs, kwargs);
        }
        
        /// <summary>
        /// Dump a pickle of the array to the specified file.
        /// The array can be read back with pickle.load or numpy.load.
        /// </summary>
        /// <param name="file">
        /// A string naming the dump file.
        /// </param>
        public void dump(string file)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                file,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("dump", pyargs, kwargs);
        }
        
        /// <summary>
        /// Returns the pickle of the array as a string.
        /// pickle.loads or numpy.loads will convert the string back to an array.
        /// </summary>
        public void dumps()
        {
            //auto-generated code, do not change
            var __self__=self;
            dynamic py = __self__.InvokeMethod("dumps");
        }
        
        /// <summary>
        /// Copy of the array, cast to a specified type.
        /// 
        /// Notes
        /// 
        /// Starting in NumPy 1.9, astype method now returns an error if the string
        /// dtype to cast to is not long enough in ‘safe’ casting mode to hold the max
        /// value of integer/float array that is being casted. Previously the casting
        /// was allowed even if the result was truncated.
        /// </summary>
        /// <param name="dtype">
        /// Typecode or data-type to which the array is cast.
        /// </param>
        /// <param name="order">
        /// Controls the memory layout order of the result.
        /// ‘C’ means C order, ‘F’ means Fortran order, ‘A’
        /// means ‘F’ order if all the arrays are Fortran contiguous,
        /// ‘C’ order otherwise, and ‘K’ means as close to the
        /// order the array elements appear in memory as possible.
        /// Default is ‘K’.
        /// </param>
        /// <param name="casting">
        /// Controls what kind of data casting may occur. Defaults to ‘unsafe’
        /// for backwards compatibility.
        /// </param>
        /// <param name="subok">
        /// If True, then sub-classes will be passed-through (default), otherwise
        /// the returned array will be forced to be a base-class array.
        /// </param>
        /// <param name="copy">
        /// By default, astype always returns a newly allocated array. If this
        /// is set to false, and the dtype, order, and subok
        /// requirements are satisfied, the input array is returned instead
        /// of a copy.
        /// </param>
        /// <returns>
        /// Unless copy is False and the other conditions for returning the input
        /// array are satisfied (see description for copy input parameter), arr_t
        /// is a new array of the same shape as the input array, with dtype, order
        /// given by dtype, order.
        /// </returns>
        public NDarray astype(Dtype dtype, string order = null, string casting = null, bool? subok = null, bool? copy = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                dtype,
            });
            var kwargs=new PyDict();
            if (order!=null) kwargs["order"]=ToPython(order);
            if (casting!=null) kwargs["casting"]=ToPython(casting);
            if (subok!=null) kwargs["subok"]=ToPython(subok);
            if (copy!=null) kwargs["copy"]=ToPython(copy);
            dynamic py = __self__.InvokeMethod("astype", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Swap the bytes of the array elements
        /// 
        /// Toggle between low-endian and big-endian data representation by
        /// returning a byteswapped array, optionally swapped in-place.
        /// </summary>
        /// <param name="inplace">
        /// If True, swap bytes in-place, default is False.
        /// </param>
        /// <returns>
        /// The byteswapped array. If inplace is True, this is
        /// a view to self.
        /// </returns>
        public NDarray byteswap(bool? inplace = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (inplace!=null) kwargs["inplace"]=ToPython(inplace);
            dynamic py = __self__.InvokeMethod("byteswap", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Return a copy of the array.
        /// </summary>
        /// <param name="order">
        /// Controls the memory layout of the copy. ‘C’ means C-order,
        /// ‘F’ means F-order, ‘A’ means ‘F’ if a is Fortran contiguous,
        /// ‘C’ otherwise. ‘K’ means match the layout of a as closely
        /// as possible. (Note that this function and numpy.copy are very
        /// similar, but have different default values for their order=
        /// arguments.)
        /// </param>
        public void copy(string order = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (order!=null) kwargs["order"]=ToPython(order);
            dynamic py = __self__.InvokeMethod("copy", pyargs, kwargs);
        }
        
        /// <summary>
        /// Returns a field of the given array as a certain type.
        /// 
        /// A field is a view of the array data with a given data-type. The values in
        /// the view are determined by the given type and the offset into the current
        /// array in bytes. The offset needs to be such that the view dtype fits in the
        /// array dtype; for example an array of dtype complex128 has 16-byte elements.
        /// If taking a view with a 32-bit integer (4 bytes), the offset needs to be
        /// between 0 and 12 bytes.
        /// </summary>
        /// <param name="dtype">
        /// The data type of the view. The dtype size of the view can not be larger
        /// than that of the array itself.
        /// </param>
        /// <param name="offset">
        /// Number of bytes to skip before beginning the element view.
        /// </param>
        public void getfield(Dtype dtype, int offset)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                dtype,
                offset,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("getfield", pyargs, kwargs);
        }
        
        /// <summary>
        /// Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),
        /// respectively.
        /// 
        /// These Boolean-valued flags affect how numpy interprets the memory
        /// area used by a (see Notes below). The ALIGNED flag can only
        /// be set to True if the data is actually aligned according to the type.
        /// The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set
        /// to True. The flag WRITEABLE can only be set to True if the array owns its
        /// own memory, or the ultimate owner of the memory exposes a writeable buffer
        /// interface, or is a string. (The exception for string is made so that
        /// unpickling can be done without copying memory.)
        /// 
        /// Notes
        /// 
        /// Array flags provide information about how the memory area used
        /// for the array is to be interpreted. There are 7 Boolean flags
        /// in use, only four of which can be changed by the user:
        /// WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.
        /// 
        /// WRITEABLE (W) the data area can be written to;
        /// 
        /// ALIGNED (A) the data and strides are aligned appropriately for the hardware
        /// (as determined by the compiler);
        /// 
        /// UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;
        /// 
        /// WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced
        /// by .base). When the C-API function PyArray_ResolveWritebackIfCopy is
        /// called, the base array will be updated with the contents of this array.
        /// 
        /// All flags can be accessed using the single (upper case) letter as well
        /// as the full name.
        /// </summary>
        /// <param name="write">
        /// Describes whether or not a can be written to.
        /// </param>
        /// <param name="align">
        /// Describes whether or not a is aligned properly for its type.
        /// </param>
        /// <param name="uic">
        /// Describes whether or not a is a copy of another “base” array.
        /// </param>
        public void setflags(bool? write = null, bool? align = null, bool? uic = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (write!=null) kwargs["write"]=ToPython(write);
            if (align!=null) kwargs["align"]=ToPython(align);
            if (uic!=null) kwargs["uic"]=ToPython(uic);
            dynamic py = __self__.InvokeMethod("setflags", pyargs, kwargs);
        }
        
        /// <summary>
        /// Fill the array with a scalar value.
        /// </summary>
        /// <param name="@value">
        /// All elements of a will be assigned this value.
        /// </param>
        public void fill(ValueType @value)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                @value,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("fill", pyargs, kwargs);
        }
        
        /// <summary>
        /// Returns a view of the array with axes transposed.
        /// 
        /// For a 1-D array, this has no effect. (To change between column and
        /// row vectors, first cast the 1-D array into a matrix object.)
        /// For a 2-D array, this is the usual matrix transpose.
        /// For an n-D array, if axes are given, their order indicates how the
        /// axes are permuted (see Examples). If axes are not provided and
        /// a.shape = (i[0], i[1], ... i[n-2], i[n-1]), then
        /// a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0]).
        /// </summary>
        /// <returns>
        /// View of a, with axes suitably permuted.
        /// </returns>
        public NDarray transpose(int[] axes = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                axes,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("transpose", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Return a copy of the array collapsed into one dimension.
        /// </summary>
        /// <param name="order">
        /// ‘C’ means to flatten in row-major (C-style) order.
        /// ‘F’ means to flatten in column-major (Fortran-
        /// style) order. ‘A’ means to flatten in column-major
        /// order if a is Fortran contiguous in memory,
        /// row-major order otherwise. ‘K’ means to flatten
        /// a in the order the elements occur in memory.
        /// The default is ‘C’.
        /// </param>
        /// <returns>
        /// A copy of the input array, flattened to one dimension.
        /// </returns>
        public NDarray flatten(string order = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (order!=null) kwargs["order"]=ToPython(order);
            dynamic py = __self__.InvokeMethod("flatten", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// For unpickling.
        /// 
        /// The state argument must be a sequence that contains the following
        /// elements:
        /// </summary>
        /// <param name="version">
        /// optional pickle version. If omitted defaults to 0.
        /// </param>
        /// <param name="rawdata">
        /// a binary string with the data (or a list if ‘a’ is an object array)
        /// </param>
        public void __setstate__(int version, Shape shape, Dtype dtype, bool isFortran, string rawdata)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                version,
                shape,
                dtype,
                isFortran,
                rawdata,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("__setstate__", pyargs, kwargs);
        }
        
        /// <summary>
        /// Gives a new shape to an array without changing its data.
        /// 
        /// Notes
        /// 
        /// It is not always possible to change the shape of an array without
        /// copying the data. If you want an error to be raised when the data is copied,
        /// you should assign the new shape to the shape attribute of the array:
        /// 
        /// The order keyword gives the index ordering both for fetching the values
        /// from a, and then placing the values into the output array.
        /// For example, let’s say you have an array:
        /// 
        /// You can think of reshaping as first raveling the array (using the given
        /// index order), then inserting the elements from the raveled array into the
        /// new array using the same kind of index ordering as was used for the
        /// raveling.
        /// </summary>
        /// <param name="newshape">
        /// The new shape should be compatible with the original shape. If
        /// an integer, then the result will be a 1-D array of that length.
        /// One shape dimension can be -1. In this case, the value is
        /// inferred from the length of the array and remaining dimensions.
        /// </param>
        /// <param name="order">
        /// Read the elements of a using this index order, and place the
        /// elements into the reshaped array using this index order.  ‘C’
        /// means to read / write the elements using C-like index order,
        /// with the last axis index changing fastest, back to the first
        /// axis index changing slowest. ‘F’ means to read / write the
        /// elements using Fortran-like index order, with the first index
        /// changing fastest, and the last index changing slowest. Note that
        /// the ‘C’ and ‘F’ options take no account of the memory layout of
        /// the underlying array, and only refer to the order of indexing.
        /// ‘A’ means to read / write the elements in Fortran-like index
        /// order if a is Fortran contiguous in memory, C-like order
        /// otherwise.
        /// </param>
        /// <returns>
        /// This will be a new view object if possible; otherwise, it will
        /// be a copy.  Note there is no guarantee of the memory layout (C- or
        /// Fortran- contiguous) of the returned array.
        /// </returns>
        public NDarray reshape(Shape newshape, string order = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.reshape(@this, newshape, order:order);
        }
        
        /// <summary>
        /// Return a contiguous flattened array.
        /// 
        /// A 1-D array, containing the elements of the input, is returned.  A copy is
        /// made only if needed.
        /// 
        /// As of NumPy 1.10, the returned array will have the same type as the input
        /// array. (for example, a masked array will be returned for a masked array
        /// input)
        /// 
        /// Notes
        /// 
        /// In row-major, C-style order, in two dimensions, the row index
        /// varies the slowest, and the column index the quickest.  This can
        /// be generalized to multiple dimensions, where row-major order
        /// implies that the index along the first axis varies slowest, and
        /// the index along the last quickest.  The opposite holds for
        /// column-major, Fortran-style index ordering.
        /// 
        /// When a view is desired in as many cases as possible, arr.reshape(-1)
        /// may be preferable.
        /// </summary>
        /// <param name="order">
        /// The elements of a are read using this index order. ‘C’ means
        /// to index the elements in row-major, C-style order,
        /// with the last axis index changing fastest, back to the first
        /// axis index changing slowest.  ‘F’ means to index the elements
        /// in column-major, Fortran-style order, with the
        /// first index changing fastest, and the last index changing
        /// slowest. Note that the ‘C’ and ‘F’ options take no account of
        /// the memory layout of the underlying array, and only refer to
        /// the order of axis indexing.  ‘A’ means to read the elements in
        /// Fortran-like index order if a is Fortran contiguous in
        /// memory, C-like order otherwise.  ‘K’ means to read the
        /// elements in the order they occur in memory, except for
        /// reversing the data when strides are negative.  By default, ‘C’
        /// index order is used.
        /// </param>
        /// <returns>
        /// y is an array of the same subtype as a, with shape (a.size,).
        /// Note that matrices are special cased for backward compatibility, if a
        /// is a matrix, then y is a 1-D ndarray.
        /// </returns>
        public NDarray ravel(string order = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.ravel(@this, order:order);
        }
        
        /// <summary>
        /// Move axes of an array to new positions.
        /// 
        /// Other axes remain in their original order.
        /// </summary>
        /// <param name="source">
        /// Original positions of the axes to move. These must be unique.
        /// </param>
        /// <param name="destination">
        /// Destination positions for each of the original axes. These must also be
        /// unique.
        /// </param>
        /// <returns>
        /// Array with moved axes. This array is a view of the input array.
        /// </returns>
        public NDarray moveaxis(int[] source, int[] destination)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.moveaxis(@this, source, destination);
        }
        
        /// <summary>
        /// Roll the specified axis backwards, until it lies in a given position.
        /// 
        /// This function continues to be supported for backward compatibility, but you
        /// should prefer moveaxis. The moveaxis function was added in NumPy
        /// 1.11.
        /// </summary>
        /// <param name="axis">
        /// The axis to roll backwards.  The positions of the other axes do not
        /// change relative to one another.
        /// </param>
        /// <param name="start">
        /// The axis is rolled until it lies before this position.  The default,
        /// 0, results in a “complete” roll.
        /// </param>
        /// <returns>
        /// For NumPy &gt;= 1.10.0 a view of a is always returned. For earlier
        /// NumPy versions a view of a is returned only if the order of the
        /// axes is changed, otherwise the input array is returned.
        /// </returns>
        public NDarray rollaxis(int axis, int? start = 0)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.rollaxis(@this, axis, start:start);
        }
        
        /// <summary>
        /// Interchange two axes of an array.
        /// </summary>
        /// <param name="axis1">
        /// First axis.
        /// </param>
        /// <param name="axis2">
        /// Second axis.
        /// </param>
        /// <returns>
        /// For NumPy &gt;= 1.10.0, if a is an ndarray, then a view of a is
        /// returned; otherwise a new array is created. For earlier NumPy
        /// versions a view of a is returned only if the order of the
        /// axes is changed, otherwise the input array is returned.
        /// </returns>
        public NDarray swapaxes(int axis1, int axis2)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.swapaxes(@this, axis1, axis2);
        }
        
        /// <summary>
        /// Produce an object that mimics broadcasting.
        /// </summary>
        /// <param name="in1">
        /// Input parameters.
        /// </param>
        /// <returns>
        /// Broadcast the input parameters against one another, and
        /// return an object that encapsulates the result.
        /// Amongst others, it has shape and nd properties, and
        /// may be used as an iterator.
        /// </returns>
        public NDarray broadcast(NDarray in1)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.broadcast(@this, in1);
        }
        
        /// <summary>
        /// Broadcast an array to a new shape.
        /// 
        /// Notes
        /// </summary>
        /// <param name="shape">
        /// The shape of the desired array.
        /// </param>
        /// <param name="subok">
        /// If True, then sub-classes will be passed-through, otherwise
        /// the returned array will be forced to be a base-class array (default).
        /// </param>
        /// <returns>
        /// A readonly view on the original array with the given shape. It is
        /// typically not contiguous. Furthermore, more than one element of a
        /// broadcasted array may refer to a single memory location.
        /// </returns>
        public NDarray broadcast_to(Shape shape, bool? subok = false)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.broadcast_to(@this, shape, subok:subok);
        }
        
        /// <summary>
        /// Expand the shape of an array.
        /// 
        /// Insert a new axis that will appear at the axis position in the expanded
        /// array shape.
        /// </summary>
        /// <param name="axis">
        /// Position in the expanded axes where the new axis is placed.
        /// </param>
        /// <returns>
        /// Output array. The number of dimensions is one greater than that of
        /// the input array.
        /// </returns>
        public NDarray expand_dims(int axis)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.expand_dims(@this, axis);
        }
        
        /// <summary>
        /// Remove single-dimensional entries from the shape of an array.
        /// </summary>
        /// <param name="axis">
        /// Selects a subset of the single-dimensional entries in the
        /// shape. If an axis is selected with shape entry greater than
        /// one, an error is raised.
        /// </param>
        /// <returns>
        /// The input array, but with all or a subset of the
        /// dimensions of length 1 removed. This is always a itself
        /// or a view into a.
        /// </returns>
        public NDarray squeeze(int[] axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.squeeze(@this, axis:axis);
        }
        
        /// <summary>
        /// Return an array converted to a float type.
        /// </summary>
        /// <param name="dtype">
        /// Float type code to coerce input array a.  If dtype is one of the
        /// ‘int’ dtypes, it is replaced with float64.
        /// </param>
        /// <returns>
        /// The input a as a float ndarray.
        /// </returns>
        public NDarray asfarray(Dtype dtype = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.asfarray(@this, dtype:dtype);
        }
        
        /// <summary>
        /// Return an array (ndim &gt;= 1) laid out in Fortran order in memory.
        /// </summary>
        /// <param name="dtype">
        /// By default, the data-type is inferred from the input data.
        /// </param>
        /// <returns>
        /// The input a in Fortran, or column-major, order.
        /// </returns>
        public NDarray asfortranarray(Dtype dtype = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.asfortranarray(@this, dtype:dtype);
        }
        
        /// <summary>
        /// Convert the input to an array, checking for NaNs or Infs.
        /// </summary>
        /// <param name="dtype">
        /// By default, the data-type is inferred from the input data.
        /// </param>
        /// <param name="order">
        /// Whether to use row-major (C-style) or
        /// column-major (Fortran-style) memory representation.
        /// Defaults to ‘C’.
        /// </param>
        /// <returns>
        /// Array interpretation of a.  No copy is performed if the input
        /// is already an ndarray.  If a is a subclass of ndarray, a base
        /// class ndarray is returned.
        /// </returns>
        public NDarray asarray_chkfinite(Dtype dtype = null, string order = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.asarray_chkfinite(@this, dtype:dtype, order:order);
        }
        
        /// <summary>
        /// Return an ndarray of the provided type that satisfies requirements.
        /// 
        /// This function is useful to be sure that an array with the correct flags
        /// is returned for passing to compiled code (perhaps through ctypes).
        /// 
        /// Notes
        /// 
        /// The returned array will be guaranteed to have the listed requirements
        /// by making a copy if needed.
        /// </summary>
        /// <param name="dtype">
        /// The required data-type. If None preserve the current dtype. If your
        /// application requires the data to be in native byteorder, include
        /// a byteorder specification as a part of the dtype specification.
        /// </param>
        /// <param name="requirements">
        /// The requirements list can be any of the following
        /// </param>
        public NDarray require(Dtype dtype, string[] requirements = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.require(@this, dtype, requirements);
        }
        
        /// <summary>
        /// Split an array into multiple sub-arrays.
        /// </summary>
        /// <param name="indices_or_sections">
        /// If indices_or_sections is an integer, N, the array will be divided
        /// into N equal arrays along axis.  If such a split is not possible,
        /// an error is raised.
        /// 
        /// If indices_or_sections is a 1-D array of sorted integers, the entries
        /// indicate where along axis the array is split.  For example,
        /// [2, 3] would, for axis=0, result in
        /// 
        /// If an index exceeds the dimension of the array along axis,
        /// an empty sub-array is returned correspondingly.
        /// </param>
        /// <param name="axis">
        /// The axis along which to split, default is 0.
        /// </param>
        /// <returns>
        /// A list of sub-arrays.
        /// </returns>
        public NDarray[] split(int[] indices_or_sections, int? axis = 0)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.split(@this, indices_or_sections, axis:axis);
        }
        
        /// <summary>
        /// Construct an array by repeating A the number of times given by reps.
        /// 
        /// If reps has length d, the result will have dimension of
        /// max(d, A.ndim).
        /// 
        /// If A.ndim &lt; d, A is promoted to be d-dimensional by prepending new
        /// axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,
        /// or shape (1, 1, 3) for 3-D replication. If this is not the desired
        /// behavior, promote A to d-dimensions manually before calling this
        /// function.
        /// 
        /// If A.ndim &gt; d, reps is promoted to A.ndim by pre-pending 1’s to it.
        /// Thus for an A of shape (2, 3, 4, 5), a reps of (2, 2) is treated as
        /// (1, 1, 2, 2).
        /// 
        /// Note : Although tile may be used for broadcasting, it is strongly
        /// recommended to use numpy’s broadcasting operations and functions.
        /// </summary>
        /// <param name="reps">
        /// The number of repetitions of A along each axis.
        /// </param>
        /// <returns>
        /// The tiled output array.
        /// </returns>
        public NDarray tile(NDarray reps)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.tile(@this, reps);
        }
        
        /// <summary>
        /// Repeat elements of an array.
        /// </summary>
        /// <param name="repeats">
        /// The number of repetitions for each element.  repeats is broadcasted
        /// to fit the shape of the given axis.
        /// </param>
        /// <param name="axis">
        /// The axis along which to repeat values.  By default, use the
        /// flattened input array, and return a flat output array.
        /// </param>
        /// <returns>
        /// Output array which has the same shape as a, except along
        /// the given axis.
        /// </returns>
        public NDarray repeat(int[] repeats, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.repeat(@this, repeats, axis:axis);
        }
        
        /// <summary>
        /// Return a new array with sub-arrays along an axis deleted. For a one
        /// dimensional array, this returns those entries not returned by
        /// arr[obj].
        /// 
        /// Notes
        /// 
        /// Often it is preferable to use a boolean mask. For example:
        /// 
        /// Is equivalent to np.delete(arr, [0,2,4], axis=0), but allows further
        /// use of mask.
        /// </summary>
        /// <param name="obj">
        /// Indicate which sub-arrays to remove.
        /// </param>
        /// <param name="axis">
        /// The axis along which to delete the subarray defined by obj.
        /// If axis is None, obj is applied to the flattened array.
        /// </param>
        /// <returns>
        /// A copy of arr with the elements specified by obj removed. Note
        /// that delete does not occur in-place. If axis is None, out is
        /// a flattened array.
        /// </returns>
        public NDarray delete(Slice obj, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.delete(@this, obj, axis:axis);
        }
        
        /// <summary>
        /// Insert values along the given axis before the given indices.
        /// 
        /// Notes
        /// 
        /// Note that for higher dimensional inserts obj=0 behaves very different
        /// from obj=[0] just like arr[:,0,:] = values is different from
        /// arr[:,[0],:] = values.
        /// </summary>
        /// <param name="obj">
        /// Object that defines the index or indices before which values is
        /// inserted.
        /// 
        /// Support for multiple insertions when obj is a single scalar or a
        /// sequence with one element (similar to calling insert multiple
        /// times).
        /// </param>
        /// <param name="values">
        /// Values to insert into arr. If the type of values is different
        /// from that of arr, values is converted to the type of arr.
        /// values should be shaped so that arr[...,obj,...] = values
        /// is legal.
        /// </param>
        /// <param name="axis">
        /// Axis along which to insert values.  If axis is None then arr
        /// is flattened first.
        /// </param>
        /// <returns>
        /// A copy of arr with values inserted.  Note that insert
        /// does not occur in-place: a new array is returned. If
        /// axis is None, out is a flattened array.
        /// </returns>
        public NDarray insert(int obj = 0, NDarray values = null, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.insert(@this, obj, values, axis:axis);
        }
        
        /// <summary>
        /// Append values to the end of an array.
        /// </summary>
        /// <param name="values">
        /// These values are appended to a copy of arr.  It must be of the
        /// correct shape (the same shape as arr, excluding axis).  If
        /// axis is not specified, values can be any shape and will be
        /// flattened before use.
        /// </param>
        /// <param name="axis">
        /// The axis along which values are appended.  If axis is not
        /// given, both arr and values are flattened before use.
        /// </param>
        /// <returns>
        /// A copy of arr with values appended to axis.  Note that
        /// append does not occur in-place: a new array is allocated and
        /// filled.  If axis is None, out is a flattened array.
        /// </returns>
        public NDarray append(NDarray values, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.append(@this, values, axis:axis);
        }
        
        /// <summary>
        /// Trim the leading and/or trailing zeros from a 1-D array or sequence.
        /// </summary>
        /// <param name="trim">
        /// A string with ‘f’ representing trim from front and ‘b’ to trim from
        /// back. Default is ‘fb’, trim zeros from both front and back of the
        /// array.
        /// </param>
        /// <returns>
        /// The result of trimming the input. The input data type is preserved.
        /// </returns>
        public NDarray trim_zeros(string trim = "fb")
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.trim_zeros(@this, trim:trim);
        }
        
        /// <summary>
        /// Find the unique elements of an array.
        /// 
        /// Returns the sorted unique elements of an array. There are three optional
        /// outputs in addition to the unique elements:
        /// 
        /// Notes
        /// 
        /// When an axis is specified the subarrays indexed by the axis are sorted.
        /// This is done by making the specified axis the first dimension of the array
        /// and then flattening the subarrays in C order. The flattened subarrays are
        /// then viewed as a structured type with each element given a label, with the
        /// effect that we end up with a 1-D array of structured types that can be
        /// treated in the same way as any other 1-D array. The result is that the
        /// flattened subarrays are sorted in lexicographic order starting with the
        /// first element.
        /// </summary>
        /// <param name="return_index">
        /// If True, also return the indices of ar (along the specified axis,
        /// if provided, or in the flattened array) that result in the unique array.
        /// </param>
        /// <param name="return_inverse">
        /// If True, also return the indices of the unique array (for the specified
        /// axis, if provided) that can be used to reconstruct ar.
        /// </param>
        /// <param name="return_counts">
        /// If True, also return the number of times each unique item appears
        /// in ar.
        /// </param>
        /// <param name="axis">
        /// The axis to operate on. If None, ar will be flattened. If an integer,
        /// the subarrays indexed by the given axis will be flattened and treated
        /// as the elements of a 1-D array with the dimension of the given axis,
        /// see the notes for more details.  Object arrays or structured arrays
        /// that contain objects are not supported if the axis kwarg is used. The
        /// default is None.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// unique
        /// The sorted unique values.
        /// unique_indices
        /// The indices of the first occurrences of the unique values in the
        /// original array. Only provided if return_index is True.
        /// unique_inverse
        /// The indices to reconstruct the original array from the
        /// unique array. Only provided if return_inverse is True.
        /// unique_counts
        /// The number of times each of the unique values comes up in the
        /// original array. Only provided if return_counts is True.
        /// </returns>
        public (NDarray, NDarray, NDarray, NDarray) unique(bool? return_index = false, bool? return_inverse = false, bool? return_counts = false, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.unique(@this, return_index:return_index, return_inverse:return_inverse, return_counts:return_counts, axis:axis);
        }
        
        /// <summary>
        /// Reverse the order of elements in an array along the given axis.
        /// 
        /// The shape of the array is preserved, but the elements are reordered.
        /// 
        /// Notes
        /// 
        /// flip(m, 0) is equivalent to flipud(m).
        /// 
        /// flip(m, 1) is equivalent to fliplr(m).
        /// 
        /// flip(m, n) corresponds to m[...,::-1,...] with ::-1 at position n.
        /// 
        /// flip(m) corresponds to m[::-1,::-1,...,::-1] with ::-1 at all
        /// positions.
        /// 
        /// flip(m, (0, 1)) corresponds to m[::-1,::-1,...] with ::-1 at
        /// position 0 and position 1.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which to flip over. The default,
        /// axis=None, will flip over all of the axes of the input array.
        /// If axis is negative it counts from the last to the first axis.
        /// 
        /// If axis is a tuple of ints, flipping is performed on all of the axes
        /// specified in the tuple.
        /// </param>
        /// <returns>
        /// A view of m with the entries of axis reversed.  Since a view is
        /// returned, this operation is done in constant time.
        /// </returns>
        public NDarray flip(int[] axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.flip(@this, axis:axis);
        }
        
        /// <summary>
        /// Flip array in the left/right direction.
        /// 
        /// Flip the entries in each row in the left/right direction.
        /// Columns are preserved, but appear in a different order than before.
        /// 
        /// Notes
        /// 
        /// Equivalent to m[:,::-1]. Requires the array to be at least 2-D.
        /// </summary>
        /// <returns>
        /// A view of m with the columns reversed.  Since a view
        /// is returned, this operation is .
        /// </returns>
        public NDarray fliplr()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.fliplr(@this);
        }
        
        /// <summary>
        /// Flip array in the up/down direction.
        /// 
        /// Flip the entries in each column in the up/down direction.
        /// Rows are preserved, but appear in a different order than before.
        /// 
        /// Notes
        /// 
        /// Equivalent to m[::-1,...].
        /// Does not require the array to be two-dimensional.
        /// </summary>
        /// <returns>
        /// A view of m with the rows reversed.  Since a view is
        /// returned, this operation is .
        /// </returns>
        public NDarray flipud()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.flipud(@this);
        }
        
        /// <summary>
        /// Roll array elements along a given axis.
        /// 
        /// Elements that roll beyond the last position are re-introduced at
        /// the first.
        /// 
        /// Notes
        /// 
        /// Supports rolling over multiple dimensions simultaneously.
        /// </summary>
        /// <param name="shift">
        /// The number of places by which elements are shifted.  If a tuple,
        /// then axis must be a tuple of the same size, and each of the
        /// given axes is shifted by the corresponding number.  If an int
        /// while axis is a tuple of ints, then the same value is used for
        /// all given axes.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which elements are shifted.  By default, the
        /// array is flattened before shifting, after which the original
        /// shape is restored.
        /// </param>
        /// <returns>
        /// Output array, with the same shape as a.
        /// </returns>
        public NDarray roll(int[] shift, int[] axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.roll(@this, shift, axis:axis);
        }
        
        /// <summary>
        /// Rotate an array by 90 degrees in the plane specified by axes.
        /// 
        /// Rotation direction is from the first towards the second axis.
        /// 
        /// Notes
        /// 
        /// rot90(m, k=1, axes=(1,0)) is the reverse of rot90(m, k=1, axes=(0,1))
        /// rot90(m, k=1, axes=(1,0)) is equivalent to rot90(m, k=-1, axes=(0,1))
        /// </summary>
        /// <param name="k">
        /// Number of times the array is rotated by 90 degrees.
        /// </param>
        /// <param name="axes">
        /// The array is rotated in the plane defined by the axes.
        /// Axes must be different.
        /// </param>
        /// <returns>
        /// A rotated view of m.
        /// </returns>
        public NDarray rot90(int k = 1, int[] axes = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.rot90(@this, k, axes);
        }
        
        /// <summary>
        /// Compute the bit-wise AND of two arrays element-wise.
        /// 
        /// Computes the bit-wise AND of the underlying binary representation of
        /// the integers in the input arrays. This ufunc implements the C/Python
        /// operator &amp;.
        /// </summary>
        /// <param name="x1">
        /// Only integer and boolean types are handled.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Result.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray bitwise_and(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.bitwise_and(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Compute the bit-wise OR of two arrays element-wise.
        /// 
        /// Computes the bit-wise OR of the underlying binary representation of
        /// the integers in the input arrays. This ufunc implements the C/Python
        /// operator |.
        /// </summary>
        /// <param name="x1">
        /// Only integer and boolean types are handled.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Result.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray bitwise_or(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.bitwise_or(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Compute the bit-wise XOR of two arrays element-wise.
        /// 
        /// Computes the bit-wise XOR of the underlying binary representation of
        /// the integers in the input arrays. This ufunc implements the C/Python
        /// operator ^.
        /// </summary>
        /// <param name="x1">
        /// Only integer and boolean types are handled.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Result.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray bitwise_xor(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.bitwise_xor(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Compute bit-wise inversion, or bit-wise NOT, element-wise.
        /// 
        /// Computes the bit-wise NOT of the underlying binary representation of
        /// the integers in the input arrays. This ufunc implements the C/Python
        /// operator ~.
        /// 
        /// For signed integer inputs, the two’s complement is returned.  In a
        /// two’s-complement system negative numbers are represented by the two’s
        /// complement of the absolute value. This is the most common method of
        /// representing signed integers on computers [1]. A N-bit
        /// two’s-complement system can represent every integer in the range
        ///  to .
        /// 
        /// Notes
        /// 
        /// bitwise_not is an alias for invert:
        /// 
        /// References
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Result.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray invert(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.invert(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Shift the bits of an integer to the right.
        /// 
        /// Bits are shifted to the right x2.  Because the internal
        /// representation of numbers is in binary format, this operation is
        /// equivalent to dividing x1 by 2**x2.
        /// </summary>
        /// <param name="x2">
        /// Number of bits to remove at the right of x1.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Return x1 with bits shifted x2 times to the right.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray right_shift(NDarray x2, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.right_shift(@this, x2, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Packs the elements of a binary-valued array into bits in a uint8 array.
        /// 
        /// The result is padded to full bytes by inserting zero bits at the end.
        /// </summary>
        /// <param name="axis">
        /// The dimension over which bit-packing is done.
        /// None implies packing the flattened array.
        /// </param>
        /// <returns>
        /// Array of type uint8 whose elements represent bits corresponding to the
        /// logical (0 or nonzero) value of the input elements. The shape of
        /// packed has the same number of dimensions as the input (unless axis
        /// is None, in which case the output is 1-D).
        /// </returns>
        public NDarray packbits(int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.packbits(@this, axis:axis);
        }
        
        /// <summary>
        /// Unpacks elements of a uint8 array into a binary-valued output array.
        /// 
        /// Each element of myarray represents a bit-field that should be unpacked
        /// into a binary-valued output array. The shape of the output array is either
        /// 1-D (if axis is None) or the same shape as the input array with unpacking
        /// done along the axis specified.
        /// </summary>
        /// <param name="axis">
        /// The dimension over which bit-unpacking is done.
        /// None implies unpacking the flattened array.
        /// </param>
        /// <returns>
        /// The elements are binary-valued (0 or 1).
        /// </returns>
        public NDarray unpackbits(int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.unpackbits(@this, axis:axis);
        }
        
        /// <summary>
        /// Cholesky decomposition.
        /// 
        /// Return the Cholesky decomposition, L * L.H, of the square matrix a,
        /// where L is lower-triangular and .H is the conjugate transpose operator
        /// (which is the ordinary transpose if a is real-valued).  a must be
        /// Hermitian (symmetric if real-valued) and positive-definite.  Only L is
        /// actually returned.
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// The Cholesky decomposition is often used as a fast way of solving
        /// 
        /// (when A is both Hermitian/symmetric and positive-definite).
        /// 
        /// First, we solve for  in
        /// 
        /// and then for  in
        /// </summary>
        /// <returns>
        /// Upper or lower-triangular Cholesky factor of a.  Returns a
        /// matrix object if a is a matrix object.
        /// </returns>
        public NDarray cholesky()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.cholesky(@this);
        }
        
        /// <summary>
        /// Compute the determinant of an array.
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// The determinant is computed via LU factorization using the LAPACK
        /// routine z/dgetrf.
        /// </summary>
        /// <returns>
        /// Determinant of a.
        /// </returns>
        public NDarray det()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.det(@this);
        }
        
        /// <summary>
        /// Compute the eigenvalues and right eigenvectors of a square array.
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// This is implemented using the _geev LAPACK routines which compute
        /// the eigenvalues and eigenvectors of general square arrays.
        /// 
        /// The number w is an eigenvalue of a if there exists a vector
        /// v such that dot(a,v) = w * v. Thus, the arrays a, w, and
        /// v satisfy the equations dot(a[:,:], v[:,i]) = w[i] * v[:,i]
        /// for .
        /// 
        /// The array v of eigenvectors may not be of maximum rank, that is, some
        /// of the columns may be linearly dependent, although round-off error may
        /// obscure that fact. If the eigenvalues are all different, then theoretically
        /// the eigenvectors are linearly independent. Likewise, the (complex-valued)
        /// matrix of eigenvectors v is unitary if the matrix a is normal, i.e.,
        /// if dot(a, a.H) = dot(a.H, a), where a.H denotes the conjugate
        /// transpose of a.
        /// 
        /// Finally, it is emphasized that v consists of the right (as in
        /// right-hand side) eigenvectors of a.  A vector y satisfying
        /// dot(y.T, a) = z * y.T for some number z is called a left
        /// eigenvector of a, and, in general, the left and right eigenvectors
        /// of a matrix are not necessarily the (perhaps conjugate) transposes
        /// of each other.
        /// 
        /// References
        /// 
        /// G. Strang, Linear Algebra and Its Applications, 2nd Ed., Orlando, FL,
        /// Academic Press, Inc., 1980, Various pp.
        /// </summary>
        /// <returns>
        /// A tuple of:
        /// w
        /// The eigenvalues, each repeated according to its multiplicity.
        /// The eigenvalues are not necessarily ordered. The resulting
        /// array will be of complex type, unless the imaginary part is
        /// zero in which case it will be cast to a real type. When a
        /// is real the resulting eigenvalues will be real (0 imaginary
        /// part) or occur in conjugate pairs
        /// v
        /// The normalized (unit “length”) eigenvectors, such that the
        /// column v[:,i] is the eigenvector corresponding to the
        /// eigenvalue w[i].
        /// </returns>
        public (NDarray, NDarray) eig()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.eig(@this);
        }
        
        /// <summary>
        /// Return the eigenvalues and eigenvectors of a complex Hermitian
        /// (conjugate symmetric) or a real symmetric matrix.
        /// 
        /// Returns two objects, a 1-D array containing the eigenvalues of a, and
        /// a 2-D square array or matrix (depending on the input type) of the
        /// corresponding eigenvectors (in columns).
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// The eigenvalues/eigenvectors are computed using LAPACK routines _syevd,
        /// _heevd
        /// 
        /// The eigenvalues of real symmetric or complex Hermitian matrices are
        /// always real. [1] The array v of (column) eigenvectors is unitary
        /// and a, w, and v satisfy the equations
        /// dot(a, v[:, i]) = w[i] * v[:, i].
        /// 
        /// References
        /// </summary>
        /// <param name="UPLO">
        /// Specifies whether the calculation is done with the lower triangular
        /// part of a (‘L’, default) or the upper triangular part (‘U’).
        /// Irrespective of this value only the real parts of the diagonal will
        /// be considered in the computation to preserve the notion of a Hermitian
        /// matrix. It therefore follows that the imaginary part of the diagonal
        /// will always be treated as zero.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// w
        /// The eigenvalues in ascending order, each repeated according to
        /// its multiplicity.
        /// v
        /// The column v[:, i] is the normalized eigenvector corresponding
        /// to the eigenvalue w[i].  Will return a matrix object if a is
        /// a matrix object.
        /// </returns>
        public (NDarray, NDarray) eigh(string UPLO = "L")
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.eigh(@this, UPLO:UPLO);
        }
        
        /// <summary>
        /// Compute the eigenvalues of a general matrix.
        /// 
        /// Main difference between eigvals and eig: the eigenvectors aren’t
        /// returned.
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// This is implemented using the _geev LAPACK routines which compute
        /// the eigenvalues and eigenvectors of general square arrays.
        /// </summary>
        /// <returns>
        /// The eigenvalues, each repeated according to its multiplicity.
        /// They are not necessarily ordered, nor are they necessarily
        /// real for real matrices.
        /// </returns>
        public NDarray eigvals()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.eigvals(@this);
        }
        
        /// <summary>
        /// Compute the eigenvalues of a complex Hermitian or real symmetric matrix.
        /// 
        /// Main difference from eigh: the eigenvectors are not computed.
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// The eigenvalues are computed using LAPACK routines _syevd, _heevd
        /// </summary>
        /// <param name="UPLO">
        /// Specifies whether the calculation is done with the lower triangular
        /// part of a (‘L’, default) or the upper triangular part (‘U’).
        /// Irrespective of this value only the real parts of the diagonal will
        /// be considered in the computation to preserve the notion of a Hermitian
        /// matrix. It therefore follows that the imaginary part of the diagonal
        /// will always be treated as zero.
        /// </param>
        /// <returns>
        /// The eigenvalues in ascending order, each repeated according to
        /// its multiplicity.
        /// </returns>
        public NDarray eigvalsh(string UPLO = "L")
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.eigvalsh(@this, UPLO:UPLO);
        }
        
        /// <summary>
        /// Compute the (multiplicative) inverse of a matrix.
        /// 
        /// Given a square matrix a, return the matrix ainv satisfying
        /// dot(a, ainv) = dot(ainv, a) = eye(a.shape[0]).
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// </summary>
        /// <returns>
        /// (Multiplicative) inverse of the matrix a.
        /// </returns>
        public NDarray inv()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.inv(@this);
        }
        
        /// <summary>
        /// Return the least-squares solution to a linear matrix equation.
        /// 
        /// Solves the equation a x = b by computing a vector x that
        /// minimizes the Euclidean 2-norm || b - a x ||^2.  The equation may
        /// be under-, well-, or over- determined (i.e., the number of
        /// linearly independent rows of a can be less than, equal to, or
        /// greater than its number of linearly independent columns).  If a
        /// is square and of full rank, then x (but for round-off error) is
        /// the “exact” solution of the equation.
        /// 
        /// Notes
        /// 
        /// If b is a matrix, then all array results are returned as matrices.
        /// </summary>
        /// <param name="b">
        /// Ordinate or “dependent variable” values. If b is two-dimensional,
        /// the least-squares solution is calculated for each of the K columns
        /// of b.
        /// </param>
        /// <param name="rcond">
        /// Cut-off ratio for small singular values of a.
        /// For the purposes of rank determination, singular values are treated
        /// as zero if they are smaller than rcond times the largest singular
        /// value of a.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// x
        /// Least-squares solution. If b is two-dimensional,
        /// the solutions are in the K columns of x.
        /// residuals
        /// Sums of residuals; squared Euclidean 2-norm for each column in
        /// b - a*x.
        /// If the rank of a is &lt; N or M &lt;= N, this is an empty array.
        /// If b is 1-dimensional, this is a (1,) shape array.
        /// Otherwise the shape is (K,).
        /// rank
        /// Rank of matrix a.
        /// s
        /// Singular values of a.
        /// </returns>
        public (NDarray, NDarray, int, NDarray) lstsq(NDarray b, float? rcond = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.lstsq(@this, b, rcond:rcond);
        }
        
        /// <summary>
        /// Compute the (Moore-Penrose) pseudo-inverse of a matrix.
        /// 
        /// Calculate the generalized inverse of a matrix using its
        /// singular-value decomposition (SVD) and including all
        /// large singular values.
        /// 
        /// Notes
        /// 
        /// The pseudo-inverse of a matrix A, denoted , is
        /// defined as: “the matrix that ‘solves’ [the least-squares problem]
        /// ,” i.e., if  is said solution, then
        ///  is that matrix such that .
        /// 
        /// It can be shown that if  is the singular
        /// value decomposition of A, then
        /// , where  are
        /// orthogonal matrices,  is a diagonal matrix consisting
        /// of A’s so-called singular values, (followed, typically, by
        /// zeros), and then  is simply the diagonal matrix
        /// consisting of the reciprocals of A’s singular values
        /// (again, followed by zeros). [1]
        /// 
        /// References
        /// </summary>
        /// <param name="rcond">
        /// Cutoff for small singular values.
        /// Singular values smaller (in modulus) than
        /// rcond * largest_singular_value (again, in modulus)
        /// are set to zero. Broadcasts against the stack of matrices
        /// </param>
        /// <returns>
        /// The pseudo-inverse of a. If a is a matrix instance, then so
        /// is B.
        /// </returns>
        public NDarray pinv(float rcond = 1e-15f)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.pinv(@this, rcond);
        }
        
        /// <summary>
        /// Solve a linear matrix equation, or system of linear scalar equations.
        /// 
        /// Computes the “exact” solution, x, of the well-determined, i.e., full
        /// rank, linear matrix equation ax = b.
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// The solutions are computed using LAPACK routine _gesv
        /// 
        /// a must be square and of full-rank, i.e., all rows (or, equivalently,
        /// columns) must be linearly independent; if either is not true, use
        /// lstsq for the least-squares best “solution” of the
        /// system/equation.
        /// 
        /// References
        /// </summary>
        /// <param name="b">
        /// Ordinate or “dependent variable” values.
        /// </param>
        /// <returns>
        /// Solution to the system a x = b.  Returned shape is identical to b.
        /// </returns>
        public NDarray solve(NDarray b)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.solve(@this, b);
        }
        
        /// <summary>
        /// Singular Value Decomposition.
        /// 
        /// When a is a 2D array, it is factorized as u &#64; np.diag(s) &#64; vh
        /// = (u * s) &#64; vh, where u and vh are 2D unitary arrays and s is a 1D
        /// array of a’s singular values. When a is higher-dimensional, SVD is
        /// applied in stacked mode as explained below.
        /// 
        /// Notes
        /// 
        /// The decomposition is performed using LAPACK routine _gesdd.
        /// 
        /// SVD is usually described for the factorization of a 2D matrix .
        /// The higher-dimensional case will be discussed below. In the 2D case, SVD is
        /// written as , where , ,
        ///  and . The 1D array s
        /// contains the singular values of a and u and vh are unitary. The rows
        /// of vh are the eigenvectors of  and the columns of u are
        /// the eigenvectors of . In both cases the corresponding
        /// (possibly non-zero) eigenvalues are given by s**2.
        /// 
        /// If a has more than two dimensions, then broadcasting rules apply, as
        /// explained in Linear algebra on several matrices at once. This means that SVD is
        /// working in “stacked” mode: it iterates over all indices of the first
        /// a.ndim - 2 dimensions and for each combination SVD is applied to the
        /// last two indices. The matrix a can be reconstructed from the
        /// decomposition with either (u * s[..., None, :]) &#64; vh or
        /// u &#64; (s[..., None] * vh). (The &#64; operator can be replaced by the
        /// function np.matmul for python versions below 3.5.)
        /// 
        /// If a is a matrix object (as opposed to an ndarray), then so are
        /// all the return values.
        /// </summary>
        /// <param name="full_matrices">
        /// If True (default), u and vh have the shapes (..., M, M) and
        /// (..., N, N), respectively.  Otherwise, the shapes are
        /// (..., M, K) and (..., K, N), respectively, where
        /// K = min(M, N).
        /// </param>
        /// <param name="compute_uv">
        /// Whether or not to compute u and vh in addition to s.  True
        /// by default.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// u
        /// Unitary array(s). The first a.ndim - 2 dimensions have the same
        /// size as those of the input a. The size of the last two dimensions
        /// depends on the value of full_matrices. Only returned when
        /// compute_uv is True.
        /// s
        /// Vector(s) with the singular values, within each vector sorted in
        /// descending order. The first a.ndim - 2 dimensions have the same
        /// size as those of the input a.
        /// vh
        /// Unitary array(s). The first a.ndim - 2 dimensions have the same
        /// size as those of the input a. The size of the last two dimensions
        /// depends on the value of full_matrices. Only returned when
        /// compute_uv is True.
        /// </returns>
        public (NDarray, NDarray, NDarray) svd(bool? full_matrices = true, bool? compute_uv = true)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.svd(@this, full_matrices:full_matrices, compute_uv:compute_uv);
        }
        
        /// <summary>
        /// Compute the one-dimensional discrete Fourier Transform.
        /// 
        /// This function computes the one-dimensional n-point discrete Fourier
        /// Transform (DFT) with the efficient Fast Fourier Transform (FFT)
        /// algorithm [CT].
        /// 
        /// Notes
        /// 
        /// FFT (Fast Fourier Transform) refers to a way the discrete Fourier
        /// Transform (DFT) can be calculated efficiently, by using symmetries in the
        /// calculated terms.  The symmetry is highest when n is a power of 2, and
        /// the transform is therefore most efficient for these sizes.
        /// 
        /// The DFT is defined, with the conventions used in this implementation, in
        /// the documentation for the numpy.fft module.
        /// 
        /// References
        /// </summary>
        /// <param name="n">
        /// Length of the transformed axis of the output.
        /// If n is smaller than the length of the input, the input is cropped.
        /// If it is larger, the input is padded with zeros.  If n is not given,
        /// the length of the input along the axis specified by axis is used.
        /// </param>
        /// <param name="axis">
        /// Axis over which to compute the FFT.  If not given, the last axis is
        /// used.
        /// </param>
        /// <param name="norm">
        /// Normalization mode (see numpy.fft). Default is None.
        /// </param>
        /// <returns>
        /// The truncated or zero-padded input, transformed along the axis
        /// indicated by axis, or the last one if axis is not specified.
        /// </returns>
        public NDarray fft(int? n = null, int? axis = -1, string norm = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.fft(@this, n:n, axis:axis, norm:norm);
        }
        
        /// <summary>
        /// Compute the 2-dimensional discrete Fourier Transform
        /// 
        /// This function computes the n-dimensional discrete Fourier Transform
        /// over any axes in an M-dimensional array by means of the
        /// Fast Fourier Transform (FFT).  By default, the transform is computed over
        /// the last two axes of the input array, i.e., a 2-dimensional FFT.
        /// 
        /// Notes
        /// 
        /// fft2 is just fftn with a different default for axes.
        /// 
        /// The output, analogously to fft, contains the term for zero frequency in
        /// the low-order corner of the transformed axes, the positive frequency terms
        /// in the first half of these axes, the term for the Nyquist frequency in the
        /// middle of the axes and the negative frequency terms in the second half of
        /// the axes, in order of decreasingly negative frequency.
        /// 
        /// See fftn for details and a plotting example, and numpy.fft for
        /// definitions and conventions used.
        /// </summary>
        /// <param name="s">
        /// Shape (length of each transformed axis) of the output
        /// (s[0] refers to axis 0, s[1] to axis 1, etc.).
        /// This corresponds to n for fft(x, n).
        /// Along each axis, if the given shape is smaller than that of the input,
        /// the input is cropped.  If it is larger, the input is padded with zeros.
        /// if s is not given, the shape of the input along the axes specified
        /// by axes is used.
        /// </param>
        /// <param name="axes">
        /// Axes over which to compute the FFT.  If not given, the last two
        /// axes are used.  A repeated index in axes means the transform over
        /// that axis is performed multiple times.  A one-element sequence means
        /// that a one-dimensional FFT is performed.
        /// </param>
        /// <param name="norm">
        /// Normalization mode (see numpy.fft). Default is None.
        /// </param>
        /// <returns>
        /// The truncated or zero-padded input, transformed along the axes
        /// indicated by axes, or the last two axes if axes is not given.
        /// </returns>
        public NDarray fft2(int[] s = null, int[] axes = null, string norm = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.fft2(@this, s:s, axes:axes, norm:norm);
        }
        
        /// <summary>
        /// Compute the N-dimensional discrete Fourier Transform.
        /// 
        /// This function computes the N-dimensional discrete Fourier Transform over
        /// any number of axes in an M-dimensional array by means of the Fast Fourier
        /// Transform (FFT).
        /// 
        /// Notes
        /// 
        /// The output, analogously to fft, contains the term for zero frequency in
        /// the low-order corner of all axes, the positive frequency terms in the
        /// first half of all axes, the term for the Nyquist frequency in the middle
        /// of all axes and the negative frequency terms in the second half of all
        /// axes, in order of decreasingly negative frequency.
        /// 
        /// See numpy.fft for details, definitions and conventions used.
        /// </summary>
        /// <param name="s">
        /// Shape (length of each transformed axis) of the output
        /// (s[0] refers to axis 0, s[1] to axis 1, etc.).
        /// This corresponds to n for fft(x, n).
        /// Along any axis, if the given shape is smaller than that of the input,
        /// the input is cropped.  If it is larger, the input is padded with zeros.
        /// if s is not given, the shape of the input along the axes specified
        /// by axes is used.
        /// </param>
        /// <param name="axes">
        /// Axes over which to compute the FFT.  If not given, the last len(s)
        /// axes are used, or all axes if s is also not specified.
        /// Repeated indices in axes means that the transform over that axis is
        /// performed multiple times.
        /// </param>
        /// <param name="norm">
        /// Normalization mode (see numpy.fft). Default is None.
        /// </param>
        /// <returns>
        /// The truncated or zero-padded input, transformed along the axes
        /// indicated by axes, or by a combination of s and a,
        /// as explained in the parameters section above.
        /// </returns>
        public NDarray fftn(int[] s = null, int[] axes = null, string norm = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.fftn(@this, s:s, axes:axes, norm:norm);
        }
        
        /// <summary>
        /// Compute the one-dimensional inverse discrete Fourier Transform.
        /// 
        /// This function computes the inverse of the one-dimensional n-point
        /// discrete Fourier transform computed by fft.  In other words,
        /// ifft(fft(a)) == a to within numerical accuracy.
        /// For a general description of the algorithm and definitions,
        /// see numpy.fft.
        /// 
        /// The input should be ordered in the same way as is returned by fft,
        /// i.e.,
        /// 
        /// For an even number of input points, A[n//2] represents the sum of
        /// the values at the positive and negative Nyquist frequencies, as the two
        /// are aliased together. See numpy.fft for details.
        /// 
        /// Notes
        /// 
        /// If the input parameter n is larger than the size of the input, the input
        /// is padded by appending zeros at the end.  Even though this is the common
        /// approach, it might lead to surprising results.  If a different padding is
        /// desired, it must be performed before calling ifft.
        /// </summary>
        /// <param name="n">
        /// Length of the transformed axis of the output.
        /// If n is smaller than the length of the input, the input is cropped.
        /// If it is larger, the input is padded with zeros.  If n is not given,
        /// the length of the input along the axis specified by axis is used.
        /// See notes about padding issues.
        /// </param>
        /// <param name="axis">
        /// Axis over which to compute the inverse DFT.  If not given, the last
        /// axis is used.
        /// </param>
        /// <param name="norm">
        /// Normalization mode (see numpy.fft). Default is None.
        /// </param>
        /// <returns>
        /// The truncated or zero-padded input, transformed along the axis
        /// indicated by axis, or the last one if axis is not specified.
        /// </returns>
        public NDarray ifft(int? n = null, int? axis = -1, string norm = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.ifft(@this, n:n, axis:axis, norm:norm);
        }
        
        /// <summary>
        /// Compute the 2-dimensional inverse discrete Fourier Transform.
        /// 
        /// This function computes the inverse of the 2-dimensional discrete Fourier
        /// Transform over any number of axes in an M-dimensional array by means of
        /// the Fast Fourier Transform (FFT).  In other words, ifft2(fft2(a)) == a
        /// to within numerical accuracy.  By default, the inverse transform is
        /// computed over the last two axes of the input array.
        /// 
        /// The input, analogously to ifft, should be ordered in the same way as is
        /// returned by fft2, i.e. it should have the term for zero frequency
        /// in the low-order corner of the two axes, the positive frequency terms in
        /// the first half of these axes, the term for the Nyquist frequency in the
        /// middle of the axes and the negative frequency terms in the second half of
        /// both axes, in order of decreasingly negative frequency.
        /// 
        /// Notes
        /// 
        /// ifft2 is just ifftn with a different default for axes.
        /// 
        /// See ifftn for details and a plotting example, and numpy.fft for
        /// definition and conventions used.
        /// 
        /// Zero-padding, analogously with ifft, is performed by appending zeros to
        /// the input along the specified dimension.  Although this is the common
        /// approach, it might lead to surprising results.  If another form of zero
        /// padding is desired, it must be performed before ifft2 is called.
        /// </summary>
        /// <param name="s">
        /// Shape (length of each axis) of the output (s[0] refers to axis 0,
        /// s[1] to axis 1, etc.).  This corresponds to n for ifft(x, n).
        /// Along each axis, if the given shape is smaller than that of the input,
        /// the input is cropped.  If it is larger, the input is padded with zeros.
        /// if s is not given, the shape of the input along the axes specified
        /// by axes is used.  See notes for issue on ifft zero padding.
        /// </param>
        /// <param name="axes">
        /// Axes over which to compute the FFT.  If not given, the last two
        /// axes are used.  A repeated index in axes means the transform over
        /// that axis is performed multiple times.  A one-element sequence means
        /// that a one-dimensional FFT is performed.
        /// </param>
        /// <param name="norm">
        /// Normalization mode (see numpy.fft). Default is None.
        /// </param>
        /// <returns>
        /// The truncated or zero-padded input, transformed along the axes
        /// indicated by axes, or the last two axes if axes is not given.
        /// </returns>
        public NDarray ifft2(int[] s = null, int[] axes = null, string norm = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.ifft2(@this, s:s, axes:axes, norm:norm);
        }
        
        /// <summary>
        /// Compute the N-dimensional inverse discrete Fourier Transform.
        /// 
        /// This function computes the inverse of the N-dimensional discrete
        /// Fourier Transform over any number of axes in an M-dimensional array by
        /// means of the Fast Fourier Transform (FFT).  In other words,
        /// ifftn(fftn(a)) == a to within numerical accuracy.
        /// For a description of the definitions and conventions used, see numpy.fft.
        /// 
        /// The input, analogously to ifft, should be ordered in the same way as is
        /// returned by fftn, i.e. it should have the term for zero frequency
        /// in all axes in the low-order corner, the positive frequency terms in the
        /// first half of all axes, the term for the Nyquist frequency in the middle
        /// of all axes and the negative frequency terms in the second half of all
        /// axes, in order of decreasingly negative frequency.
        /// 
        /// Notes
        /// 
        /// See numpy.fft for definitions and conventions used.
        /// 
        /// Zero-padding, analogously with ifft, is performed by appending zeros to
        /// the input along the specified dimension.  Although this is the common
        /// approach, it might lead to surprising results.  If another form of zero
        /// padding is desired, it must be performed before ifftn is called.
        /// </summary>
        /// <param name="s">
        /// Shape (length of each transformed axis) of the output
        /// (s[0] refers to axis 0, s[1] to axis 1, etc.).
        /// This corresponds to n for ifft(x, n).
        /// Along any axis, if the given shape is smaller than that of the input,
        /// the input is cropped.  If it is larger, the input is padded with zeros.
        /// if s is not given, the shape of the input along the axes specified
        /// by axes is used.  See notes for issue on ifft zero padding.
        /// </param>
        /// <param name="axes">
        /// Axes over which to compute the IFFT.  If not given, the last len(s)
        /// axes are used, or all axes if s is also not specified.
        /// Repeated indices in axes means that the inverse transform over that
        /// axis is performed multiple times.
        /// </param>
        /// <param name="norm">
        /// Normalization mode (see numpy.fft). Default is None.
        /// </param>
        /// <returns>
        /// The truncated or zero-padded input, transformed along the axes
        /// indicated by axes, or by a combination of s or a,
        /// as explained in the parameters section above.
        /// </returns>
        public NDarray ifftn(int[] s = null, int[] axes = null, string norm = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.ifftn(@this, s:s, axes:axes, norm:norm);
        }
        
        /// <summary>
        /// Modified Bessel function of the first kind, order 0.
        /// 
        /// Usually denoted .  This function does broadcast, but will not
        /// “up-cast” int dtype arguments unless accompanied by at least one float or
        /// complex dtype argument (see Raises below).
        /// 
        /// Notes
        /// 
        /// We use the algorithm published by Clenshaw [1] and referenced by
        /// Abramowitz and Stegun [2], for which the function domain is
        /// partitioned into the two intervals [0,8] and (8,inf), and Chebyshev
        /// polynomial expansions are employed in each interval. Relative error on
        /// the domain [0,30] using IEEE arithmetic is documented [3] as having a
        /// peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).
        /// 
        /// References
        /// </summary>
        /// <returns>
        /// The modified Bessel function evaluated at each of the elements of x.
        /// </returns>
        public NDarray i0()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.i0(@this);
        }
        
        /// <summary>
        /// Trigonometric sine, element-wise.
        /// 
        /// Notes
        /// 
        /// The sine is one of the fundamental functions of trigonometry (the
        /// mathematical study of triangles).  Consider a circle of radius 1
        /// centered on the origin.  A ray comes in from the  axis, makes
        /// an angle at the origin (measured counter-clockwise from that axis), and
        /// departs from the origin.  The  coordinate of the outgoing
        /// ray’s intersection with the unit circle is the sine of that angle.  It
        /// ranges from -1 for  to +1 for   The
        /// function has zeroes where the angle is a multiple of .
        /// Sines of angles between  and  are negative.
        /// The numerous properties of the sine and related functions are included
        /// in any standard trigonometry text.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The sine of each element of x.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray sin(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.sin(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Cosine element-wise.
        /// 
        /// Notes
        /// 
        /// If out is provided, the function writes the result into it,
        /// and returns a reference to out.  (See Examples)
        /// 
        /// References
        /// 
        /// M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
        /// New York, NY: Dover, 1972.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The corresponding cosine values.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray cos(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.cos(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Compute tangent element-wise.
        /// 
        /// Equivalent to np.sin(x)/np.cos(x) element-wise.
        /// 
        /// Notes
        /// 
        /// If out is provided, the function writes the result into it,
        /// and returns a reference to out.  (See Examples)
        /// 
        /// References
        /// 
        /// M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
        /// New York, NY: Dover, 1972.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The corresponding tangent values.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray tan(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.tan(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Inverse sine, element-wise.
        /// 
        /// Notes
        /// 
        /// arcsin is a multivalued function: for each x there are infinitely
        /// many numbers z such that .  The convention is to
        /// return the angle z whose real part lies in [-pi/2, pi/2].
        /// 
        /// For real-valued input data types, arcsin always returns real output.
        /// For each value that cannot be expressed as a real number or infinity,
        /// it yields nan and sets the invalid floating point error flag.
        /// 
        /// For complex-valued input, arcsin is a complex analytic function that
        /// has, by convention, the branch cuts [-inf, -1] and [1, inf]  and is
        /// continuous from above on the former and from below on the latter.
        /// 
        /// The inverse sine is also known as asin or sin^{-1}.
        /// 
        /// References
        /// 
        /// Abramowitz, M. and Stegun, I. A., Handbook of Mathematical Functions,
        /// 10th printing, New York: Dover, 1964, pp. 79ff.
        /// http://www.math.sfu.ca/~cbm/aands/
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The inverse sine of each element in x, in radians and in the
        /// closed interval [-pi/2, pi/2].
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray arcsin(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.arcsin(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Trigonometric inverse cosine, element-wise.
        /// 
        /// The inverse of cos so that, if y = cos(x), then x = arccos(y).
        /// 
        /// Notes
        /// 
        /// arccos is a multivalued function: for each x there are infinitely
        /// many numbers z such that cos(z) = x. The convention is to return
        /// the angle z whose real part lies in [0, pi].
        /// 
        /// For real-valued input data types, arccos always returns real output.
        /// For each value that cannot be expressed as a real number or infinity,
        /// it yields nan and sets the invalid floating point error flag.
        /// 
        /// For complex-valued input, arccos is a complex analytic function that
        /// has branch cuts [-inf, -1] and [1, inf] and is continuous from
        /// above on the former and from below on the latter.
        /// 
        /// The inverse cos is also known as acos or cos^-1.
        /// 
        /// References
        /// 
        /// M. Abramowitz and I.A. Stegun, “Handbook of Mathematical Functions”,
        /// 10th printing, 1964, pp. 79. http://www.math.sfu.ca/~cbm/aands/
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The angle of the ray intersecting the unit circle at the given
        /// x-coordinate in radians [0, pi].
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray arccos(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.arccos(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Trigonometric inverse tangent, element-wise.
        /// 
        /// The inverse of tan, so that if y = tan(x) then x = arctan(y).
        /// 
        /// Notes
        /// 
        /// arctan is a multi-valued function: for each x there are infinitely
        /// many numbers z such that tan(z) = x.  The convention is to return
        /// the angle z whose real part lies in [-pi/2, pi/2].
        /// 
        /// For real-valued input data types, arctan always returns real output.
        /// For each value that cannot be expressed as a real number or infinity,
        /// it yields nan and sets the invalid floating point error flag.
        /// 
        /// For complex-valued input, arctan is a complex analytic function that
        /// has [1j, infj] and [-1j, -infj] as branch cuts, and is continuous
        /// from the left on the former and from the right on the latter.
        /// 
        /// The inverse tangent is also known as atan or tan^{-1}.
        /// 
        /// References
        /// 
        /// Abramowitz, M. and Stegun, I. A., Handbook of Mathematical Functions,
        /// 10th printing, New York: Dover, 1964, pp. 79.
        /// http://www.math.sfu.ca/~cbm/aands/
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Out has the same shape as x.  Its real part is in
        /// [-pi/2, pi/2] (arctan(+/-inf) returns +/-pi/2).
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray arctan(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.arctan(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Given the “legs” of a right triangle, return its hypotenuse.
        /// 
        /// Equivalent to sqrt(x1**2 + x2**2), element-wise.  If x1 or
        /// x2 is scalar_like (i.e., unambiguously cast-able to a scalar type),
        /// it is broadcast for use with each element of the other argument.
        /// (See Examples)
        /// </summary>
        /// <param name="x1">
        /// Leg of the triangle(s).
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The hypotenuse of the triangle(s).
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray hypot(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.hypot(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Element-wise arc tangent of x1/x2 choosing the quadrant correctly.
        /// 
        /// The quadrant (i.e., branch) is chosen so that arctan2(x1, x2) is
        /// the signed angle in radians between the ray ending at the origin and
        /// passing through the point (1,0), and the ray ending at the origin and
        /// passing through the point (x2, x1).  (Note the role reversal: the
        /// “y-coordinate” is the first function parameter, the “x-coordinate”
        /// is the second.)  By IEEE convention, this function is defined for
        /// x2 = +/-0 and for either or both of x1 and x2 = +/-inf (see
        /// Notes for specific values).
        /// 
        /// This function is not defined for complex-valued arguments; for the
        /// so-called argument of complex values, use angle.
        /// 
        /// Notes
        /// 
        /// arctan2 is identical to the atan2 function of the underlying
        /// C library.  The following special values are defined in the C
        /// standard: [1]
        /// 
        /// Note that +0 and -0 are distinct floating point numbers, as are +inf
        /// and -inf.
        /// 
        /// References
        /// </summary>
        /// <param name="x2">
        /// x-coordinates. x2 must be broadcastable to match the shape of
        /// x1 or vice versa.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Array of angles in radians, in the range [-pi, pi].
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray arctan2(NDarray x2, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.arctan2(@this, x2, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Convert angles from radians to degrees.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The corresponding degree values; if out was supplied this is a
        /// reference to it.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray degrees(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.degrees(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Convert angles from degrees to radians.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The corresponding radian values.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray radians(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.radians(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Unwrap by changing deltas between values to 2*pi complement.
        /// 
        /// Unwrap radian phase p by changing absolute jumps greater than
        /// discont to their 2*pi complement along the given axis.
        /// 
        /// Notes
        /// 
        /// If the discontinuity in p is smaller than pi, but larger than
        /// discont, no unwrapping is done because taking the 2*pi complement
        /// would only make the discontinuity larger.
        /// </summary>
        /// <param name="discont">
        /// Maximum discontinuity between values, default is pi.
        /// </param>
        /// <param name="axis">
        /// Axis along which unwrap will operate, default is the last axis.
        /// </param>
        /// <returns>
        /// Output array.
        /// </returns>
        public NDarray unwrap(float? discont = 3.141592653589793f, int? axis = -1)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.unwrap(@this, discont:discont, axis:axis);
        }
        
        /// <summary>
        /// Convert angles from degrees to radians.
        /// 
        /// Notes
        /// 
        /// deg2rad(x) is x * pi / 180.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The corresponding angle in radians.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray deg2rad(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.deg2rad(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Convert angles from radians to degrees.
        /// 
        /// Notes
        /// 
        /// rad2deg(x) is 180 * x / pi.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The corresponding angle in degrees.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray rad2deg(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.rad2deg(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Hyperbolic sine, element-wise.
        /// 
        /// Equivalent to 1/2 * (np.exp(x) - np.exp(-x)) or
        /// -1j * np.sin(1j*x).
        /// 
        /// Notes
        /// 
        /// If out is provided, the function writes the result into it,
        /// and returns a reference to out.  (See Examples)
        /// 
        /// References
        /// 
        /// M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.
        /// New York, NY: Dover, 1972, pg. 83.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The corresponding hyperbolic sine values.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray sinh(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.sinh(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Hyperbolic cosine, element-wise.
        /// 
        /// Equivalent to 1/2 * (np.exp(x) + np.exp(-x)) and np.cos(1j*x).
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Output array of same shape as x.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray cosh(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.cosh(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Compute hyperbolic tangent element-wise.
        /// 
        /// Equivalent to np.sinh(x)/np.cosh(x) or -1j * np.tan(1j*x).
        /// 
        /// Notes
        /// 
        /// If out is provided, the function writes the result into it,
        /// and returns a reference to out.  (See Examples)
        /// 
        /// References
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The corresponding hyperbolic tangent values.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray tanh(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.tanh(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Inverse hyperbolic sine element-wise.
        /// 
        /// Notes
        /// 
        /// arcsinh is a multivalued function: for each x there are infinitely
        /// many numbers z such that sinh(z) = x. The convention is to return the
        /// z whose imaginary part lies in [-pi/2, pi/2].
        /// 
        /// For real-valued input data types, arcsinh always returns real output.
        /// For each value that cannot be expressed as a real number or infinity, it
        /// returns nan and sets the invalid floating point error flag.
        /// 
        /// For complex-valued input, arccos is a complex analytical function that
        /// has branch cuts [1j, infj] and [-1j, -infj] and is continuous from
        /// the right on the former and from the left on the latter.
        /// 
        /// The inverse hyperbolic sine is also known as asinh or sinh^-1.
        /// 
        /// References
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Array of the same shape as x.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray arcsinh(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.arcsinh(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Inverse hyperbolic cosine, element-wise.
        /// 
        /// Notes
        /// 
        /// arccosh is a multivalued function: for each x there are infinitely
        /// many numbers z such that cosh(z) = x. The convention is to return the
        /// z whose imaginary part lies in [-pi, pi] and the real part in
        /// [0, inf].
        /// 
        /// For real-valued input data types, arccosh always returns real output.
        /// For each value that cannot be expressed as a real number or infinity, it
        /// yields nan and sets the invalid floating point error flag.
        /// 
        /// For complex-valued input, arccosh is a complex analytical function that
        /// has a branch cut [-inf, 1] and is continuous from above on it.
        /// 
        /// References
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Array of the same shape as x.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray arccosh(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.arccosh(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Inverse hyperbolic tangent element-wise.
        /// 
        /// Notes
        /// 
        /// arctanh is a multivalued function: for each x there are infinitely
        /// many numbers z such that tanh(z) = x. The convention is to return
        /// the z whose imaginary part lies in [-pi/2, pi/2].
        /// 
        /// For real-valued input data types, arctanh always returns real output.
        /// For each value that cannot be expressed as a real number or infinity,
        /// it yields nan and sets the invalid floating point error flag.
        /// 
        /// For complex-valued input, arctanh is a complex analytical function
        /// that has branch cuts [-1, -inf] and [1, inf] and is continuous from
        /// above on the former and from below on the latter.
        /// 
        /// The inverse hyperbolic tangent is also known as atanh or tanh^-1.
        /// 
        /// References
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Array of the same shape as x.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray arctanh(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.arctanh(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Evenly round to the given number of decimals.
        /// 
        /// Notes
        /// 
        /// For values exactly halfway between rounded decimal values, NumPy
        /// rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,
        /// -0.5 and 0.5 round to 0.0, etc. Results may also be surprising due
        /// to the inexact representation of decimal fractions in the IEEE
        /// floating point standard [1] and errors introduced when scaling
        /// by powers of ten.
        /// 
        /// References
        /// </summary>
        /// <param name="decimals">
        /// Number of decimal places to round to (default: 0).  If
        /// decimals is negative, it specifies the number of positions to
        /// the left of the decimal point.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output, but the type of the output
        /// values will be cast if necessary. See doc.ufuncs (Section
        /// “Output arguments”) for details.
        /// </param>
        /// <returns>
        /// An array of the same type as a, containing the rounded values.
        /// Unless out was specified, a new array is created.  A reference to
        /// the result is returned.
        /// 
        /// The real and imaginary parts of complex numbers are rounded
        /// separately.  The result of rounding a float is a float.
        /// </returns>
        public NDarray around(int? decimals = 0, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.around(@this, decimals:decimals, @out:@out);
        }
        
        /// <summary>
        /// Round elements of the array to the nearest integer.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Output array is same shape and type as x.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray rint(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.rint(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Round to nearest integer towards zero.
        /// 
        /// Round an array of floats element-wise to nearest integer towards zero.
        /// The rounded values are returned as floats.
        /// </summary>
        /// <param name="y">
        /// Output array
        /// </param>
        /// <returns>
        /// The array of rounded numbers
        /// </returns>
        public NDarray fix(NDarray y = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.fix(@this, y:y);
        }
        
        /// <summary>
        /// Return the floor of the input, element-wise.
        /// 
        /// The floor of the scalar x is the largest integer i, such that
        /// i &lt;= x.  It is often denoted as .
        /// 
        /// Notes
        /// 
        /// Some spreadsheet programs calculate the “floor-towards-zero”, in other
        /// words floor(-2.5) == -2.  NumPy instead uses the definition of
        /// floor where floor(-2.5) == -3.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The floor of each element in x.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray floor(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.floor(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return the ceiling of the input, element-wise.
        /// 
        /// The ceil of the scalar x is the smallest integer i, such that
        /// i &gt;= x.  It is often denoted as .
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The ceiling of each element in x, with float dtype.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray ceil(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.ceil(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return the truncated value of the input, element-wise.
        /// 
        /// The truncated value of the scalar x is the nearest integer i which
        /// is closer to zero than x is. In short, the fractional part of the
        /// signed number x is discarded.
        /// 
        /// Notes
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The truncated value of each element in x.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray trunc(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.trunc(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return the product of array elements over a given axis.
        /// 
        /// Notes
        /// 
        /// Arithmetic is modular when using integer types, and no error is
        /// raised on overflow.  That means that, on a 32-bit platform:
        /// 
        /// The product of an empty array is the neutral element 1:
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which a product is performed.  The default,
        /// axis=None, will calculate the product of all the elements in the
        /// input array. If axis is negative it counts from the last to the
        /// first axis.
        /// 
        /// If axis is a tuple of ints, a product is performed on all of the
        /// axes specified in the tuple instead of a single axis or all the
        /// axes as before.
        /// </param>
        /// <param name="dtype">
        /// The type of the returned array, as well as of the accumulator in
        /// which the elements are multiplied.  The dtype of a is used by
        /// default unless a has an integer dtype of less precision than the
        /// default platform integer.  In that case, if a is signed then the
        /// platform integer is used while if a is unsigned then an unsigned
        /// integer of the same precision as the platform integer is used.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output, but the type of the output
        /// values will be cast if necessary.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left in the
        /// result as dimensions with size one. With this option, the result
        /// will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the prod method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <param name="initial">
        /// The starting value for this product. See reduce for details.
        /// </param>
        /// <returns>
        /// An array shaped as a but with the specified axis removed.
        /// Returns a reference to out if specified.
        /// </returns>
        public NDarray prod(int[] axis = null, Dtype dtype = null, NDarray @out = null, bool? keepdims = null, ValueType initial = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.prod(@this, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims, initial:initial);
        }
        
        /// <summary>
        /// Sum of array elements over a given axis.
        /// 
        /// Notes
        /// 
        /// Arithmetic is modular when using integer types, and no error is
        /// raised on overflow.
        /// 
        /// The sum of an empty array is the neutral element 0:
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which a sum is performed.  The default,
        /// axis=None, will sum all of the elements of the input array.  If
        /// axis is negative it counts from the last to the first axis.
        /// 
        /// If axis is a tuple of ints, a sum is performed on all of the axes
        /// specified in the tuple instead of a single axis or all the axes as
        /// before.
        /// </param>
        /// <param name="dtype">
        /// The type of the returned array and of the accumulator in which the
        /// elements are summed.  The dtype of a is used by default unless a
        /// has an integer dtype of less precision than the default platform
        /// integer.  In that case, if a is signed then the platform integer
        /// is used while if a is unsigned then an unsigned integer of the
        /// same precision as the platform integer is used.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output, but the type of the output
        /// values will be cast if necessary.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the sum method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <param name="initial">
        /// Starting value for the sum. See reduce for details.
        /// </param>
        /// <returns>
        /// An array with the same shape as a, with the specified
        /// axis removed.   If a is a 0-d array, or if axis is None, a scalar
        /// is returned.  If an output array is specified, a reference to
        /// out is returned.
        /// </returns>
        public NDarray sum(int[] axis = null, Dtype dtype = null, NDarray @out = null, bool? keepdims = null, ValueType initial = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.sum(@this, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims, initial:initial);
        }
        
        /// <summary>
        /// Return the product of array elements over a given axis treating Not a
        /// Numbers (NaNs) as ones.
        /// 
        /// One is returned for slices that are all-NaN or empty.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the product is computed. The default is to compute
        /// the product of the flattened array.
        /// </param>
        /// <param name="dtype">
        /// The type of the returned array and of the accumulator in which the
        /// elements are summed.  By default, the dtype of a is used.  An
        /// exception is when a has an integer type with less precision than
        /// the platform (u)intp. In that case, the default will be either
        /// (u)int32 or (u)int64 depending on whether the platform is 32 or 64
        /// bits. For inexact inputs, dtype must be inexact.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None. If provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.  See
        /// doc.ufuncs for details. The casting of NaN to integer can yield
        /// unexpected results.
        /// </param>
        /// <param name="keepdims">
        /// If True, the axes which are reduced are left in the result as
        /// dimensions with size one. With this option, the result will
        /// broadcast correctly against the original arr.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which case it is returned.
        /// </returns>
        public NDarray nanprod(int[] axis = null, Dtype dtype = null, NDarray @out = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanprod(@this, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims);
        }
        
        /// <summary>
        /// Return the sum of array elements over a given axis treating Not a
        /// Numbers (NaNs) as zero.
        /// 
        /// In NumPy versions &lt;= 1.9.0 Nan is returned for slices that are all-NaN or
        /// empty. In later versions zero is returned.
        /// 
        /// Notes
        /// 
        /// If both positive and negative infinity are present, the sum will be Not
        /// A Number (NaN).
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the sum is computed. The default is to compute the
        /// sum of the flattened array.
        /// </param>
        /// <param name="dtype">
        /// The type of the returned array and of the accumulator in which the
        /// elements are summed.  By default, the dtype of a is used.  An
        /// exception is when a has an integer type with less precision than
        /// the platform (u)intp. In that case, the default will be either
        /// (u)int32 or (u)int64 depending on whether the platform is 32 or 64
        /// bits. For inexact inputs, dtype must be inexact.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None. If provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.  See
        /// doc.ufuncs for details. The casting of NaN to integer can yield
        /// unexpected results.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// 
        /// If the value is anything but the default, then
        /// keepdims will be passed through to the mean or sum methods
        /// of sub-classes of ndarray.  If the sub-classes methods
        /// does not implement keepdims any exceptions will be raised.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which it is returned. The result has the same
        /// size as a, and the same shape as a if axis is not None
        /// or a is a 1-d array.
        /// </returns>
        public NDarray nansum(int[] axis = null, Dtype dtype = null, NDarray @out = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nansum(@this, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims);
        }
        
        /// <summary>
        /// Return the cumulative product of elements along a given axis.
        /// 
        /// Notes
        /// 
        /// Arithmetic is modular when using integer types, and no error is
        /// raised on overflow.
        /// </summary>
        /// <param name="axis">
        /// Axis along which the cumulative product is computed.  By default
        /// the input is flattened.
        /// </param>
        /// <param name="dtype">
        /// Type of the returned array, as well as of the accumulator in which
        /// the elements are multiplied.  If dtype is not specified, it
        /// defaults to the dtype of a, unless a has an integer dtype with
        /// a precision less than that of the default platform integer.  In
        /// that case, the default platform integer is used instead.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output
        /// but the type of the resulting values will be cast if necessary.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which case a reference to out is returned.
        /// </returns>
        public NDarray cumprod(int? axis = null, Dtype dtype = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.cumprod(@this, axis:axis, dtype:dtype, @out:@out);
        }
        
        /// <summary>
        /// Return the cumulative sum of the elements along a given axis.
        /// 
        /// Notes
        /// 
        /// Arithmetic is modular when using integer types, and no error is
        /// raised on overflow.
        /// </summary>
        /// <param name="axis">
        /// Axis along which the cumulative sum is computed. The default
        /// (None) is to compute the cumsum over the flattened array.
        /// </param>
        /// <param name="dtype">
        /// Type of the returned array and of the accumulator in which the
        /// elements are summed.  If dtype is not specified, it defaults
        /// to the dtype of a, unless a has an integer dtype with a
        /// precision less than that of the default platform integer.  In
        /// that case, the default platform integer is used.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output
        /// but the type will be cast if necessary. See doc.ufuncs
        /// (Section “Output arguments”) for more details.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which case a reference to out is returned. The
        /// result has the same size as a, and the same shape as a if
        /// axis is not None or a is a 1-d array.
        /// </returns>
        public NDarray cumsum(int? axis = null, Dtype dtype = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.cumsum(@this, axis:axis, dtype:dtype, @out:@out);
        }
        
        /// <summary>
        /// Return the cumulative product of array elements over a given axis treating Not a
        /// Numbers (NaNs) as one.  The cumulative product does not change when NaNs are
        /// encountered and leading NaNs are replaced by ones.
        /// 
        /// Ones are returned for slices that are all-NaN or empty.
        /// </summary>
        /// <param name="axis">
        /// Axis along which the cumulative product is computed.  By default
        /// the input is flattened.
        /// </param>
        /// <param name="dtype">
        /// Type of the returned array, as well as of the accumulator in which
        /// the elements are multiplied.  If dtype is not specified, it
        /// defaults to the dtype of a, unless a has an integer dtype with
        /// a precision less than that of the default platform integer.  In
        /// that case, the default platform integer is used instead.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output
        /// but the type of the resulting values will be cast if necessary.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which case it is returned.
        /// </returns>
        public NDarray nancumprod(int? axis = null, Dtype dtype = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nancumprod(@this, axis:axis, dtype:dtype, @out:@out);
        }
        
        /// <summary>
        /// Return the cumulative sum of array elements over a given axis treating Not a
        /// Numbers (NaNs) as zero.  The cumulative sum does not change when NaNs are
        /// encountered and leading NaNs are replaced by zeros.
        /// 
        /// Zeros are returned for slices that are all-NaN or empty.
        /// </summary>
        /// <param name="axis">
        /// Axis along which the cumulative sum is computed. The default
        /// (None) is to compute the cumsum over the flattened array.
        /// </param>
        /// <param name="dtype">
        /// Type of the returned array and of the accumulator in which the
        /// elements are summed.  If dtype is not specified, it defaults
        /// to the dtype of a, unless a has an integer dtype with a
        /// precision less than that of the default platform integer.  In
        /// that case, the default platform integer is used.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output
        /// but the type will be cast if necessary. See doc.ufuncs
        /// (Section “Output arguments”) for more details.
        /// </param>
        /// <returns>
        /// A new array holding the result is returned unless out is
        /// specified, in which it is returned. The result has the same
        /// size as a, and the same shape as a if axis is not None
        /// or a is a 1-d array.
        /// </returns>
        public NDarray nancumsum(int? axis = null, Dtype dtype = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nancumsum(@this, axis:axis, dtype:dtype, @out:@out);
        }
        
        /// <summary>
        /// Calculate the n-th discrete difference along the given axis.
        /// 
        /// The first difference is given by out[n] = a[n+1] - a[n] along
        /// the given axis, higher differences are calculated by using diff
        /// recursively.
        /// 
        /// Notes
        /// 
        /// Type is preserved for boolean arrays, so the result will contain
        /// False when consecutive elements are the same and True when they
        /// differ.
        /// 
        /// For unsigned integer arrays, the results will also be unsigned. This
        /// should not be surprising, as the result is consistent with
        /// calculating the difference directly:
        /// 
        /// If this is not desirable, then the array should be cast to a larger
        /// integer type first:
        /// </summary>
        /// <param name="n">
        /// The number of times values are differenced. If zero, the input
        /// is returned as-is.
        /// </param>
        /// <param name="axis">
        /// The axis along which the difference is taken, default is the
        /// last axis.
        /// </param>
        /// <param name="append">
        /// Values to prepend or append to “a” along axis prior to
        /// performing the difference.  Scalar values are expanded to
        /// arrays with length 1 in the direction of axis and the shape
        /// of the input array in along all other axes.  Otherwise the
        /// dimension and shape must match “a” except along axis.
        /// </param>
        /// <param name="prepend">
        /// Values to prepend or append to “a” along axis prior to
        /// performing the difference.  Scalar values are expanded to
        /// arrays with length 1 in the direction of axis and the shape
        /// of the input array in along all other axes.  Otherwise the
        /// dimension and shape must match “a” except along axis.
        /// </param>
        /// <returns>
        /// The n-th differences. The shape of the output is the same as a
        /// except along axis where the dimension is smaller by n. The
        /// type of the output is the same as the type of the difference
        /// between any two elements of a. This is the same as the type of
        /// a in most cases. A notable exception is datetime64, which
        /// results in a timedelta64 output array.
        /// </returns>
        public NDarray diff(int? n = 1, int? axis = -1, NDarray append = null, NDarray prepend = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.diff(@this, n:n, axis:axis, append:append, prepend:prepend);
        }
        
        /// <summary>
        /// The differences between consecutive elements of an array.
        /// 
        /// Notes
        /// 
        /// When applied to masked arrays, this function drops the mask information
        /// if the to_begin and/or to_end parameters are used.
        /// </summary>
        /// <param name="to_end">
        /// Number(s) to append at the end of the returned differences.
        /// </param>
        /// <param name="to_begin">
        /// Number(s) to prepend at the beginning of the returned differences.
        /// </param>
        /// <returns>
        /// The differences. Loosely, this is ary.flat[1:] - ary.flat[:-1].
        /// </returns>
        public NDarray ediff1d(NDarray to_end = null, NDarray to_begin = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.ediff1d(@this, to_end:to_end, to_begin:to_begin);
        }
        
        /// <summary>
        /// Return the gradient of an N-dimensional array.
        /// 
        /// The gradient is computed using second order accurate central differences
        /// in the interior points and either first or second order accurate one-sides
        /// (forward or backwards) differences at the boundaries.
        /// The returned gradient hence has the same shape as the input array.
        /// 
        /// Notes
        /// 
        /// Assuming that  (i.e.,  has at least 3 continuous
        /// derivatives) and let  be a non-homogeneous stepsize, we
        /// minimize the “consistency error”  between the true gradient
        /// and its estimate from a linear combination of the neighboring grid-points:
        /// 
        /// By substituting  and 
        /// with their Taylor series expansion, this translates into solving
        /// the following the linear system:
        /// 
        /// The resulting approximation of  is the following:
        /// 
        /// It is worth noting that if 
        /// (i.e., data are evenly spaced)
        /// we find the standard second order approximation:
        /// 
        /// With a similar procedure the forward/backward approximations used for
        /// boundaries can be derived.
        /// 
        /// References
        /// </summary>
        /// <param name="varargs">
        /// Spacing between f values. Default unitary spacing for all dimensions.
        /// Spacing can be specified using:
        /// 
        /// If axis is given, the number of varargs must equal the number of axes.
        /// Default: 1.
        /// </param>
        /// <param name="edge_order">
        /// Gradient is calculated using N-th order accurate differences
        /// at the boundaries. Default: 1.
        /// </param>
        /// <param name="axis">
        /// Gradient is calculated only along the given axis or axes
        /// The default (axis = None) is to calculate the gradient for all the axes
        /// of the input array. axis may be negative, in which case it counts from
        /// the last to the first axis.
        /// </param>
        /// <returns>
        /// A set of ndarrays (or a single ndarray if there is only one dimension)
        /// corresponding to the derivatives of f with respect to each dimension.
        /// Each derivative has the same shape as f.
        /// </returns>
        public NDarray gradient(NDarray varargs = null, int? edge_order = null, int[] axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.gradient(@this, varargs:varargs, edge_order:edge_order, axis:axis);
        }
        
        /// <summary>
        /// Return the cross product of two (arrays of) vectors.
        /// 
        /// The cross product of a and b in  is a vector perpendicular
        /// to both a and b.  If a and b are arrays of vectors, the vectors
        /// are defined by the last axis of a and b by default, and these axes
        /// can have dimensions 2 or 3.  Where the dimension of either a or b is
        /// 2, the third component of the input vector is assumed to be zero and the
        /// cross product calculated accordingly.  In cases where both input vectors
        /// have dimension 2, the z-component of the cross product is returned.
        /// 
        /// Notes
        /// 
        /// Supports full broadcasting of the inputs.
        /// </summary>
        /// <param name="b">
        /// Components of the second vector(s).
        /// </param>
        /// <param name="axisa">
        /// Axis of a that defines the vector(s).  By default, the last axis.
        /// </param>
        /// <param name="axisb">
        /// Axis of b that defines the vector(s).  By default, the last axis.
        /// </param>
        /// <param name="axisc">
        /// Axis of c containing the cross product vector(s).  Ignored if
        /// both input vectors have dimension 2, as the return is scalar.
        /// By default, the last axis.
        /// </param>
        /// <param name="axis">
        /// If defined, the axis of a, b and c that defines the vector(s)
        /// and cross product(s).  Overrides axisa, axisb and axisc.
        /// </param>
        /// <returns>
        /// Vector cross product(s).
        /// </returns>
        public NDarray cross(NDarray b, int? axisa = -1, int? axisb = -1, int? axisc = -1, int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.cross(@this, b, axisa:axisa, axisb:axisb, axisc:axisc, axis:axis);
        }
        
        /// <summary>
        /// Integrate along the given axis using the composite trapezoidal rule.
        /// 
        /// Integrate y (x) along given axis.
        /// 
        /// Notes
        /// 
        /// Image [2] illustrates trapezoidal rule – y-axis locations of points
        /// will be taken from y array, by default x-axis distances between
        /// points will be 1.0, alternatively they can be provided with x array
        /// or with dx scalar.  Return value will be equal to combined area under
        /// the red lines.
        /// 
        /// References
        /// </summary>
        /// <param name="x">
        /// The sample points corresponding to the y values. If x is None,
        /// the sample points are assumed to be evenly spaced dx apart. The
        /// default is None.
        /// </param>
        /// <param name="dx">
        /// The spacing between sample points when x is None. The default is 1.
        /// </param>
        /// <param name="axis">
        /// The axis along which to integrate.
        /// </param>
        /// <returns>
        /// Definite integral as approximated by trapezoidal rule.
        /// </returns>
        public float trapz(NDarray x = null, float? dx = 1.0f, int? axis = -1)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.trapz(@this, x:x, dx:dx, axis:axis);
        }
        
        /// <summary>
        /// Calculate the exponential of all elements in the input array.
        /// 
        /// Notes
        /// 
        /// The irrational number e is also known as Euler’s number.  It is
        /// approximately 2.718281, and is the base of the natural logarithm,
        /// ln (this means that, if ,
        /// then . For real input, exp(x) is always positive.
        /// 
        /// For complex arguments, x = a + ib, we can write
        /// .  The first term, , is already
        /// known (it is the real argument, described above).  The second term,
        /// , is , a function with
        /// magnitude 1 and a periodic phase.
        /// 
        /// References
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Output array, element-wise exponential of x.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray exp(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.exp(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Calculate exp(x) - 1 for all elements in the array.
        /// 
        /// Notes
        /// 
        /// This function provides greater precision than exp(x) - 1
        /// for small values of x.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Element-wise exponential minus one: out = exp(x) - 1.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray expm1(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.expm1(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Calculate 2**p for all p in the input array.
        /// 
        /// Notes
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Element-wise 2 to the power x.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray exp2(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.exp2(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Natural logarithm, element-wise.
        /// 
        /// The natural logarithm log is the inverse of the exponential function,
        /// so that log(exp(x)) = x. The natural logarithm is logarithm in base
        /// e.
        /// 
        /// Notes
        /// 
        /// Logarithm is a multivalued function: for each x there is an infinite
        /// number of z such that exp(z) = x. The convention is to return the
        /// z whose imaginary part lies in [-pi, pi].
        /// 
        /// For real-valued input data types, log always returns real output. For
        /// each value that cannot be expressed as a real number or infinity, it
        /// yields nan and sets the invalid floating point error flag.
        /// 
        /// For complex-valued input, log is a complex analytical function that
        /// has a branch cut [-inf, 0] and is continuous from above on it. log
        /// handles the floating-point negative zero as an infinitesimal negative
        /// number, conforming to the C99 standard.
        /// 
        /// References
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The natural logarithm of x, element-wise.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray log(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.log(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return the base 10 logarithm of the input array, element-wise.
        /// 
        /// Notes
        /// 
        /// Logarithm is a multivalued function: for each x there is an infinite
        /// number of z such that 10**z = x. The convention is to return the
        /// z whose imaginary part lies in [-pi, pi].
        /// 
        /// For real-valued input data types, log10 always returns real output.
        /// For each value that cannot be expressed as a real number or infinity,
        /// it yields nan and sets the invalid floating point error flag.
        /// 
        /// For complex-valued input, log10 is a complex analytical function that
        /// has a branch cut [-inf, 0] and is continuous from above on it.
        /// log10 handles the floating-point negative zero as an infinitesimal
        /// negative number, conforming to the C99 standard.
        /// 
        /// References
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The logarithm to the base 10 of x, element-wise. NaNs are
        /// returned where x is negative.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray log10(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.log10(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Base-2 logarithm of x.
        /// 
        /// Notes
        /// 
        /// Logarithm is a multivalued function: for each x there is an infinite
        /// number of z such that 2**z = x. The convention is to return the z
        /// whose imaginary part lies in [-pi, pi].
        /// 
        /// For real-valued input data types, log2 always returns real output.
        /// For each value that cannot be expressed as a real number or infinity,
        /// it yields nan and sets the invalid floating point error flag.
        /// 
        /// For complex-valued input, log2 is a complex analytical function that
        /// has a branch cut [-inf, 0] and is continuous from above on it. log2
        /// handles the floating-point negative zero as an infinitesimal negative
        /// number, conforming to the C99 standard.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Base-2 logarithm of x.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray log2(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.log2(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return the natural logarithm of one plus the input array, element-wise.
        /// 
        /// Calculates log(1 + x).
        /// 
        /// Notes
        /// 
        /// For real-valued input, log1p is accurate also for x so small
        /// that 1 + x == 1 in floating-point accuracy.
        /// 
        /// Logarithm is a multivalued function: for each x there is an infinite
        /// number of z such that exp(z) = 1 + x. The convention is to return
        /// the z whose imaginary part lies in [-pi, pi].
        /// 
        /// For real-valued input data types, log1p always returns real output.
        /// For each value that cannot be expressed as a real number or infinity,
        /// it yields nan and sets the invalid floating point error flag.
        /// 
        /// For complex-valued input, log1p is a complex analytical function that
        /// has a branch cut [-inf, -1] and is continuous from above on it.
        /// log1p handles the floating-point negative zero as an infinitesimal
        /// negative number, conforming to the C99 standard.
        /// 
        /// References
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Natural logarithm of 1 + x, element-wise.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray log1p(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.log1p(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Logarithm of the sum of exponentiations of the inputs.
        /// 
        /// Calculates log(exp(x1) + exp(x2)). This function is useful in
        /// statistics where the calculated probabilities of events may be so small
        /// as to exceed the range of normal floating point numbers.  In such cases
        /// the logarithm of the calculated probability is stored. This function
        /// allows adding probabilities stored in such a fashion.
        /// 
        /// Notes
        /// </summary>
        /// <param name="x1">
        /// Input values.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Logarithm of exp(x1) + exp(x2).
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray logaddexp(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.logaddexp(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Logarithm of the sum of exponentiations of the inputs in base-2.
        /// 
        /// Calculates log2(2**x1 + 2**x2). This function is useful in machine
        /// learning when the calculated probabilities of events may be so small as
        /// to exceed the range of normal floating point numbers.  In such cases
        /// the base-2 logarithm of the calculated probability can be used instead.
        /// This function allows adding probabilities stored in such a fashion.
        /// 
        /// Notes
        /// </summary>
        /// <param name="x1">
        /// Input values.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Base-2 logarithm of 2**x1 + 2**x2.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray logaddexp2(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.logaddexp2(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return the sinc function.
        /// 
        /// The sinc function is .
        /// 
        /// Notes
        /// 
        /// sinc(0) is the limit value 1.
        /// 
        /// The name sinc is short for “sine cardinal” or “sinus cardinalis”.
        /// 
        /// The sinc function is used in various signal processing applications,
        /// including in anti-aliasing, in the construction of a Lanczos resampling
        /// filter, and in interpolation.
        /// 
        /// For bandlimited interpolation of discrete-time signals, the ideal
        /// interpolation kernel is proportional to the sinc function.
        /// 
        /// References
        /// </summary>
        /// <returns>
        /// sinc(x), which has the same shape as the input.
        /// </returns>
        public NDarray sinc()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.sinc(@this);
        }
        
        /// <summary>
        /// Returns element-wise True where signbit is set (less than zero).
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Output array, or reference to out if that was supplied.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray signbit(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.signbit(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Change the sign of x1 to that of x2, element-wise.
        /// 
        /// If both arguments are arrays or sequences, they have to be of the same
        /// length. If x2 is a scalar, its sign will be copied to all elements of
        /// x1.
        /// </summary>
        /// <param name="x2">
        /// The sign of x2 is copied to x1.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The values of x1 with the sign of x2.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray copysign(NDarray x2, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.copysign(@this, x2, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Decompose the elements of x into mantissa and twos exponent.
        /// 
        /// Returns (mantissa, exponent), where x = mantissa * 2**exponent`.
        /// The mantissa is lies in the open interval(-1, 1), while the twos
        /// exponent is a signed integer.
        /// 
        /// Notes
        /// 
        /// Complex dtypes are not supported, they will raise a TypeError.
        /// </summary>
        /// <param name="out1">
        /// Output array for the mantissa. Must have the same shape as x.
        /// </param>
        /// <param name="out2">
        /// Output array for the exponent. Must have the same shape as x.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// mantissa
        /// Floating values between -1 and 1.
        /// This is a scalar if x is a scalar.
        /// exponent
        /// Integer exponents of 2.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public (NDarray, NDarray) frexp(NDarray out1 = null, NDarray out2 = null, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.frexp(@this, out1:out1, out2:out2, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Returns x1 * 2**x2, element-wise.
        /// 
        /// The mantissas x1 and twos exponents x2 are used to construct
        /// floating point numbers x1 * 2**x2.
        /// 
        /// Notes
        /// 
        /// Complex dtypes are not supported, they will raise a TypeError.
        /// 
        /// ldexp is useful as the inverse of frexp, if used by itself it is
        /// more clear to simply use the expression x1 * 2**x2.
        /// </summary>
        /// <param name="x2">
        /// Array of twos exponents.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The result of x1 * 2**x2.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray ldexp(NDarray x2, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.ldexp(@this, x2, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return the next floating-point value after x1 towards x2, element-wise.
        /// </summary>
        /// <param name="x2">
        /// The direction where to look for the next representable value of x1.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The next representable values of x1 in the direction of x2.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray nextafter(NDarray x2, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nextafter(@this, x2, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return the distance between x and the nearest adjacent number.
        /// 
        /// Notes
        /// 
        /// It can be considered as a generalization of EPS:
        /// spacing(np.float64(1)) == np.finfo(np.float64).eps, and there
        /// should not be any representable number between x + spacing(x) and
        /// x for any finite x.
        /// 
        /// Spacing of +- inf and NaN is NaN.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The spacing of values of x.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray spacing(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.spacing(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Returns the lowest common multiple of |x1| and |x2|
        /// </summary>
        /// <param name="x1">
        /// Arrays of values
        /// </param>
        /// <returns>
        /// The lowest common multiple of the absolute value of the inputs
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray lcm(NDarray x1)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.lcm(@this, x1);
        }
        
        /// <summary>
        /// Returns the greatest common divisor of |x1| and |x2|
        /// </summary>
        /// <param name="x1">
        /// Arrays of values
        /// </param>
        /// <returns>
        /// The greatest common divisor of the absolute value of the inputs
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray gcd(NDarray x1)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.gcd(@this, x1);
        }
        
        /// <summary>
        /// Add arguments element-wise.
        /// 
        /// Notes
        /// 
        /// Equivalent to x1 + x2 in terms of array broadcasting.
        /// </summary>
        /// <param name="x1">
        /// The arrays to be added.  If x1.shape != x2.shape, they must be
        /// broadcastable to a common shape (which may be the shape of one or
        /// the other).
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The sum of x1 and x2, element-wise.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray @add(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.@add(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return the reciprocal of the argument, element-wise.
        /// 
        /// Calculates 1/x.
        /// 
        /// Notes
        /// 
        /// For integer arguments with absolute value larger than 1 the result is
        /// always zero because of the way Python handles integer division.  For
        /// integer zero the result is an overflow.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Return array.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray reciprocal(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.reciprocal(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Numerical positive, element-wise.
        /// 
        /// Notes
        /// 
        /// Equivalent to x.copy(), but only defined for types that support
        /// arithmetic.
        /// </summary>
        /// <returns>
        /// Returned array or scalar: y = +x.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray positive()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.positive(@this);
        }
        
        /// <summary>
        /// Numerical negative, element-wise.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Returned array or scalar: y = -x.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray negative(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.negative(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Multiply arguments element-wise.
        /// 
        /// Notes
        /// 
        /// Equivalent to x1 * x2 in terms of array broadcasting.
        /// </summary>
        /// <param name="x1">
        /// Input arrays to be multiplied.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The product of x1 and x2, element-wise.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray multiply(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.multiply(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Returns a true division of the inputs, element-wise.
        /// 
        /// Instead of the Python traditional ‘floor division’, this returns a true
        /// division.  True division adjusts the output type to present the best
        /// answer, regardless of input types.
        /// 
        /// Notes
        /// 
        /// The floor division operator // was added in Python 2.2 making
        /// // and / equivalent operators.  The default floor division
        /// operation of / can be replaced by true division with from
        /// __future__ import division.
        /// 
        /// In Python 3.0, // is the floor division operator and / the
        /// true division operator.  The true_divide(x1, x2) function is
        /// equivalent to true division in Python.
        /// </summary>
        /// <param name="x2">
        /// Divisor array.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray divide(NDarray x2, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.divide(@this, x2, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// First array elements raised to powers from second array, element-wise.
        /// 
        /// Raise each base in x1 to the positionally-corresponding power in
        /// x2.  x1 and x2 must be broadcastable to the same shape. Note that an
        /// integer type raised to a negative integer power will raise a ValueError.
        /// </summary>
        /// <param name="x2">
        /// The exponents.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The bases in x1 raised to the exponents in x2.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray power(NDarray x2, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.power(@this, x2, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Subtract arguments, element-wise.
        /// 
        /// Notes
        /// 
        /// Equivalent to x1 - x2 in terms of array broadcasting.
        /// </summary>
        /// <param name="x1">
        /// The arrays to be subtracted from each other.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The difference of x1 and x2, element-wise.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray subtract(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.subtract(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Returns a true division of the inputs, element-wise.
        /// 
        /// Instead of the Python traditional ‘floor division’, this returns a true
        /// division.  True division adjusts the output type to present the best
        /// answer, regardless of input types.
        /// 
        /// Notes
        /// 
        /// The floor division operator // was added in Python 2.2 making
        /// // and / equivalent operators.  The default floor division
        /// operation of / can be replaced by true division with from
        /// __future__ import division.
        /// 
        /// In Python 3.0, // is the floor division operator and / the
        /// true division operator.  The true_divide(x1, x2) function is
        /// equivalent to true division in Python.
        /// </summary>
        /// <param name="x2">
        /// Divisor array.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray true_divide(NDarray x2, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.true_divide(@this, x2, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return the largest integer smaller or equal to the division of the inputs.
        /// It is equivalent to the Python // operator and pairs with the
        /// Python % (remainder), function so that b = a % b + b * (a // b)
        /// up to roundoff.
        /// </summary>
        /// <param name="x2">
        /// Denominator.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// y = floor(x1/x2)
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray floor_divide(NDarray x2, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.floor_divide(@this, x2, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// First array elements raised to powers from second array, element-wise.
        /// 
        /// Raise each base in x1 to the positionally-corresponding power in x2.
        /// x1 and x2 must be broadcastable to the same shape. This differs from
        /// the power function in that integers, float16, and float32  are promoted to
        /// floats with a minimum precision of float64 so that the result is always
        /// inexact.  The intent is that the function will return a usable result for
        /// negative powers and seldom overflow for positive powers.
        /// </summary>
        /// <param name="x2">
        /// The exponents.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The bases in x1 raised to the exponents in x2.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray float_power(NDarray x2, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.float_power(@this, x2, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return the element-wise remainder of division.
        /// 
        /// This is the NumPy implementation of the C library function fmod, the
        /// remainder has the same sign as the dividend x1. It is equivalent to
        /// the Matlab(TM) rem function and should not be confused with the
        /// Python modulus operator x1 % x2.
        /// 
        /// Notes
        /// 
        /// The result of the modulo operation for negative dividend and divisors
        /// is bound by conventions. For fmod, the sign of result is the sign of
        /// the dividend, while for remainder the sign of the result is the sign
        /// of the divisor. The fmod function is equivalent to the Matlab(TM)
        /// rem function.
        /// </summary>
        /// <param name="x2">
        /// Divisor.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The remainder of the division of x1 by x2.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray fmod(NDarray x2, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.fmod(@this, x2, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return element-wise remainder of division.
        /// 
        /// Computes the remainder complementary to the floor_divide function.  It is
        /// equivalent to the Python modulus operator``x1 % x2`` and has the same sign
        /// as the divisor x2. The MATLAB function equivalent to np.remainder
        /// is mod.
        /// 
        /// Notes
        /// 
        /// Returns 0 when x2 is 0 and both x1 and x2 are (arrays of)
        /// integers.
        /// </summary>
        /// <param name="x2">
        /// Divisor array.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The element-wise remainder of the quotient floor_divide(x1, x2).
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray mod(NDarray x2, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.mod(@this, x2, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return the fractional and integral parts of an array, element-wise.
        /// 
        /// The fractional and integral parts are negative if the given number is
        /// negative.
        /// 
        /// Notes
        /// 
        /// For integer input the return values are floats.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// y1
        /// Fractional part of x.
        /// This is a scalar if x is a scalar.
        /// y2
        /// Integral part of x.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public (NDarray, NDarray) modf(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.modf(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return element-wise remainder of division.
        /// 
        /// Computes the remainder complementary to the floor_divide function.  It is
        /// equivalent to the Python modulus operator``x1 % x2`` and has the same sign
        /// as the divisor x2. The MATLAB function equivalent to np.remainder
        /// is mod.
        /// 
        /// Notes
        /// 
        /// Returns 0 when x2 is 0 and both x1 and x2 are (arrays of)
        /// integers.
        /// </summary>
        /// <param name="x2">
        /// Divisor array.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The element-wise remainder of the quotient floor_divide(x1, x2).
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray remainder(NDarray x2, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.remainder(@this, x2, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return element-wise quotient and remainder simultaneously.
        /// 
        /// np.divmod(x, y) is equivalent to (x // y, x % y), but faster
        /// because it avoids redundant work. It is used to implement the Python
        /// built-in function divmod on NumPy arrays.
        /// </summary>
        /// <param name="x2">
        /// Divisor array.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// out1
        /// Element-wise quotient resulting from floor division.
        /// This is a scalar if both x1 and x2 are scalars.
        /// out2
        /// Element-wise remainder from floor division.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public (NDarray, NDarray) divmod(NDarray x2, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.divmod(@this, x2, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return the angle of the complex argument.
        /// </summary>
        /// <param name="deg">
        /// Return angle in degrees if True, radians if False (default).
        /// </param>
        /// <returns>
        /// The counterclockwise angle from the positive real axis on
        /// the complex plane, with dtype as numpy.float64.
        /// </returns>
        public NDarray angle(bool? deg = false)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.angle(@this, deg:deg);
        }
        
        /// <summary>
        /// Return the real part of the complex argument.
        /// </summary>
        /// <returns>
        /// The real component of the complex argument. If val is real, the type
        /// of val is used for the output.  If val has complex elements, the
        /// returned type is float.
        /// </returns>
        public NDarray real()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.real(@this);
        }
        
        /// <summary>
        /// Return the imaginary part of the complex argument.
        /// </summary>
        /// <returns>
        /// The imaginary component of the complex argument. If val is real,
        /// the type of val is used for the output.  If val has complex
        /// elements, the returned type is float.
        /// </returns>
        public NDarray imag()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.imag(@this);
        }
        
        /// <summary>
        /// Return the complex conjugate, element-wise.
        /// 
        /// The complex conjugate of a complex number is obtained by changing the
        /// sign of its imaginary part.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The complex conjugate of x, with same dtype as y.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray conj(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.conj(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Returns the discrete, linear convolution of two one-dimensional sequences.
        /// 
        /// The convolution operator is often seen in signal processing, where it
        /// models the effect of a linear time-invariant system on a signal [1].  In
        /// probability theory, the sum of two independent random variables is
        /// distributed according to the convolution of their individual
        /// distributions.
        /// 
        /// If v is longer than a, the arrays are swapped before computation.
        /// 
        /// Notes
        /// 
        /// The discrete convolution operation is defined as
        /// 
        /// It can be shown that a convolution  in time/space
        /// is equivalent to the multiplication  in the Fourier
        /// domain, after appropriate padding (padding is necessary to prevent
        /// circular convolution).  Since multiplication is more efficient (faster)
        /// than convolution, the function scipy.signal.fftconvolve exploits the
        /// FFT to calculate the convolution of large data-sets.
        /// 
        /// References
        /// </summary>
        /// <param name="v">
        /// Second one-dimensional input array.
        /// </param>
        /// <returns>
        /// Discrete, linear convolution of a and v.
        /// </returns>
        public NDarray convolve(NDarray v, string mode = "full")
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.convolve(@this, v, mode:mode);
        }
        
        /// <summary>
        /// Clip (limit) the values in an array.
        /// 
        /// Given an interval, values outside the interval are clipped to
        /// the interval edges.  For example, if an interval of [0, 1]
        /// is specified, values smaller than 0 become 0, and values larger
        /// than 1 become 1.
        /// </summary>
        /// <param name="a_min">
        /// Minimum value. If None, clipping is not performed on lower
        /// interval edge. Not more than one of a_min and a_max may be
        /// None.
        /// </param>
        /// <param name="a_max">
        /// Maximum value. If None, clipping is not performed on upper
        /// interval edge. Not more than one of a_min and a_max may be
        /// None. If a_min or a_max are array_like, then the three
        /// arrays will be broadcasted to match their shapes.
        /// </param>
        /// <param name="@out">
        /// The results will be placed in this array. It may be the input
        /// array for in-place clipping.  out must be of the right shape
        /// to hold the output.  Its type is preserved.
        /// </param>
        /// <returns>
        /// An array with the elements of a, but where values
        /// &lt; a_min are replaced with a_min, and those &gt; a_max
        /// with a_max.
        /// </returns>
        public NDarray clip(NDarray a_min, NDarray a_max, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.clip(@this, a_min, a_max, @out:@out);
        }
        
        /// <summary>
        /// Return the non-negative square-root of an array, element-wise.
        /// 
        /// Notes
        /// 
        /// sqrt has–consistent with common convention–as its branch cut the
        /// real “interval” [-inf, 0), and is continuous from above on it.
        /// A branch cut is a curve in the complex plane across which a given
        /// complex function fails to be continuous.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// An array of the same shape as x, containing the positive
        /// square-root of each element in x.  If any element in x is
        /// complex, a complex array is returned (and the square-roots of
        /// negative reals are calculated).  If all of the elements in x
        /// are real, so is y, with negative elements returning nan.
        /// If out was provided, y is a reference to it.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray sqrt(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.sqrt(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return the cube-root of an array, element-wise.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// An array of the same shape as x, containing the cube
        /// cube-root of each element in x.
        /// If out was provided, y is a reference to it.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray cbrt(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.cbrt(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return the element-wise square of the input.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Element-wise x*x, of the same shape and dtype as x.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray square(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.square(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Calculate the absolute value element-wise.
        /// 
        /// np.abs is a shorthand for this function.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// An ndarray containing the absolute value of
        /// each element in x.  For complex input, a + ib, the
        /// absolute value is .
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray absolute(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.absolute(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Compute the absolute values element-wise.
        /// 
        /// This function returns the absolute values (positive magnitude) of the
        /// data in x. Complex values are not handled, use absolute to find the
        /// absolute values of complex data.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The absolute values of x, the returned values are always floats.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray fabs(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.fabs(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Returns an element-wise indication of the sign of a number.
        /// 
        /// The sign function returns -1 if x &lt; 0, 0 if x==0, 1 if x &gt; 0.  nan
        /// is returned for nan inputs.
        /// 
        /// For complex inputs, the sign function returns
        /// sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j.
        /// 
        /// complex(nan, 0) is returned for complex nan inputs.
        /// 
        /// Notes
        /// 
        /// There is more than one definition of sign in common use for complex
        /// numbers.  The definition used here is equivalent to 
        /// which is different from a common alternative, .
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The sign of x.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray sign(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.sign(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Compute the Heaviside step function.
        /// 
        /// The Heaviside step function is defined as:
        /// 
        /// where x2 is often taken to be 0.5, but 0 and 1 are also sometimes used.
        /// 
        /// Notes
        /// 
        /// References
        /// </summary>
        /// <param name="x2">
        /// The value of the function when x1 is 0.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The output array, element-wise Heaviside step function of x1.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray heaviside(NDarray x2, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.heaviside(@this, x2, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Element-wise maximum of array elements.
        /// 
        /// Compare two arrays and returns a new array containing the element-wise
        /// maxima. If one of the elements being compared is a NaN, then that
        /// element is returned. If both elements are NaNs then the first is
        /// returned. The latter distinction is important for complex NaNs, which
        /// are defined as at least one of the real or imaginary parts being a NaN.
        /// The net effect is that NaNs are propagated.
        /// 
        /// Notes
        /// 
        /// The maximum is equivalent to np.where(x1 &gt;= x2, x1, x2) when
        /// neither x1 nor x2 are nans, but it is faster and does proper
        /// broadcasting.
        /// </summary>
        /// <param name="x1">
        /// The arrays holding the elements to be compared. They must have
        /// the same shape, or shapes that can be broadcast to a single shape.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The maximum of x1 and x2, element-wise.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray maximum(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.maximum(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Element-wise minimum of array elements.
        /// 
        /// Compare two arrays and returns a new array containing the element-wise
        /// minima. If one of the elements being compared is a NaN, then that
        /// element is returned. If both elements are NaNs then the first is
        /// returned. The latter distinction is important for complex NaNs, which
        /// are defined as at least one of the real or imaginary parts being a NaN.
        /// The net effect is that NaNs are propagated.
        /// 
        /// Notes
        /// 
        /// The minimum is equivalent to np.where(x1 &lt;= x2, x1, x2) when
        /// neither x1 nor x2 are NaNs, but it is faster and does proper
        /// broadcasting.
        /// </summary>
        /// <param name="x1">
        /// The arrays holding the elements to be compared. They must have
        /// the same shape, or shapes that can be broadcast to a single shape.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The minimum of x1 and x2, element-wise.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray minimum(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.minimum(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Element-wise maximum of array elements.
        /// 
        /// Compare two arrays and returns a new array containing the element-wise
        /// maxima. If one of the elements being compared is a NaN, then the
        /// non-nan element is returned. If both elements are NaNs then the first
        /// is returned.  The latter distinction is important for complex NaNs,
        /// which are defined as at least one of the real or imaginary parts being
        /// a NaN. The net effect is that NaNs are ignored when possible.
        /// 
        /// Notes
        /// 
        /// The fmax is equivalent to np.where(x1 &gt;= x2, x1, x2) when neither
        /// x1 nor x2 are NaNs, but it is faster and does proper broadcasting.
        /// </summary>
        /// <param name="x1">
        /// The arrays holding the elements to be compared. They must have
        /// the same shape.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The maximum of x1 and x2, element-wise.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray fmax(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.fmax(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Element-wise minimum of array elements.
        /// 
        /// Compare two arrays and returns a new array containing the element-wise
        /// minima. If one of the elements being compared is a NaN, then the
        /// non-nan element is returned. If both elements are NaNs then the first
        /// is returned.  The latter distinction is important for complex NaNs,
        /// which are defined as at least one of the real or imaginary parts being
        /// a NaN. The net effect is that NaNs are ignored when possible.
        /// 
        /// Notes
        /// 
        /// The fmin is equivalent to np.where(x1 &lt;= x2, x1, x2) when neither
        /// x1 nor x2 are NaNs, but it is faster and does proper broadcasting.
        /// </summary>
        /// <param name="x1">
        /// The arrays holding the elements to be compared. They must have
        /// the same shape.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// The minimum of x1 and x2, element-wise.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray fmin(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.fmin(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Replace NaN with zero and infinity with large finite numbers.
        /// 
        /// If x is inexact, NaN is replaced by zero, and infinity and -infinity
        /// replaced by the respectively largest and most negative finite floating
        /// point values representable by x.dtype.
        /// 
        /// For complex dtypes, the above is applied to each of the real and
        /// imaginary components of x separately.
        /// 
        /// If x is not inexact, then no replacements are made.
        /// 
        /// Notes
        /// 
        /// NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
        /// (IEEE 754). This means that Not a Number is not equivalent to infinity.
        /// </summary>
        /// <param name="copy">
        /// Whether to create a copy of x (True) or to replace values
        /// in-place (False). The in-place operation only occurs if
        /// casting to an array does not require a copy.
        /// Default is True.
        /// </param>
        /// <returns>
        /// x, with the non-finite values replaced. If copy is False, this may
        /// be x itself.
        /// </returns>
        public NDarray nan_to_num(bool? copy = true)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nan_to_num(@this, copy:copy);
        }
        
        /// <summary>
        /// If complex input returns a real array if complex parts are close to zero.
        /// 
        /// “Close to zero” is defined as tol * (machine epsilon of the type for
        /// a).
        /// 
        /// Notes
        /// 
        /// Machine epsilon varies from machine to machine and between data types
        /// but Python floats on most platforms have a machine epsilon equal to
        /// 2.2204460492503131e-16.  You can use ‘np.finfo(float).eps’ to print
        /// out the machine epsilon for floats.
        /// </summary>
        /// <param name="tol">
        /// Tolerance in machine epsilons for the complex part of the elements
        /// in the array.
        /// </param>
        /// <returns>
        /// If a is real, the type of a is used for the output.  If a
        /// has complex elements, the returned type is float.
        /// </returns>
        public NDarray real_if_close(float tol = 100)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.real_if_close(@this, tol);
        }
        
        /*
        /// <summary>
        /// One-dimensional linear interpolation.
        /// 
        /// Returns the one-dimensional piecewise linear interpolant to a function
        /// with given discrete data points (xp, fp), evaluated at x.
        /// 
        /// Notes
        /// 
        /// Does not check that the x-coordinate sequence xp is increasing.
        /// If xp is not increasing, the results are nonsense.
        /// A simple check for increasing is:
        /// </summary>
        /// <param name="xp">
        /// The x-coordinates of the data points, must be increasing if argument
        /// period is not specified. Otherwise, xp is internally sorted after
        /// normalizing the periodic boundaries with xp = xp % period.
        /// </param>
        /// <param name="fp">
        /// The y-coordinates of the data points, same length as xp.
        /// </param>
        /// <param name="left">
        /// Value to return for x &lt; xp[0], default is fp[0].
        /// </param>
        /// <param name="right">
        /// Value to return for x &gt; xp[-1], default is fp[-1].
        /// </param>
        /// <param name="period">
        /// A period for the x-coordinates. This parameter allows the proper
        /// interpolation of angular x-coordinates. Parameters left and right
        /// are ignored if period is specified.
        /// </param>
        /// <returns>
        /// The interpolated values, same shape as x.
        /// </returns>
        public float or complex (corresponding to fp) or ndarray interp(1-D sequence of floats xp, 1-D sequence of float or complex fp, optional float or complex corresponding to fp left = null, optional float or complex corresponding to fp right = null, None or float period = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.interp(@this, xp, fp, left:left, right:right, period:period);
        }
        */
        
        /// <summary>
        /// Dot product of two arrays. Specifically,
        /// </summary>
        /// <param name="b">
        /// Second argument.
        /// </param>
        /// <param name="@out">
        /// Output argument. This must have the exact kind that would be returned
        /// if it was not used. In particular, it must have the right type, must be
        /// C-contiguous, and its dtype must be the dtype that would be returned
        /// for dot(a,b). This is a performance feature. Therefore, if these
        /// conditions are not met, an exception is raised, instead of attempting
        /// to be flexible.
        /// </param>
        /// <returns>
        /// Returns the dot product of a and b.  If a and b are both
        /// scalars or both 1-D arrays then a scalar is returned; otherwise
        /// an array is returned.
        /// If out is given, then it is returned.
        /// </returns>
        public NDarray dot(NDarray b, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.dot(@this, b, @out:@out);
        }
        
        /// <summary>
        /// Return the dot product of two vectors.
        /// 
        /// The vdot(a, b) function handles complex numbers differently than
        /// dot(a, b).  If the first argument is complex the complex conjugate
        /// of the first argument is used for the calculation of the dot product.
        /// 
        /// Note that vdot handles multidimensional arrays differently than dot:
        /// it does not perform a matrix product, but flattens input arguments
        /// to 1-D vectors first. Consequently, it should only be used for vectors.
        /// </summary>
        /// <param name="b">
        /// Second argument to the dot product.
        /// </param>
        /// <returns>
        /// Dot product of a and b.  Can be an int, float, or
        /// complex depending on the types of a and b.
        /// </returns>
        public NDarray vdot(NDarray b)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.vdot(@this, b);
        }
        
        /// <summary>
        /// Inner product of two arrays.
        /// 
        /// Ordinary inner product of vectors for 1-D arrays (without complex
        /// conjugation), in higher dimensions a sum product over the last axes.
        /// 
        /// Notes
        /// 
        /// For vectors (1-D arrays) it computes the ordinary inner-product:
        /// 
        /// More generally, if ndim(a) = r &gt; 0 and ndim(b) = s &gt; 0:
        /// 
        /// or explicitly:
        /// 
        /// In addition a or b may be scalars, in which case:
        /// </summary>
        /// <param name="a">
        /// If a and b are nonscalar, their last dimensions must match.
        /// </param>
        /// <returns>
        /// out.shape = a.shape[:-1] + b.shape[:-1]
        /// </returns>
        public NDarray inner(NDarray a)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.inner(@this, a);
        }
        
        /// <summary>
        /// Compute the outer product of two vectors.
        /// 
        /// Given two vectors, a = [a0, a1, ..., aM] and
        /// b = [b0, b1, ..., bN],
        /// the outer product [1] is:
        /// 
        /// References
        /// </summary>
        /// <param name="b">
        /// Second input vector.  Input is flattened if
        /// not already 1-dimensional.
        /// </param>
        /// <param name="@out">
        /// A location where the result is stored
        /// </param>
        /// <returns>
        /// out[i, j] = a[i] * b[j]
        /// </returns>
        public NDarray outer(NDarray b, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.outer(@this, b, @out:@out);
        }
        
        /// <summary>
        /// Matrix product of two arrays.
        /// 
        /// Notes
        /// 
        /// The behavior depends on the arguments in the following way.
        /// 
        /// matmul differs from dot in two important ways:
        /// 
        /// The matmul function implements the semantics of the &#64; operator introduced
        /// in Python 3.5 following PEP465.
        /// </summary>
        /// <param name="x1">
        /// Input arrays, scalars not allowed.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that matches the signature (n,k),(k,m)-&gt;(n,m). If not
        /// provided or None, a freshly-allocated array is returned.
        /// </param>
        /// <returns>
        /// The matrix product of the inputs.
        /// This is a scalar only when both x1, x2 are 1-d vectors.
        /// </returns>
        public NDarray matmul(NDarray x1, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.matmul(@this, x1, @out:@out);
        }
        
        /// <summary>
        /// Compute tensor dot product along specified axes for arrays &gt;= 1-D.
        /// 
        /// Given two tensors (arrays of dimension greater than or equal to one),
        /// a and b, and an array_like object containing two array_like
        /// objects, (a_axes, b_axes), sum the products of a’s and b’s
        /// elements (components) over the axes specified by a_axes and
        /// b_axes. The third argument can be a single non-negative
        /// integer_like scalar, N; if it is such, then the last N
        /// dimensions of a and the first N dimensions of b are summed
        /// over.
        /// 
        /// Notes
        /// 
        /// When axes is integer_like, the sequence for evaluation will be: first
        /// the -Nth axis in a and 0th axis in b, and the -1th axis in a and
        /// Nth axis in b last.
        /// 
        /// When there is more than one axis to sum over - and they are not the last
        /// (first) axes of a (b) - the argument axes should consist of
        /// two sequences of the same length, with the first axis to sum over given
        /// first in both sequences, the second axis second, and so forth.
        /// </summary>
        /// <param name="a">
        /// Tensors to “dot”.
        /// </param>
        public NDarray tensordot(NDarray a, int[] axes = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.tensordot(@this, a, axes);
        }
        
        /// <summary>
        /// Raise a square matrix to the (integer) power n.
        /// 
        /// For positive integers n, the power is computed by repeated matrix
        /// squarings and matrix multiplications. If n == 0, the identity matrix
        /// of the same shape as M is returned. If n &lt; 0, the inverse
        /// is computed and then raised to the abs(n).
        /// </summary>
        /// <param name="n">
        /// The exponent can be any integer or long integer, positive,
        /// negative, or zero.
        /// </param>
        /// <returns>
        /// The return value is the same shape and type as M;
        /// if the exponent is positive or zero then the type of the
        /// elements is the same as those of M. If the exponent is
        /// negative the elements are floating-point.
        /// </returns>
        public NDarray matrix_power(int n)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.matrix_power(@this, n);
        }
        
        /// <summary>
        /// Kronecker product of two arrays.
        /// 
        /// Computes the Kronecker product, a composite array made of blocks of the
        /// second array scaled by the first.
        /// 
        /// Notes
        /// 
        /// The function assumes that the number of dimensions of a and b
        /// are the same, if necessary prepending the smallest with ones.
        /// If a.shape = (r0,r1,..,rN) and b.shape = (s0,s1,…,sN),
        /// the Kronecker product has shape (r0*s0, r1*s1, …, rN*SN).
        /// The elements are products of elements from a and b, organized
        /// explicitly by:
        /// 
        /// where:
        /// 
        /// In the common 2-D case (N=1), the block structure can be visualized:
        /// </summary>
        public NDarray kron(NDarray a)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.kron(@this, a);
        }
        
        /// <summary>
        /// Compute the qr factorization of a matrix.
        /// 
        /// Factor the matrix a as qr, where q is orthonormal and r is
        /// upper-triangular.
        /// 
        /// Notes
        /// 
        /// This is an interface to the LAPACK routines dgeqrf, zgeqrf,
        /// dorgqr, and zungqr.
        /// 
        /// For more information on the qr factorization, see for example:
        /// https://en.wikipedia.org/wiki/QR_factorization
        /// 
        /// Subclasses of ndarray are preserved except for the ‘raw’ mode. So if
        /// a is of type matrix, all the return values will be matrices too.
        /// 
        /// New ‘reduced’, ‘complete’, and ‘raw’ options for mode were added in
        /// NumPy 1.8.0 and the old option ‘full’ was made an alias of ‘reduced’.  In
        /// addition the options ‘full’ and ‘economic’ were deprecated.  Because
        /// ‘full’ was the previous default and ‘reduced’ is the new default,
        /// backward compatibility can be maintained by letting mode default.
        /// The ‘raw’ option was added so that LAPACK routines that can multiply
        /// arrays by q using the Householder reflectors can be used. Note that in
        /// this case the returned arrays are of type np.double or np.cdouble and
        /// the h array is transposed to be FORTRAN compatible.  No routines using
        /// the ‘raw’ return are currently exposed by numpy, but some are available
        /// in lapack_lite and just await the necessary work.
        /// </summary>
        /// <param name="mode">
        /// If K = min(M, N), then
        /// 
        /// The options ‘reduced’, ‘complete, and ‘raw’ are new in numpy 1.8,
        /// see the notes for more information. The default is ‘reduced’, and to
        /// maintain backward compatibility with earlier versions of numpy both
        /// it and the old default ‘full’ can be omitted. Note that array h
        /// returned in ‘raw’ mode is transposed for calling Fortran. The
        /// ‘economic’ mode is deprecated.  The modes ‘full’ and ‘economic’ may
        /// be passed using only the first letter for backwards compatibility,
        /// but all others must be spelled out. See the Notes for more
        /// explanation.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// q
        /// A matrix with orthonormal columns. When mode = ‘complete’ the
        /// result is an orthogonal/unitary matrix depending on whether or not
        /// a is real/complex. The determinant may be either +/- 1 in that
        /// case.
        /// r
        /// The upper-triangular matrix.
        /// (h, tau)
        /// The array h contains the Householder reflectors that generate q
        /// along with r. The tau array contains scaling factors for the
        /// reflectors. In the deprecated  ‘economic’ mode only h is returned.
        /// </returns>
        public (NDarray, NDarray, NDarray) qr(string mode = "reduced")
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.qr(@this, mode:mode);
        }
        
        /*
        /// <summary>
        /// Compute the condition number of a matrix.
        /// 
        /// This function is capable of returning the condition number using
        /// one of seven different norms, depending on the value of p (see
        /// Parameters below).
        /// 
        /// Notes
        /// 
        /// The condition number of x is defined as the norm of x times the
        /// norm of the inverse of x [1]; the norm can be the usual L2-norm
        /// (root-of-sum-of-squares) or one of a number of other matrix norms.
        /// 
        /// References
        /// </summary>
        /// <param name="p">
        /// Order of the norm:
        /// 
        /// inf means the numpy.inf object, and the Frobenius norm is
        /// the root-of-sum-of-squares norm.
        /// </param>
        /// <returns>
        /// The condition number of the matrix. May be infinite.
        /// </returns>
        public {float cond({None p = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.cond(@this, p:p);
        }
        */
        
        /// <summary>
        /// Return matrix rank of array using SVD method
        /// 
        /// Rank of the array is the number of singular values of the array that are
        /// greater than tol.
        /// 
        /// Notes
        /// 
        /// The default threshold to detect rank deficiency is a test on the magnitude
        /// of the singular values of M.  By default, we identify singular values less
        /// than S.max() * max(M.shape) * eps as indicating rank deficiency (with
        /// the symbols defined above). This is the algorithm MATLAB uses [1].  It also
        /// appears in Numerical recipes in the discussion of SVD solutions for linear
        /// least squares [2].
        /// 
        /// This default threshold is designed to detect rank deficiency accounting for
        /// the numerical errors of the SVD computation.  Imagine that there is a column
        /// in M that is an exact (in floating point) linear combination of other
        /// columns in M. Computing the SVD on M will not produce a singular value
        /// exactly equal to 0 in general: any difference of the smallest SVD value from
        /// 0 will be caused by numerical imprecision in the calculation of the SVD.
        /// Our threshold for small SVD values takes this numerical imprecision into
        /// account, and the default threshold will detect such numerical rank
        /// deficiency.  The threshold may declare a matrix M rank deficient even if
        /// the linear combination of some columns of M is not exactly equal to
        /// another column of M but only numerically very close to another column of
        /// M.
        /// 
        /// We chose our default threshold because it is in wide use.  Other thresholds
        /// are possible.  For example, elsewhere in the 2007 edition of Numerical
        /// recipes there is an alternative threshold of S.max() *
        /// np.finfo(M.dtype).eps / 2. * np.sqrt(m + n + 1.). The authors describe
        /// this threshold as being based on “expected roundoff error” (p 71).
        /// 
        /// The thresholds above deal with floating point roundoff error in the
        /// calculation of the SVD.  However, you may have more information about the
        /// sources of error in M that would make you consider other tolerance values
        /// to detect effective rank deficiency.  The most useful measure of the
        /// tolerance depends on the operations you intend to use on your matrix.  For
        /// example, if your data come from uncertain measurements with uncertainties
        /// greater than floating point epsilon, choosing a tolerance near that
        /// uncertainty may be preferable.  The tolerance may be absolute if the
        /// uncertainties are absolute rather than relative.
        /// 
        /// References
        /// </summary>
        /// <param name="tol">
        /// threshold below which SVD values are considered zero. If tol is
        /// None, and S is an array with singular values for M, and
        /// eps is the epsilon value for datatype of S, then tol is
        /// set to S.max() * max(M.shape) * eps.
        /// </param>
        /// <param name="hermitian">
        /// If True, M is assumed to be Hermitian (symmetric if real-valued),
        /// enabling a more efficient method for finding singular values.
        /// Defaults to False.
        /// </param>
        public int matrix_rank(NDarray tol = null, bool? hermitian = false)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.matrix_rank(@this, tol:tol, hermitian:hermitian);
        }
        
        /// <summary>
        /// Compute the sign and (natural) logarithm of the determinant of an array.
        /// 
        /// If an array has a very small or very large determinant, then a call to
        /// det may overflow or underflow. This routine is more robust against such
        /// issues, because it computes the logarithm of the determinant rather than
        /// the determinant itself.
        /// 
        /// Notes
        /// 
        /// Broadcasting rules apply, see the numpy.linalg documentation for
        /// details.
        /// 
        /// The determinant is computed via LU factorization using the LAPACK
        /// routine z/dgetrf.
        /// </summary>
        /// <returns>
        /// A tuple of:
        /// sign
        /// A number representing the sign of the determinant. For a real matrix,
        /// this is 1, 0, or -1. For a complex matrix, this is a complex number
        /// with absolute value 1 (i.e., it is on the unit circle), or else 0.
        /// logdet
        /// The natural log of the absolute value of the determinant.
        /// </returns>
        public (NDarray, NDarray) slogdet()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.slogdet(@this);
        }
        
        /// <summary>
        /// Return the sum along diagonals of the array.
        /// 
        /// If a is 2-D, the sum along its diagonal with the given offset
        /// is returned, i.e., the sum of elements a[i,i+offset] for all i.
        /// 
        /// If a has more than two dimensions, then the axes specified by axis1 and
        /// axis2 are used to determine the 2-D sub-arrays whose traces are returned.
        /// The shape of the resulting array is the same as that of a with axis1
        /// and axis2 removed.
        /// </summary>
        /// <param name="offset">
        /// Offset of the diagonal from the main diagonal. Can be both positive
        /// and negative. Defaults to 0.
        /// </param>
        /// <param name="axis2">
        /// Axes to be used as the first and second axis of the 2-D sub-arrays
        /// from which the diagonals should be taken. Defaults are the first two
        /// axes of a.
        /// </param>
        /// <param name="axis1">
        /// Axes to be used as the first and second axis of the 2-D sub-arrays
        /// from which the diagonals should be taken. Defaults are the first two
        /// axes of a.
        /// </param>
        /// <param name="dtype">
        /// Determines the data-type of the returned array and of the accumulator
        /// where the elements are summed. If dtype has the value None and a is
        /// of integer type of precision less than the default integer
        /// precision, then the default integer precision is used. Otherwise,
        /// the precision is the same as that of a.
        /// </param>
        /// <param name="@out">
        /// Array into which the output is placed. Its type is preserved and
        /// it must be of the right shape to hold the output.
        /// </param>
        /// <returns>
        /// If a is 2-D, the sum along the diagonal is returned.  If a has
        /// larger dimensions, then an array of sums along diagonals is returned.
        /// </returns>
        public NDarray trace(int? offset = 0, int? axis2 = null, int? axis1 = null, Dtype dtype = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.trace(@this, offset:offset, axis2:axis2, axis1:axis1, dtype:dtype, @out:@out);
        }
        
        /// <summary>
        /// Solve the tensor equation a x = b for x.
        /// 
        /// It is assumed that all indices of x are summed over in the product,
        /// together with the rightmost indices of a, as is done in, for example,
        /// tensordot(a, x, axes=b.ndim).
        /// </summary>
        /// <param name="b">
        /// Right-hand tensor, which can be of any shape.
        /// </param>
        /// <param name="axes">
        /// Axes in a to reorder to the right, before inversion.
        /// If None (default), no reordering is done.
        /// </param>
        public NDarray tensorsolve(NDarray b, int[] axes = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.tensorsolve(@this, b, axes:axes);
        }
        
        /// <summary>
        /// Compute the ‘inverse’ of an N-dimensional array.
        /// 
        /// The result is an inverse for a relative to the tensordot operation
        /// tensordot(a, b, ind), i. e., up to floating-point accuracy,
        /// tensordot(tensorinv(a), a, ind) is the “identity” tensor for the
        /// tensordot operation.
        /// </summary>
        /// <param name="ind">
        /// Number of first indices that are involved in the inverse sum.
        /// Must be a positive integer, default is 2.
        /// </param>
        /// <returns>
        /// a’s tensordot inverse, shape a.shape[ind:] + a.shape[:ind].
        /// </returns>
        public NDarray tensorinv(int? ind = 2)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.tensorinv(@this, ind:ind);
        }
        
        /// <summary>
        /// Test whether all array elements along a given axis evaluate to True.
        /// 
        /// Notes
        /// 
        /// Not a Number (NaN), positive infinity and negative infinity
        /// evaluate to True because these are not equal to zero.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which a logical AND reduction is performed.
        /// The default (axis = None) is to perform a logical AND over all
        /// the dimensions of the input array. axis may be negative, in
        /// which case it counts from the last to the first axis.
        /// 
        /// If this is a tuple of ints, a reduction is performed on multiple
        /// axes, instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.
        /// It must have the same shape as the expected output and its
        /// type is preserved (e.g., if dtype(out) is float, the result
        /// will consist of 0.0’s and 1.0’s).  See doc.ufuncs (Section
        /// “Output arguments”) for more details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the all method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <returns>
        /// A new boolean or array is returned unless out is specified,
        /// in which case a reference to out is returned.
        /// </returns>
        public NDarray<bool> all(int[] axis, NDarray @out = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.all(@this, axis:axis, @out:@out, keepdims:keepdims);
        }
        
        /// <summary>
        /// Test whether all array elements along a given axis evaluate to True.
        /// 
        /// Notes
        /// 
        /// Not a Number (NaN), positive infinity and negative infinity
        /// evaluate to True because these are not equal to zero.
        /// </summary>
        /// <returns>
        /// A new boolean or array is returned unless out is specified,
        /// in which case a reference to out is returned.
        /// </returns>
        public bool all()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.all(@this);
        }
        
        /// <summary>
        /// Test whether any array element along a given axis evaluates to True.
        /// 
        /// Returns single boolean unless axis is not None
        /// 
        /// Notes
        /// 
        /// Not a Number (NaN), positive infinity and negative infinity evaluate
        /// to True because these are not equal to zero.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which a logical OR reduction is performed.
        /// The default (axis = None) is to perform a logical OR over all
        /// the dimensions of the input array. axis may be negative, in
        /// which case it counts from the last to the first axis.
        /// 
        /// If this is a tuple of ints, a reduction is performed on multiple
        /// axes, instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  It must have
        /// the same shape as the expected output and its type is preserved
        /// (e.g., if it is of type float, then it will remain so, returning
        /// 1.0 for True and 0.0 for False, regardless of the type of a).
        /// See doc.ufuncs (Section “Output arguments”) for details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the any method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <returns>
        /// A new boolean or ndarray is returned unless out is specified,
        /// in which case a reference to out is returned.
        /// </returns>
        public NDarray<bool> any(int[] axis, NDarray @out = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.any(@this, axis:axis, @out:@out, keepdims:keepdims);
        }
        
        /// <summary>
        /// Test whether any array element along a given axis evaluates to True.
        /// 
        /// Returns single boolean unless axis is not None
        /// 
        /// Notes
        /// 
        /// Not a Number (NaN), positive infinity and negative infinity evaluate
        /// to True because these are not equal to zero.
        /// </summary>
        /// <returns>
        /// A new boolean or ndarray is returned unless out is specified,
        /// in which case a reference to out is returned.
        /// </returns>
        public bool any()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.any(@this);
        }
        
        /// <summary>
        /// Test element-wise for finiteness (not infinity or not Not a Number).
        /// 
        /// The result is returned as a boolean array.
        /// 
        /// Notes
        /// 
        /// Not a Number, positive infinity and negative infinity are considered
        /// to be non-finite.
        /// 
        /// NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
        /// (IEEE 754). This means that Not a Number is not equivalent to infinity.
        /// Also that positive infinity is not equivalent to negative infinity. But
        /// infinity is equivalent to positive infinity.  Errors result if the
        /// second argument is also supplied when x is a scalar input, or if
        /// first and second arguments have different shapes.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// True where x is not positive infinity, negative infinity,
        /// or NaN; false otherwise.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray isfinite(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.isfinite(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Test element-wise for positive or negative infinity.
        /// 
        /// Returns a boolean array of the same shape as x, True where x ==
        /// +/-inf, otherwise False.
        /// 
        /// Notes
        /// 
        /// NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
        /// (IEEE 754).
        /// 
        /// Errors result if the second argument is supplied when the first
        /// argument is a scalar, or if the first and second arguments have
        /// different shapes.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// True where x is positive or negative infinity, false otherwise.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray<bool> isinf(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.isinf(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Test element-wise for NaN and return result as a boolean array.
        /// 
        /// Notes
        /// 
        /// NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
        /// (IEEE 754). This means that Not a Number is not equivalent to infinity.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// True where x is NaN, false otherwise.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray isnan(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.isnan(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Test element-wise for NaT (not a time) and return result as a boolean array.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// True where x is NaT, false otherwise.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray isnat(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.isnat(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Test element-wise for negative infinity, return result as bool array.
        /// 
        /// Notes
        /// 
        /// NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
        /// (IEEE 754).
        /// 
        /// Errors result if the second argument is also supplied when x is a scalar
        /// input, if first and second arguments have different shapes, or if the
        /// first argument has complex values.
        /// </summary>
        /// <param name="@out">
        /// A boolean array with the same shape and type as x to store the
        /// result.
        /// </param>
        /// <returns>
        /// A boolean array with the same dimensions as the input.
        /// If second argument is not supplied then a numpy boolean array is
        /// returned with values True where the corresponding element of the
        /// input is negative infinity and values False where the element of
        /// the input is not negative infinity.
        /// 
        /// If a second argument is supplied the result is stored there. If the
        /// type of that array is a numeric type the result is represented as
        /// zeros and ones, if the type is boolean then as False and True. The
        /// return value out is then a reference to that array.
        /// </returns>
        public NDarray isneginf(NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.isneginf(@this, @out:@out);
        }
        
        /// <summary>
        /// Test element-wise for positive infinity, return result as bool array.
        /// 
        /// Notes
        /// 
        /// NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
        /// (IEEE 754).
        /// 
        /// Errors result if the second argument is also supplied when x is a scalar
        /// input, if first and second arguments have different shapes, or if the
        /// first argument has complex values
        /// </summary>
        /// <param name="y">
        /// A boolean array with the same shape as x to store the result.
        /// </param>
        /// <returns>
        /// A boolean array with the same dimensions as the input.
        /// If second argument is not supplied then a boolean array is returned
        /// with values True where the corresponding element of the input is
        /// positive infinity and values False where the element of the input is
        /// not positive infinity.
        /// 
        /// If a second argument is supplied the result is stored there. If the
        /// type of that array is a numeric type the result is represented as zeros
        /// and ones, if the type is boolean then as False and True.
        /// The return value out is then a reference to that array.
        /// </returns>
        public NDarray isposinf(NDarray y = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.isposinf(@this, y:y);
        }
        
        /// <summary>
        /// Returns a bool array, where True if input element is complex.
        /// 
        /// What is tested is whether the input has a non-zero imaginary part, not if
        /// the input type is complex.
        /// </summary>
        /// <returns>
        /// Output array.
        /// </returns>
        public NDarray iscomplex()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.iscomplex(@this);
        }
        
        /// <summary>
        /// Returns True if the array is Fortran contiguous but not C contiguous.
        /// 
        /// This function is obsolete and, because of changes due to relaxed stride
        /// checking, its return value for the same array may differ for versions
        /// of NumPy &gt;= 1.10.0 and previous versions. If you only want to check if an
        /// array is Fortran contiguous use a.flags.f_contiguous instead.
        /// </summary>
        public bool isfortran()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.isfortran(@this);
        }
        
        /// <summary>
        /// Returns a bool array, where True if input element is real.
        /// 
        /// If element has complex type with zero complex part, the return value
        /// for that element is True.
        /// </summary>
        /// <returns>
        /// Boolean array of same shape as x.
        /// </returns>
        public NDarray isreal()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.isreal(@this);
        }
        
        /// <summary>
        /// Compute the truth value of x1 AND x2 element-wise.
        /// </summary>
        /// <param name="x1">
        /// Input arrays. x1 and x2 must be of the same shape.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Boolean result with the same shape as x1 and x2 of the logical
        /// AND operation on corresponding elements of x1 and x2.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray logical_and(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.logical_and(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Compute the truth value of x1 OR x2 element-wise.
        /// </summary>
        /// <param name="x1">
        /// Logical OR is applied to the elements of x1 and x2.
        /// They have to be of the same shape.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Boolean result with the same shape as x1 and x2 of the logical
        /// OR operation on elements of x1 and x2.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray logical_or(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.logical_or(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Compute the truth value of NOT x element-wise.
        /// </summary>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Boolean result with the same shape as x of the NOT operation
        /// on elements of x.
        /// This is a scalar if x is a scalar.
        /// </returns>
        public NDarray<bool> logical_not(NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.logical_not(@this, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Compute the truth value of x1 XOR x2, element-wise.
        /// </summary>
        /// <param name="x1">
        /// Logical XOR is applied to the elements of x1 and x2.  They must
        /// be broadcastable to the same shape.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Boolean result of the logical XOR operation applied to the elements
        /// of x1 and x2; the shape is determined by whether or not
        /// broadcasting of one or both arrays was required.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray<bool> logical_xor(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.logical_xor(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Returns True if two arrays are element-wise equal within a tolerance.
        /// 
        /// The tolerance values are positive, typically very small numbers.  The
        /// relative difference (rtol * abs(b)) and the absolute difference
        /// atol are added together to compare against the absolute difference
        /// between a and b.
        /// 
        /// If either array contains one or more NaNs, False is returned.
        /// Infs are treated as equal if they are in the same place and of the same
        /// sign in both arrays.
        /// 
        /// Notes
        /// 
        /// If the following equation is element-wise True, then allclose returns
        /// True.
        /// 
        /// The above equation is not symmetric in a and b, so that
        /// allclose(a, b) might be different from allclose(b, a) in
        /// some rare cases.
        /// 
        /// The comparison of a and b uses standard broadcasting, which
        /// means that a and b need not have the same shape in order for
        /// allclose(a, b) to evaluate to True.  The same is true for
        /// equal but not array_equal.
        /// </summary>
        /// <param name="a">
        /// Input arrays to compare.
        /// </param>
        /// <param name="rtol">
        /// The relative tolerance parameter (see Notes).
        /// </param>
        /// <param name="atol">
        /// The absolute tolerance parameter (see Notes).
        /// </param>
        /// <param name="equal_nan">
        /// Whether to compare NaN’s as equal.  If True, NaN’s in a will be
        /// considered equal to NaN’s in b in the output array.
        /// </param>
        /// <returns>
        /// Returns True if the two arrays are equal within the given
        /// tolerance; False otherwise.
        /// </returns>
        public bool allclose(NDarray a, float rtol = 1e-05f, float atol = 1e-08f, bool equal_nan = false)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.allclose(@this, a, rtol, atol, equal_nan);
        }
        
        /// <summary>
        /// Returns a boolean array where two arrays are element-wise equal within a
        /// tolerance.
        /// 
        /// The tolerance values are positive, typically very small numbers.  The
        /// relative difference (rtol * abs(b)) and the absolute difference
        /// atol are added together to compare against the absolute difference
        /// between a and b.
        /// 
        /// Notes
        /// 
        /// For finite values, isclose uses the following equation to test whether
        /// two floating point values are equivalent.
        /// 
        /// Unlike the built-in math.isclose, the above equation is not symmetric
        /// in a and b – it assumes b is the reference value – so that
        /// isclose(a, b) might be different from isclose(b, a). Furthermore,
        /// the default value of atol is not zero, and is used to determine what
        /// small values should be considered close to zero. The default value is
        /// appropriate for expected values of order unity: if the expected values
        /// are significantly smaller than one, it can result in false positives.
        /// atol should be carefully selected for the use case at hand. A zero value
        /// for atol will result in False if either a or b is zero.
        /// </summary>
        /// <param name="a">
        /// Input arrays to compare.
        /// </param>
        /// <param name="rtol">
        /// The relative tolerance parameter (see Notes).
        /// </param>
        /// <param name="atol">
        /// The absolute tolerance parameter (see Notes).
        /// </param>
        /// <param name="equal_nan">
        /// Whether to compare NaN’s as equal.  If True, NaN’s in a will be
        /// considered equal to NaN’s in b in the output array.
        /// </param>
        /// <returns>
        /// Returns a boolean array of where a and b are equal within the
        /// given tolerance. If both a and b are scalars, returns a single
        /// boolean value.
        /// </returns>
        public NDarray isclose(NDarray a, float rtol = 1e-05f, float atol = 1e-08f, bool equal_nan = false)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.isclose(@this, a, rtol, atol, equal_nan);
        }
        
        /// <summary>
        /// True if two arrays have the same shape and elements, False otherwise.
        /// </summary>
        /// <param name="a1">
        /// Input arrays.
        /// </param>
        /// <returns>
        /// Returns True if the arrays are equal.
        /// </returns>
        public bool array_equal(NDarray a1)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.array_equal(@this, a1);
        }
        
        /// <summary>
        /// Returns True if input arrays are shape consistent and all elements equal.
        /// 
        /// Shape consistent means they are either the same shape, or one input array
        /// can be broadcasted to create the same shape as the other one.
        /// </summary>
        /// <param name="a1">
        /// Input arrays.
        /// </param>
        /// <returns>
        /// True if equivalent, False otherwise.
        /// </returns>
        public bool array_equiv(NDarray a1)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.array_equiv(@this, a1);
        }
        
        /// <summary>
        /// Return the truth value of (x1 &gt; x2) element-wise.
        /// </summary>
        /// <param name="x1">
        /// Input arrays.  If x1.shape != x2.shape, they must be
        /// broadcastable to a common shape (which may be the shape of one or
        /// the other).
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Output array, element-wise comparison of x1 and x2.
        /// Typically of type bool, unless dtype=object is passed.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray greater(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.greater(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return the truth value of (x1 &gt;= x2) element-wise.
        /// </summary>
        /// <param name="x1">
        /// Input arrays.  If x1.shape != x2.shape, they must be
        /// broadcastable to a common shape (which may be the shape of one or
        /// the other).
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Output array, element-wise comparison of x1 and x2.
        /// Typically of type bool, unless dtype=object is passed.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray<bool> greater_equal(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.greater_equal(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return the truth value of (x1 &lt; x2) element-wise.
        /// </summary>
        /// <param name="x1">
        /// Input arrays.  If x1.shape != x2.shape, they must be
        /// broadcastable to a common shape (which may be the shape of one or
        /// the other).
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Output array, element-wise comparison of x1 and x2.
        /// Typically of type bool, unless dtype=object is passed.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray less(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.less(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return the truth value of (x1 =&lt; x2) element-wise.
        /// </summary>
        /// <param name="x1">
        /// Input arrays.  If x1.shape != x2.shape, they must be
        /// broadcastable to a common shape (which may be the shape of one or
        /// the other).
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Output array, element-wise comparison of x1 and x2.
        /// Typically of type bool, unless dtype=object is passed.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray less_equal(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.less_equal(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return (x1 == x2) element-wise.
        /// </summary>
        /// <param name="x1">
        /// Input arrays of the same shape.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Output array, element-wise comparison of x1 and x2.
        /// Typically of type bool, unless dtype=object is passed.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray equal(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.equal(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Return (x1 != x2) element-wise.
        /// </summary>
        /// <param name="x1">
        /// Input arrays.
        /// </param>
        /// <param name="@out">
        /// A location into which the result is stored. If provided, it must have
        /// a shape that the inputs broadcast to. If not provided or None,
        /// a freshly-allocated array is returned. A tuple (possible only as a
        /// keyword argument) must have length equal to the number of outputs.
        /// </param>
        /// <param name="@where">
        /// Values of True indicate to calculate the ufunc at that position, values
        /// of False indicate to leave the value in the output alone.
        /// </param>
        /// <returns>
        /// Output array, element-wise comparison of x1 and x2.
        /// Typically of type bool, unless dtype=object is passed.
        /// This is a scalar if both x1 and x2 are scalars.
        /// </returns>
        public NDarray not_equal(NDarray x1, NDarray @out = null, NDarray @where = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.not_equal(@this, x1, @out:@out, @where:@where);
        }
        
        /// <summary>
        /// Generates a random sample from a given 1-D array
        /// </summary>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  Default is None, in which case a
        /// single value is returned.
        /// </param>
        /// <param name="replace">
        /// Whether the sample is with or without replacement
        /// </param>
        /// <param name="p">
        /// The probabilities associated with each entry in a.
        /// If not given the sample assumes a uniform distribution over all
        /// entries in a.
        /// </param>
        /// <returns>
        /// The generated random samples
        /// </returns>
        public NDarray choice(int[] size = null, bool? replace = true, NDarray p = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.choice(@this, size:size, replace:replace, p:p);
        }
        
        /// <summary>
        /// Modify a sequence in-place by shuffling its contents.
        /// 
        /// This function only shuffles the array along the first axis of a
        /// multi-dimensional array. The order of sub-arrays is changed but
        /// their contents remains the same.
        /// </summary>
        public void shuffle()
        {
            //auto-generated code, do not change
            var @this=this;
            NumPy.Instance.shuffle(@this);
        }
        
        /// <summary>
        /// Randomly permute a sequence, or return a permuted range.
        /// 
        /// If x is a multi-dimensional array, it is only shuffled along its
        /// first index.
        /// </summary>
        /// <returns>
        /// Permuted sequence or array range.
        /// </returns>
        public NDarray permutation()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.permutation(@this);
        }
        
        /// <summary>
        /// Draw samples from the Dirichlet distribution.
        /// 
        /// Draw size samples of dimension k from a Dirichlet distribution. A
        /// Dirichlet-distributed random variable can be seen as a multivariate
        /// generalization of a Beta distribution. Dirichlet pdf is the conjugate
        /// prior of a multinomial in Bayesian inference.
        /// 
        /// Notes
        /// 
        /// Uses the following property for computation: for each dimension,
        /// draw a random sample y_i from a standard gamma generator of shape
        /// alpha_i, then
        ///  is
        /// Dirichlet distributed.
        /// 
        /// References
        /// </summary>
        /// <param name="size">
        /// Output shape.  If the given shape is, e.g., (m, n, k), then
        /// m * n * k samples are drawn.  Default is None, in which case a
        /// single value is returned.
        /// </param>
        /// <returns>
        /// The drawn samples, of shape (size, alpha.ndim).
        /// </returns>
        public NDarray dirichlet(int[] size = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.dirichlet(@this, size:size);
        }
        
        /// <summary>
        /// Draw random samples from a multivariate normal distribution.
        /// 
        /// The multivariate normal, multinormal or Gaussian distribution is a
        /// generalization of the one-dimensional normal distribution to higher
        /// dimensions.  Such a distribution is specified by its mean and
        /// covariance matrix.  These parameters are analogous to the mean
        /// (average or “center”) and variance (standard deviation, or “width,”
        /// squared) of the one-dimensional normal distribution.
        /// 
        /// Notes
        /// 
        /// The mean is a coordinate in N-dimensional space, which represents the
        /// location where samples are most likely to be generated.  This is
        /// analogous to the peak of the bell curve for the one-dimensional or
        /// univariate normal distribution.
        /// 
        /// Covariance indicates the level to which two variables vary together.
        /// From the multivariate normal distribution, we draw N-dimensional
        /// samples, .  The covariance matrix
        /// element  is the covariance of  and .
        /// The element  is the variance of  (i.e. its
        /// “spread”).
        /// 
        /// Instead of specifying the full covariance matrix, popular
        /// approximations include:
        /// 
        /// This geometrical property can be seen in two dimensions by plotting
        /// generated data-points:
        /// 
        /// Diagonal covariance means that points are oriented along x or y-axis:
        /// 
        /// Note that the covariance matrix must be positive semidefinite (a.k.a.
        /// nonnegative-definite). Otherwise, the behavior of this method is
        /// undefined and backwards compatibility is not guaranteed.
        /// 
        /// References
        /// </summary>
        /// <param name="cov">
        /// Covariance matrix of the distribution. It must be symmetric and
        /// positive-semidefinite for proper sampling.
        /// </param>
        /// <param name="size">
        /// Given a shape of, for example, (m,n,k), m*n*k samples are
        /// generated, and packed in an m-by-n-by-k arrangement.  Because
        /// each sample is N-dimensional, the output shape is (m,n,k,N).
        /// If no shape is specified, a single (N-D) sample is returned.
        /// </param>
        /// <param name="check_valid">
        /// Behavior when the covariance matrix is not positive semidefinite.
        /// </param>
        /// <param name="tol">
        /// Tolerance when checking the singular values in covariance matrix.
        /// </param>
        /// <returns>
        /// The drawn samples, of shape size, if that was provided.  If not,
        /// the shape is (N,).
        /// 
        /// In other words, each entry out[i,j,...,:] is an N-dimensional
        /// value drawn from the distribution.
        /// </returns>
        public NDarray multivariate_normal(NDarray cov, int[] size = null, string check_valid = null, float? tol = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.multivariate_normal(@this, cov, size:size, check_valid:check_valid, tol:tol);
        }
        
        /// <summary>
        /// Container for the Mersenne Twister pseudo-random number generator.
        /// 
        /// RandomState exposes a number of methods for generating random numbers
        /// drawn from a variety of probability distributions. In addition to the
        /// distribution-specific arguments, each method takes a keyword argument
        /// size that defaults to None. If size is None, then a single
        /// value is generated and returned. If size is an integer, then a 1-D
        /// array filled with generated values is returned. If size is a tuple,
        /// then an array with that shape is filled and returned.
        /// 
        /// Compatibility Guarantee
        /// A fixed seed and a fixed series of calls to ‘RandomState’ methods using
        /// the same parameters will always produce the same results up to roundoff
        /// error except when the values were incorrect. Incorrect values will be
        /// fixed and the NumPy version in which the fix was made will be noted in
        /// the relevant docstring. Extension of existing parameter ranges and the
        /// addition of new parameters is allowed as long the previous behavior
        /// remains unchanged.
        /// 
        /// Notes
        /// 
        /// The Python stdlib module “random” also contains a Mersenne Twister
        /// pseudo-random number generator with a number of methods that are similar
        /// to the ones available in RandomState. RandomState, besides being
        /// NumPy-aware, has the advantage that it provides a much larger number
        /// of probability distributions to choose from.
        /// 
        /// Methods
        /// </summary>
        public void RandomState()
        {
            //auto-generated code, do not change
            var @this=this;
            NumPy.Instance.RandomState(@this);
        }
        
        /// <summary>
        /// Seed the generator.
        /// 
        /// This method is called when RandomState is initialized. It can be
        /// called again to re-seed the generator. For details, see RandomState.
        /// </summary>
        public void seed()
        {
            //auto-generated code, do not change
            var @this=this;
            NumPy.Instance.seed(@this);
        }
        
        /// <summary>
        /// Return a sorted copy of an array.
        /// 
        /// Notes
        /// 
        /// The various sorting algorithms are characterized by their average speed,
        /// worst case performance, work space size, and whether they are stable. A
        /// stable sort keeps items with the same key in the same relative
        /// order. The three available algorithms have the following
        /// properties:
        /// 
        /// All the sort algorithms make temporary copies of the data when
        /// sorting along any but the last axis.  Consequently, sorting along
        /// the last axis is faster and uses less space than sorting along
        /// any other axis.
        /// 
        /// The sort order for complex numbers is lexicographic. If both the real
        /// and imaginary parts are non-nan then the order is determined by the
        /// real parts except when they are equal, in which case the order is
        /// determined by the imaginary parts.
        /// 
        /// Previous to numpy 1.4.0 sorting real and complex arrays containing nan
        /// values led to undefined behaviour. In numpy versions &gt;= 1.4.0 nan
        /// values are sorted to the end. The extended sort order is:
        /// 
        /// where R is a non-nan real value. Complex values with the same nan
        /// placements are sorted according to the non-nan part if it exists.
        /// Non-nan values are sorted as before.
        /// 
        /// quicksort has been changed to an introsort which will switch
        /// heapsort when it does not make enough progress. This makes its
        /// worst case O(n*log(n)).
        /// 
        /// ‘stable’ automatically choses the best stable sorting algorithm
        /// for the data type being sorted. It is currently mapped to
        /// merge sort.
        /// </summary>
        /// <param name="axis">
        /// Axis along which to sort. If None, the array is flattened before
        /// sorting. The default is -1, which sorts along the last axis.
        /// </param>
        /// <param name="kind">
        /// Sorting algorithm. Default is ‘quicksort’.
        /// </param>
        /// <param name="order">
        /// When a is an array with fields defined, this argument specifies
        /// which fields to compare first, second, etc.  A single field can
        /// be specified as a string, and not all fields need be specified,
        /// but unspecified fields will still be used, in the order in which
        /// they come up in the dtype, to break ties.
        /// </param>
        /// <returns>
        /// Array of the same type and shape as a.
        /// </returns>
        public NDarray sort(int? axis = -1, string kind = "quicksort", string order = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.sort(@this, axis:axis, kind:kind, order:order);
        }
        
        /// <summary>
        /// Perform an indirect stable sort using a sequence of keys.
        /// 
        /// Given multiple sorting keys, which can be interpreted as columns in a
        /// spreadsheet, lexsort returns an array of integer indices that describes
        /// the sort order by multiple columns. The last key in the sequence is used
        /// for the primary sort order, the second-to-last key for the secondary sort
        /// order, and so on. The keys argument must be a sequence of objects that
        /// can be converted to arrays of the same shape. If a 2D array is provided
        /// for the keys argument, it’s rows are interpreted as the sorting keys and
        /// sorting is according to the last row, second last row etc.
        /// </summary>
        /// <param name="axis">
        /// Axis to be indirectly sorted.  By default, sort over the last axis.
        /// </param>
        /// <returns>
        /// Array of indices that sort the keys along the specified axis.
        /// </returns>
        public NDarray lexsort(int? axis = -1)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.lexsort(@this, axis:axis);
        }
        
        /// <summary>
        /// Returns the indices that would sort an array.
        /// 
        /// Perform an indirect sort along the given axis using the algorithm specified
        /// by the kind keyword. It returns an array of indices of the same shape as
        /// a that index data along the given axis in sorted order.
        /// 
        /// Notes
        /// 
        /// See sort for notes on the different sorting algorithms.
        /// 
        /// As of NumPy 1.4.0 argsort works with real/complex arrays containing
        /// nan values. The enhanced sort order is documented in sort.
        /// </summary>
        /// <param name="axis">
        /// Axis along which to sort.  The default is -1 (the last axis). If None,
        /// the flattened array is used.
        /// </param>
        /// <param name="kind">
        /// Sorting algorithm.
        /// </param>
        /// <param name="order">
        /// When a is an array with fields defined, this argument specifies
        /// which fields to compare first, second, etc.  A single field can
        /// be specified as a string, and not all fields need be specified,
        /// but unspecified fields will still be used, in the order in which
        /// they come up in the dtype, to break ties.
        /// </param>
        /// <returns>
        /// Array of indices that sort a along the specified axis.
        /// If a is one-dimensional, a[index_array] yields a sorted a.
        /// More generally, np.take_along_axis(a, index_array, axis=a) always
        /// yields the sorted a, irrespective of dimensionality.
        /// </returns>
        public NDarray argsort(int? axis = -1, string kind = "quicksort", string order = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.argsort(@this, axis:axis, kind:kind, order:order);
        }
        
        /// <summary>
        /// Return a copy of an array sorted along the first axis.
        /// 
        /// Notes
        /// 
        /// np.msort(a) is equivalent to  np.sort(a, axis=0).
        /// </summary>
        /// <returns>
        /// Array of the same type and shape as a.
        /// </returns>
        public NDarray msort()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.msort(@this);
        }
        
        /// <summary>
        /// Sort a complex array using the real part first, then the imaginary part.
        /// </summary>
        /// <returns>
        /// Always returns a sorted complex array.
        /// </returns>
        public NDarray sort_complex()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.sort_complex(@this);
        }
        
        /// <summary>
        /// Return a partitioned copy of an array.
        /// 
        /// Creates a copy of the array with its elements rearranged in such a
        /// way that the value of the element in k-th position is in the
        /// position it would be in a sorted array. All elements smaller than
        /// the k-th element are moved before this element and all equal or
        /// greater are moved behind it. The ordering of the elements in the two
        /// partitions is undefined.
        /// 
        /// Notes
        /// 
        /// The various selection algorithms are characterized by their average
        /// speed, worst case performance, work space size, and whether they are
        /// stable. A stable sort keeps items with the same key in the same
        /// relative order. The available algorithms have the following
        /// properties:
        /// 
        /// All the partition algorithms make temporary copies of the data when
        /// partitioning along any but the last axis.  Consequently,
        /// partitioning along the last axis is faster and uses less space than
        /// partitioning along any other axis.
        /// 
        /// The sort order for complex numbers is lexicographic. If both the
        /// real and imaginary parts are non-nan then the order is determined by
        /// the real parts except when they are equal, in which case the order
        /// is determined by the imaginary parts.
        /// </summary>
        /// <param name="kth">
        /// Element index to partition by. The k-th value of the element
        /// will be in its final sorted position and all smaller elements
        /// will be moved before it and all equal or greater elements behind
        /// it. The order of all elements in the partitions is undefined. If
        /// provided with a sequence of k-th it will partition all elements
        /// indexed by k-th  of them into their sorted position at once.
        /// </param>
        /// <param name="axis">
        /// Axis along which to sort. If None, the array is flattened before
        /// sorting. The default is -1, which sorts along the last axis.
        /// </param>
        /// <param name="kind">
        /// Selection algorithm. Default is ‘introselect’.
        /// </param>
        /// <param name="order">
        /// When a is an array with fields defined, this argument
        /// specifies which fields to compare first, second, etc.  A single
        /// field can be specified as a string.  Not all fields need be
        /// specified, but unspecified fields will still be used, in the
        /// order in which they come up in the dtype, to break ties.
        /// </param>
        /// <returns>
        /// Array of the same type and shape as a.
        /// </returns>
        public NDarray partition(int[] kth, int? axis = -1, string kind = "introselect", string order = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.partition(@this, kth, axis:axis, kind:kind, order:order);
        }
        
        /// <summary>
        /// Perform an indirect partition along the given axis using the
        /// algorithm specified by the kind keyword. It returns an array of
        /// indices of the same shape as a that index data along the given
        /// axis in partitioned order.
        /// 
        /// Notes
        /// 
        /// See partition for notes on the different selection algorithms.
        /// </summary>
        /// <param name="kth">
        /// Element index to partition by. The k-th element will be in its
        /// final sorted position and all smaller elements will be moved
        /// before it and all larger elements behind it. The order all
        /// elements in the partitions is undefined. If provided with a
        /// sequence of k-th it will partition all of them into their sorted
        /// position at once.
        /// </param>
        /// <param name="axis">
        /// Axis along which to sort. The default is -1 (the last axis). If
        /// None, the flattened array is used.
        /// </param>
        /// <param name="kind">
        /// Selection algorithm. Default is ‘introselect’
        /// </param>
        /// <param name="order">
        /// When a is an array with fields defined, this argument
        /// specifies which fields to compare first, second, etc. A single
        /// field can be specified as a string, and not all fields need be
        /// specified, but unspecified fields will still be used, in the
        /// order in which they come up in the dtype, to break ties.
        /// </param>
        /// <returns>
        /// Array of indices that partition a along the specified axis.
        /// If a is one-dimensional, a[index_array] yields a partitioned a.
        /// More generally, np.take_along_axis(a, index_array, axis=a) always
        /// yields the partitioned a, irrespective of dimensionality.
        /// </returns>
        public NDarray argpartition(int[] kth, int? axis = -1, string kind = "introselect", string order = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.argpartition(@this, kth, axis:axis, kind:kind, order:order);
        }
        
        /// <summary>
        /// Returns the indices of the maximum values along an axis.
        /// 
        /// Notes
        /// 
        /// In case of multiple occurrences of the maximum values, the indices
        /// corresponding to the first occurrence are returned.
        /// </summary>
        /// <param name="axis">
        /// By default, the index is into the flattened array, otherwise
        /// along the specified axis.
        /// </param>
        /// <param name="@out">
        /// If provided, the result will be inserted into this array. It should
        /// be of the appropriate shape and dtype.
        /// </param>
        /// <returns>
        /// Array of indices into the array. It has the same shape as a.shape
        /// with the dimension along axis removed.
        /// </returns>
        public NDarray argmax(int? axis = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.argmax(@this, axis:axis, @out:@out);
        }
        
        /// <summary>
        /// Return the indices of the maximum values in the specified axis ignoring
        /// NaNs. For all-NaN slices ValueError is raised. Warning: the
        /// results cannot be trusted if a slice contains only NaNs and -Infs.
        /// </summary>
        /// <param name="axis">
        /// Axis along which to operate.  By default flattened input is used.
        /// </param>
        /// <returns>
        /// An array of indices or a single index value.
        /// </returns>
        public NDarray nanargmax(int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanargmax(@this, axis:axis);
        }
        
        /// <summary>
        /// Returns the indices of the minimum values along an axis.
        /// 
        /// Notes
        /// 
        /// In case of multiple occurrences of the minimum values, the indices
        /// corresponding to the first occurrence are returned.
        /// </summary>
        /// <param name="axis">
        /// By default, the index is into the flattened array, otherwise
        /// along the specified axis.
        /// </param>
        /// <param name="@out">
        /// If provided, the result will be inserted into this array. It should
        /// be of the appropriate shape and dtype.
        /// </param>
        /// <returns>
        /// Array of indices into the array. It has the same shape as a.shape
        /// with the dimension along axis removed.
        /// </returns>
        public NDarray argmin(int? axis = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.argmin(@this, axis:axis, @out:@out);
        }
        
        /// <summary>
        /// Return the indices of the minimum values in the specified axis ignoring
        /// NaNs. For all-NaN slices ValueError is raised. Warning: the results
        /// cannot be trusted if a slice contains only NaNs and Infs.
        /// </summary>
        /// <param name="axis">
        /// Axis along which to operate.  By default flattened input is used.
        /// </param>
        /// <returns>
        /// An array of indices or a single index value.
        /// </returns>
        public NDarray nanargmin(int? axis = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanargmin(@this, axis:axis);
        }
        
        /// <summary>
        /// Find the indices of array elements that are non-zero, grouped by element.
        /// 
        /// Notes
        /// 
        /// np.argwhere(a) is the same as np.transpose(np.nonzero(a)).
        /// 
        /// The output of argwhere is not suitable for indexing arrays.
        /// For this purpose use nonzero(a) instead.
        /// </summary>
        /// <returns>
        /// Indices of elements that are non-zero. Indices are grouped by element.
        /// </returns>
        public NDarray argwhere()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.argwhere(@this);
        }
        
        /// <summary>
        /// Return the indices of the elements that are non-zero.
        /// 
        /// Returns a tuple of arrays, one for each dimension of a,
        /// containing the indices of the non-zero elements in that
        /// dimension. The values in a are always tested and returned in
        /// row-major, C-style order. The corresponding non-zero
        /// values can be obtained with:
        /// 
        /// To group the indices by element, rather than dimension, use:
        /// 
        /// The result of this is always a 2-D array, with a row for
        /// each non-zero element.
        /// </summary>
        /// <returns>
        /// Indices of elements that are non-zero.
        /// </returns>
        public NDarray[] nonzero()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nonzero(@this);
        }
        
        /// <summary>
        /// Return indices that are non-zero in the flattened version of a.
        /// 
        /// This is equivalent to np.nonzero(np.ravel(a))[0].
        /// </summary>
        /// <returns>
        /// Output array, containing the indices of the elements of a.ravel()
        /// that are non-zero.
        /// </returns>
        public NDarray flatnonzero()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.flatnonzero(@this);
        }
        
        /// <summary>
        /// Return elements chosen from x or y depending on condition.
        /// 
        /// Notes
        /// 
        /// If all the arrays are 1-D, where is equivalent to:
        /// </summary>
        /// <param name="y">
        /// Values from which to choose. x, y and condition need to be
        /// broadcastable to some shape.
        /// </param>
        /// <param name="x">
        /// Values from which to choose. x, y and condition need to be
        /// broadcastable to some shape.
        /// </param>
        /// <returns>
        /// An array with elements from x where condition is True, and elements
        /// from y elsewhere.
        /// </returns>
        public NDarray @where(NDarray y, NDarray x)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.@where(@this, y, x);
        }
        
        /// <summary>
        /// Find indices where elements should be inserted to maintain order.
        /// 
        /// Find the indices into a sorted array a such that, if the
        /// corresponding elements in v were inserted before the indices, the
        /// order of a would be preserved.
        /// 
        /// Assuming that a is sorted:
        /// 
        /// Notes
        /// 
        /// Binary search is used to find the required insertion points.
        /// 
        /// As of NumPy 1.4.0 searchsorted works with real/complex arrays containing
        /// nan values. The enhanced sort order is documented in sort.
        /// 
        /// This function is a faster version of the builtin python bisect.bisect_left
        /// (side='left') and bisect.bisect_right (side='right') functions,
        /// which is also vectorized in the v argument.
        /// </summary>
        /// <param name="v">
        /// Values to insert into a.
        /// </param>
        /// <param name="side">
        /// If ‘left’, the index of the first suitable location found is given.
        /// If ‘right’, return the last such index.  If there is no suitable
        /// index, return either 0 or N (where N is the length of a).
        /// </param>
        /// <param name="sorter">
        /// Optional array of integer indices that sort array a into ascending
        /// order. They are typically the result of argsort.
        /// </param>
        /// <returns>
        /// Array of insertion points with the same shape as v.
        /// </returns>
        public NDarray<int> searchsorted(NDarray v, string side = "left", NDarray sorter = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.searchsorted(@this, v, side:side, sorter:sorter);
        }
        
        /// <summary>
        /// Return the elements of an array that satisfy some condition.
        /// 
        /// This is equivalent to np.compress(ravel(condition), ravel(arr)).  If
        /// condition is boolean np.extract is equivalent to arr[condition].
        /// 
        /// Note that place does the exact opposite of extract.
        /// </summary>
        /// <param name="arr">
        /// Input array of the same size as condition.
        /// </param>
        /// <returns>
        /// Rank 1 array of values from arr where condition is True.
        /// </returns>
        public NDarray extract(NDarray arr)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.extract(@this, arr);
        }
        
        /// <summary>
        /// Counts the number of non-zero values in the array a.
        /// 
        /// The word “non-zero” is in reference to the Python 2.x
        /// built-in method __nonzero__() (renamed __bool__()
        /// in Python 3.x) of Python objects that tests an object’s
        /// “truthfulness”. For example, any number is considered
        /// truthful if it is nonzero, whereas any string is considered
        /// truthful if it is not the empty string. Thus, this function
        /// (recursively) counts how many elements in a (and in
        /// sub-arrays thereof) have their __nonzero__() or __bool__()
        /// method evaluated to True.
        /// </summary>
        /// <param name="axis">
        /// Axis or tuple of axes along which to count non-zeros.
        /// Default is None, meaning that non-zeros will be counted
        /// along a flattened version of a.
        /// </param>
        /// <returns>
        /// Number of non-zero values in the array along a given axis.
        /// Otherwise, the total number of non-zero values in the array
        /// is returned.
        /// </returns>
        public NDarray<int> count_nonzero(int[] axis)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.count_nonzero(@this, axis:axis);
        }
        
        /// <summary>
        /// Counts the number of non-zero values in the array a.
        /// 
        /// The word “non-zero” is in reference to the Python 2.x
        /// built-in method __nonzero__() (renamed __bool__()
        /// in Python 3.x) of Python objects that tests an object’s
        /// “truthfulness”. For example, any number is considered
        /// truthful if it is nonzero, whereas any string is considered
        /// truthful if it is not the empty string. Thus, this function
        /// (recursively) counts how many elements in a (and in
        /// sub-arrays thereof) have their __nonzero__() or __bool__()
        /// method evaluated to True.
        /// </summary>
        /// <returns>
        /// Number of non-zero values in the array along a given axis.
        /// Otherwise, the total number of non-zero values in the array
        /// is returned.
        /// </returns>
        public int count_nonzero()
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.count_nonzero(@this);
        }
        
        /// <summary>
        /// Return the minimum of an array or minimum along an axis.
        /// 
        /// Notes
        /// 
        /// NaN values are propagated, that is if at least one item is NaN, the
        /// corresponding min value will be NaN as well. To ignore NaN values
        /// (MATLAB behavior), please use nanmin.
        /// 
        /// Don’t use amin for element-wise comparison of 2 arrays; when
        /// a.shape[0] is 2, minimum(a[0], a[1]) is faster than
        /// amin(a, axis=0).
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which to operate.  By default, flattened input is
        /// used.
        /// 
        /// If this is a tuple of ints, the minimum is selected over multiple axes,
        /// instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result.  Must
        /// be of the same shape and buffer length as the expected output.
        /// See doc.ufuncs (Section “Output arguments”) for more details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the amin method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <param name="initial">
        /// The maximum value of an output element. Must be present to allow
        /// computation on empty slice. See reduce for details.
        /// </param>
        /// <returns>
        /// Minimum of a. If axis is None, the result is a scalar value.
        /// If axis is given, the result is an array of dimension
        /// a.ndim - 1.
        /// </returns>
        public NDarray amin(int[] axis = null, NDarray @out = null, bool? keepdims = null, ValueType initial = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.amin(@this, axis:axis, @out:@out, keepdims:keepdims, initial:initial);
        }
        
        /// <summary>
        /// Return the maximum of an array or maximum along an axis.
        /// 
        /// Notes
        /// 
        /// NaN values are propagated, that is if at least one item is NaN, the
        /// corresponding max value will be NaN as well. To ignore NaN values
        /// (MATLAB behavior), please use nanmax.
        /// 
        /// Don’t use amax for element-wise comparison of 2 arrays; when
        /// a.shape[0] is 2, maximum(a[0], a[1]) is faster than
        /// amax(a, axis=0).
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which to operate.  By default, flattened input is
        /// used.
        /// 
        /// If this is a tuple of ints, the maximum is selected over multiple axes,
        /// instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result.  Must
        /// be of the same shape and buffer length as the expected output.
        /// See doc.ufuncs (Section “Output arguments”) for more details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the amax method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <param name="initial">
        /// The minimum value of an output element. Must be present to allow
        /// computation on empty slice. See reduce for details.
        /// </param>
        /// <returns>
        /// Maximum of a. If axis is None, the result is a scalar value.
        /// If axis is given, the result is an array of dimension
        /// a.ndim - 1.
        /// </returns>
        public NDarray amax(int[] axis = null, NDarray @out = null, bool? keepdims = null, ValueType initial = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.amax(@this, axis:axis, @out:@out, keepdims:keepdims, initial:initial);
        }
        
        /// <summary>
        /// Return minimum of an array or minimum along an axis, ignoring any NaNs.
        /// When all-NaN slices are encountered a RuntimeWarning is raised and
        /// Nan is returned for that slice.
        /// 
        /// Notes
        /// 
        /// NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
        /// (IEEE 754). This means that Not a Number is not equivalent to infinity.
        /// Positive infinity is treated as a very large number and negative
        /// infinity is treated as a very small (i.e. negative) number.
        /// 
        /// If the input has a integer type the function is equivalent to np.min.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the minimum is computed. The default is to compute
        /// the minimum of the flattened array.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None; if provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.  See
        /// doc.ufuncs for details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// 
        /// If the value is anything but the default, then
        /// keepdims will be passed through to the min method
        /// of sub-classes of ndarray.  If the sub-classes methods
        /// does not implement keepdims any exceptions will be raised.
        /// </param>
        /// <returns>
        /// An array with the same shape as a, with the specified axis
        /// removed.  If a is a 0-d array, or if axis is None, an ndarray
        /// scalar is returned.  The same dtype as a is returned.
        /// </returns>
        public NDarray nanmin(int[] axis = null, NDarray @out = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanmin(@this, axis:axis, @out:@out, keepdims:keepdims);
        }
        
        /// <summary>
        /// Return the maximum of an array or maximum along an axis, ignoring any
        /// NaNs.  When all-NaN slices are encountered a RuntimeWarning is
        /// raised and NaN is returned for that slice.
        /// 
        /// Notes
        /// 
        /// NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
        /// (IEEE 754). This means that Not a Number is not equivalent to infinity.
        /// Positive infinity is treated as a very large number and negative
        /// infinity is treated as a very small (i.e. negative) number.
        /// 
        /// If the input has a integer type the function is equivalent to np.max.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the maximum is computed. The default is to compute
        /// the maximum of the flattened array.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None; if provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.  See
        /// doc.ufuncs for details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// 
        /// If the value is anything but the default, then
        /// keepdims will be passed through to the max method
        /// of sub-classes of ndarray.  If the sub-classes methods
        /// does not implement keepdims any exceptions will be raised.
        /// </param>
        /// <returns>
        /// An array with the same shape as a, with the specified axis removed.
        /// If a is a 0-d array, or if axis is None, an ndarray scalar is
        /// returned.  The same dtype as a is returned.
        /// </returns>
        public NDarray nanmax(int[] axis = null, NDarray @out = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanmax(@this, axis:axis, @out:@out, keepdims:keepdims);
        }
        
        /// <summary>
        /// Range of values (maximum - minimum) along an axis.
        /// 
        /// The name of the function comes from the acronym for ‘peak to peak’.
        /// </summary>
        /// <param name="axis">
        /// Axis along which to find the peaks.  By default, flatten the
        /// array.  axis may be negative, in
        /// which case it counts from the last to the first axis.
        /// 
        /// If this is a tuple of ints, a reduction is performed on multiple
        /// axes, instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type of the output values will be cast if necessary.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the ptp method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <returns>
        /// A new array holding the result, unless out was
        /// specified, in which case a reference to out is returned.
        /// </returns>
        public NDarray ptp(int[] axis = null, NDarray @out = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.ptp(@this, axis:axis, @out:@out, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the q-th percentile of the data along the specified axis.
        /// 
        /// Returns the q-th percentile(s) of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the q-th percentile of
        /// V is the value q/100 of the way from the minimum to the
        /// maximum in a sorted copy of V. The values and distances of
        /// the two nearest neighbors as well as the interpolation parameter
        /// will determine the percentile if the normalized ranking does not
        /// match the location of q exactly. This function is the same as
        /// the median if q=50, the same as the minimum if q=0 and the
        /// same as the maximum if q=100.
        /// </summary>
        /// <param name="q">
        /// Percentile or sequence of percentiles to compute, which must be between
        /// 0 and 100 inclusive.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the percentiles are computed. The
        /// default is to compute the percentile(s) along a flattened
        /// version of the array.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired percentile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left in
        /// the result as dimensions with size one. With this option, the
        /// result will broadcast correctly against the original array a.
        /// </param>
        /// <returns>
        /// If q is a single percentile and axis=None, then the result
        /// is a scalar. If multiple percentiles are given, first axis of
        /// the result corresponds to the percentiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public NDarray<double> percentile(NDarray<float> q, int[] axis, NDarray @out = null, bool? overwrite_input = false, string interpolation = "linear", bool? keepdims = false)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.percentile(@this, q, axis:axis, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the q-th percentile of the data along the specified axis.
        /// 
        /// Returns the q-th percentile(s) of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the q-th percentile of
        /// V is the value q/100 of the way from the minimum to the
        /// maximum in a sorted copy of V. The values and distances of
        /// the two nearest neighbors as well as the interpolation parameter
        /// will determine the percentile if the normalized ranking does not
        /// match the location of q exactly. This function is the same as
        /// the median if q=50, the same as the minimum if q=0 and the
        /// same as the maximum if q=100.
        /// </summary>
        /// <param name="q">
        /// Percentile or sequence of percentiles to compute, which must be between
        /// 0 and 100 inclusive.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired percentile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <returns>
        /// If q is a single percentile and axis=None, then the result
        /// is a scalar. If multiple percentiles are given, first axis of
        /// the result corresponds to the percentiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public double percentile(NDarray<float> q, NDarray @out = null, bool? overwrite_input = false, string interpolation = "linear")
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.percentile(@this, q, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation);
        }
        
        /// <summary>
        /// Compute the qth percentile of the data along the specified axis,
        /// while ignoring nan values.
        /// 
        /// Returns the qth percentile(s) of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the q-th percentile of
        /// V is the value q/100 of the way from the minimum to the
        /// maximum in a sorted copy of V. The values and distances of
        /// the two nearest neighbors as well as the interpolation parameter
        /// will determine the percentile if the normalized ranking does not
        /// match the location of q exactly. This function is the same as
        /// the median if q=50, the same as the minimum if q=0 and the
        /// same as the maximum if q=100.
        /// </summary>
        /// <param name="q">
        /// Percentile or sequence of percentiles to compute, which must be between
        /// 0 and 100 inclusive.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the percentiles are computed. The
        /// default is to compute the percentile(s) along a flattened
        /// version of the array.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired percentile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left in
        /// the result as dimensions with size one. With this option, the
        /// result will broadcast correctly against the original array a.
        /// 
        /// If this is anything but the default value it will be passed
        /// through (in the special case of an empty array) to the
        /// mean function of the underlying array.  If the array is
        /// a sub-class and mean does not have the kwarg keepdims this
        /// will raise a RuntimeError.
        /// </param>
        /// <returns>
        /// If q is a single percentile and axis=None, then the result
        /// is a scalar. If multiple percentiles are given, first axis of
        /// the result corresponds to the percentiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public NDarray<double> nanpercentile(NDarray<float> q, int[] axis, NDarray @out = null, bool? overwrite_input = false, string interpolation = "linear", bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanpercentile(@this, q, axis:axis, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the qth percentile of the data along the specified axis,
        /// while ignoring nan values.
        /// 
        /// Returns the qth percentile(s) of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the q-th percentile of
        /// V is the value q/100 of the way from the minimum to the
        /// maximum in a sorted copy of V. The values and distances of
        /// the two nearest neighbors as well as the interpolation parameter
        /// will determine the percentile if the normalized ranking does not
        /// match the location of q exactly. This function is the same as
        /// the median if q=50, the same as the minimum if q=0 and the
        /// same as the maximum if q=100.
        /// </summary>
        /// <param name="q">
        /// Percentile or sequence of percentiles to compute, which must be between
        /// 0 and 100 inclusive.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired percentile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <returns>
        /// If q is a single percentile and axis=None, then the result
        /// is a scalar. If multiple percentiles are given, first axis of
        /// the result corresponds to the percentiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public double nanpercentile(NDarray<float> q, NDarray @out = null, bool? overwrite_input = false, string interpolation = "linear")
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanpercentile(@this, q, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation);
        }
        
        /// <summary>
        /// Compute the q-th quantile of the data along the specified axis.
        /// ..versionadded:: 1.15.0
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the q-th quantile of
        /// V is the value q of the way from the minimum to the
        /// maximum in a sorted copy of V. The values and distances of
        /// the two nearest neighbors as well as the interpolation parameter
        /// will determine the quantile if the normalized ranking does not
        /// match the location of q exactly. This function is the same as
        /// the median if q=0.5, the same as the minimum if q=0.0 and the
        /// same as the maximum if q=1.0.
        /// </summary>
        /// <param name="q">
        /// Quantile or sequence of quantiles to compute, which must be between
        /// 0 and 1 inclusive.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the quantiles are computed. The
        /// default is to compute the quantile(s) along a flattened
        /// version of the array.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired quantile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left in
        /// the result as dimensions with size one. With this option, the
        /// result will broadcast correctly against the original array a.
        /// </param>
        /// <returns>
        /// If q is a single quantile and axis=None, then the result
        /// is a scalar. If multiple quantiles are given, first axis of
        /// the result corresponds to the quantiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public NDarray<double> quantile(NDarray<float> q, int[] axis, NDarray @out = null, bool? overwrite_input = false, string interpolation = "linear", bool? keepdims = false)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.quantile(@this, q, axis:axis, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the q-th quantile of the data along the specified axis.
        /// ..versionadded:: 1.15.0
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the q-th quantile of
        /// V is the value q of the way from the minimum to the
        /// maximum in a sorted copy of V. The values and distances of
        /// the two nearest neighbors as well as the interpolation parameter
        /// will determine the quantile if the normalized ranking does not
        /// match the location of q exactly. This function is the same as
        /// the median if q=0.5, the same as the minimum if q=0.0 and the
        /// same as the maximum if q=1.0.
        /// </summary>
        /// <param name="q">
        /// Quantile or sequence of quantiles to compute, which must be between
        /// 0 and 1 inclusive.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired quantile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <returns>
        /// If q is a single quantile and axis=None, then the result
        /// is a scalar. If multiple quantiles are given, first axis of
        /// the result corresponds to the quantiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public double quantile(NDarray<float> q, NDarray @out = null, bool? overwrite_input = false, string interpolation = "linear")
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.quantile(@this, q, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation);
        }
        
        /// <summary>
        /// Compute the qth quantile of the data along the specified axis,
        /// while ignoring nan values.
        /// Returns the qth quantile(s) of the array elements.
        /// .. versionadded:: 1.15.0
        /// </summary>
        /// <param name="q">
        /// Quantile or sequence of quantiles to compute, which must be between
        /// 0 and 1 inclusive.
        /// </param>
        /// <param name="axis">
        /// Axis or axes along which the quantiles are computed. The
        /// default is to compute the quantile(s) along a flattened
        /// version of the array.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired quantile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left in
        /// the result as dimensions with size one. With this option, the
        /// result will broadcast correctly against the original array a.
        /// 
        /// If this is anything but the default value it will be passed
        /// through (in the special case of an empty array) to the
        /// mean function of the underlying array.  If the array is
        /// a sub-class and mean does not have the kwarg keepdims this
        /// will raise a RuntimeError.
        /// </param>
        /// <returns>
        /// If q is a single percentile and axis=None, then the result
        /// is a scalar. If multiple quantiles are given, first axis of
        /// the result corresponds to the quantiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public NDarray<double> nanquantile(NDarray<float> q, int[] axis, NDarray @out = null, bool? overwrite_input = false, string interpolation = "linear", bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanquantile(@this, q, axis:axis, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the qth quantile of the data along the specified axis,
        /// while ignoring nan values.
        /// Returns the qth quantile(s) of the array elements.
        /// .. versionadded:: 1.15.0
        /// </summary>
        /// <param name="q">
        /// Quantile or sequence of quantiles to compute, which must be between
        /// 0 and 1 inclusive.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow the input array a to be modified by intermediate
        /// calculations, to save memory. In this case, the contents of the input
        /// a after this function completes is undefined.
        /// </param>
        /// <param name="interpolation">
        /// This optional parameter specifies the interpolation method to
        /// use when the desired quantile lies between two data points
        /// i &lt; j:
        /// </param>
        /// <returns>
        /// If q is a single percentile and axis=None, then the result
        /// is a scalar. If multiple quantiles are given, first axis of
        /// the result corresponds to the quantiles. The other axes are
        /// the axes that remain after the reduction of a. If the input
        /// contains integers or floats smaller than float64, the output
        /// data-type is float64. Otherwise, the output data-type is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public double nanquantile(NDarray<float> q, NDarray @out = null, bool? overwrite_input = false, string interpolation = "linear")
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanquantile(@this, q, @out:@out, overwrite_input:overwrite_input, interpolation:interpolation);
        }
        
        /// <summary>
        /// Compute the median along the specified axis.
        /// 
        /// Returns the median of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the median of V is the
        /// middle value of a sorted copy of V, V_sorted - i
        /// e., V_sorted[(N-1)/2], when N is odd, and the average of the
        /// two middle values of V_sorted when N is even.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the medians are computed. The default
        /// is to compute the median along a flattened version of the array.
        /// A sequence of axes is supported since version 1.9.0.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow use of memory of input array a for
        /// calculations. The input array will be modified by the call to
        /// median. This will save memory when you do not need to preserve
        /// the contents of the input array. Treat the input as undefined,
        /// but it will probably be fully or partially sorted. Default is
        /// False. If overwrite_input is True and a is not already an
        /// ndarray, an error will be raised.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original arr.
        /// </param>
        /// <returns>
        /// A new array holding the result. If the input contains integers
        /// or floats smaller than float64, then the output data-type is
        /// np.float64.  Otherwise, the data-type of the output is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public NDarray<double> median(int[] axis, NDarray @out = null, bool? overwrite_input = false, bool? keepdims = false)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.median(@this, axis:axis, @out:@out, overwrite_input:overwrite_input, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the median along the specified axis.
        /// 
        /// Returns the median of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the median of V is the
        /// middle value of a sorted copy of V, V_sorted - i
        /// e., V_sorted[(N-1)/2], when N is odd, and the average of the
        /// two middle values of V_sorted when N is even.
        /// </summary>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow use of memory of input array a for
        /// calculations. The input array will be modified by the call to
        /// median. This will save memory when you do not need to preserve
        /// the contents of the input array. Treat the input as undefined,
        /// but it will probably be fully or partially sorted. Default is
        /// False. If overwrite_input is True and a is not already an
        /// ndarray, an error will be raised.
        /// </param>
        /// <returns>
        /// A new array holding the result. If the input contains integers
        /// or floats smaller than float64, then the output data-type is
        /// np.float64.  Otherwise, the data-type of the output is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public double median(NDarray @out = null, bool? overwrite_input = false)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.median(@this, @out:@out, overwrite_input:overwrite_input);
        }
        
        /// <summary>
        /// Compute the weighted average along the specified axis.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which to average a.  The default,
        /// axis=None, will average over all of the elements of the input array.
        /// If axis is negative it counts from the last to the first axis.
        /// 
        /// If axis is a tuple of ints, averaging is performed on all of the axes
        /// specified in the tuple instead of a single axis or all the axes as
        /// before.
        /// </param>
        /// <param name="weights">
        /// An array of weights associated with the values in a. Each value in
        /// a contributes to the average according to its associated weight.
        /// The weights array can either be 1-D (in which case its length must be
        /// the size of a along the given axis) or of the same shape as a.
        /// If weights=None, then all data in a are assumed to have a
        /// weight equal to one.
        /// </param>
        /// <param name="returned">
        /// Default is False. If True, the tuple (average, sum_of_weights)
        /// is returned, otherwise only the average is returned.
        /// If weights=None, sum_of_weights is equivalent to the number of
        /// elements over which the average is taken.
        /// </param>
        /// <returns>
        /// Return the average along the specified axis. When returned is True,
        /// return a tuple with the average as the first element and the sum
        /// of the weights as the second element. sum_of_weights is of the
        /// same type as retval. The result dtype follows a genereal pattern.
        /// If weights is None, the result dtype will be that of a , or float64
        /// if a is integral. Otherwise, if weights is not None and a is non-
        /// integral, the result type will be the type of lowest precision capable of
        /// representing values of both a and weights. If a happens to be
        /// integral, the previous rules still applies but the result dtype will
        /// at least be float64.
        /// </returns>
        public NDarray<double> average(int[] axis, NDarray weights = null, bool? returned = false)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.average(@this, axis:axis, weights:weights, returned:returned);
        }
        
        /// <summary>
        /// Compute the weighted average along the specified axis.
        /// </summary>
        /// <param name="weights">
        /// An array of weights associated with the values in a. Each value in
        /// a contributes to the average according to its associated weight.
        /// The weights array can either be 1-D (in which case its length must be
        /// the size of a along the given axis) or of the same shape as a.
        /// If weights=None, then all data in a are assumed to have a
        /// weight equal to one.
        /// </param>
        /// <param name="returned">
        /// Default is False. If True, the tuple (average, sum_of_weights)
        /// is returned, otherwise only the average is returned.
        /// If weights=None, sum_of_weights is equivalent to the number of
        /// elements over which the average is taken.
        /// </param>
        /// <returns>
        /// Return the average along the specified axis. When returned is True,
        /// return a tuple with the average as the first element and the sum
        /// of the weights as the second element. sum_of_weights is of the
        /// same type as retval. The result dtype follows a genereal pattern.
        /// If weights is None, the result dtype will be that of a , or float64
        /// if a is integral. Otherwise, if weights is not None and a is non-
        /// integral, the result type will be the type of lowest precision capable of
        /// representing values of both a and weights. If a happens to be
        /// integral, the previous rules still applies but the result dtype will
        /// at least be float64.
        /// </returns>
        public double average(NDarray weights = null, bool? returned = false)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.average(@this, weights:weights, returned:returned);
        }
        
        /// <summary>
        /// Compute the arithmetic mean along the specified axis.
        /// 
        /// Returns the average of the array elements.  The average is taken over
        /// the flattened array by default, otherwise over the specified axis.
        /// float64 intermediate and return values are used for integer inputs.
        /// 
        /// Notes
        /// 
        /// The arithmetic mean is the sum of the elements along the axis divided
        /// by the number of elements.
        /// 
        /// Note that for floating-point input, the mean is computed using the
        /// same precision the input has.  Depending on the input data, this can
        /// cause the results to be inaccurate, especially for float32 (see
        /// example below).  Specifying a higher-precision accumulator using the
        /// dtype keyword can alleviate this issue.
        /// 
        /// By default, float16 results are computed using float32 intermediates
        /// for extra precision.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the means are computed. The default is to
        /// compute the mean of the flattened array.
        /// 
        /// If this is a tuple of ints, a mean is performed over multiple axes,
        /// instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the mean.  For integer inputs, the default
        /// is float64; for floating point inputs, it is the same as the
        /// input dtype.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None; if provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.
        /// See doc.ufuncs for details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the mean method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <returns>
        /// If out=None, returns a new array containing the mean values,
        /// otherwise a reference to the output array is returned.
        /// </returns>
        public NDarray<double> mean(int[] axis, Dtype dtype = null, NDarray @out = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.mean(@this, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the arithmetic mean along the specified axis.
        /// 
        /// Returns the average of the array elements.  The average is taken over
        /// the flattened array by default, otherwise over the specified axis.
        /// float64 intermediate and return values are used for integer inputs.
        /// 
        /// Notes
        /// 
        /// The arithmetic mean is the sum of the elements along the axis divided
        /// by the number of elements.
        /// 
        /// Note that for floating-point input, the mean is computed using the
        /// same precision the input has.  Depending on the input data, this can
        /// cause the results to be inaccurate, especially for float32 (see
        /// example below).  Specifying a higher-precision accumulator using the
        /// dtype keyword can alleviate this issue.
        /// 
        /// By default, float16 results are computed using float32 intermediates
        /// for extra precision.
        /// </summary>
        /// <param name="dtype">
        /// Type to use in computing the mean.  For integer inputs, the default
        /// is float64; for floating point inputs, it is the same as the
        /// input dtype.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None; if provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.
        /// See doc.ufuncs for details.
        /// </param>
        /// <returns>
        /// If out=None, returns a new array containing the mean values,
        /// otherwise a reference to the output array is returned.
        /// </returns>
        public double mean(Dtype dtype = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.mean(@this, dtype:dtype, @out:@out);
        }
        
        /// <summary>
        /// Compute the standard deviation along the specified axis.
        /// 
        /// Returns the standard deviation, a measure of the spread of a distribution,
        /// of the array elements. The standard deviation is computed for the
        /// flattened array by default, otherwise over the specified axis.
        /// 
        /// Notes
        /// 
        /// The standard deviation is the square root of the average of the squared
        /// deviations from the mean, i.e., std = sqrt(mean(abs(x - x.mean())**2)).
        /// 
        /// The average squared deviation is normally calculated as
        /// x.sum() / N, where N = len(x).  If, however, ddof is specified,
        /// the divisor N - ddof is used instead. In standard statistical
        /// practice, ddof=1 provides an unbiased estimator of the variance
        /// of the infinite population. ddof=0 provides a maximum likelihood
        /// estimate of the variance for normally distributed variables. The
        /// standard deviation computed in this function is the square root of
        /// the estimated variance, so even with ddof=1, it will not be an
        /// unbiased estimate of the standard deviation per se.
        /// 
        /// Note that, for complex numbers, std takes the absolute
        /// value before squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the std is computed using the same
        /// precision the input has. Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example below).
        /// Specifying a higher-accuracy accumulator using the dtype keyword can
        /// alleviate this issue.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the standard deviation is computed. The
        /// default is to compute the standard deviation of the flattened array.
        /// 
        /// If this is a tuple of ints, a standard deviation is performed over
        /// multiple axes, instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the standard deviation. For arrays of
        /// integer type the default is float64, for arrays of float types it is
        /// the same as the array type.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output but the type (of the calculated
        /// values) will be cast if necessary.
        /// </param>
        /// <param name="ddof">
        /// Means Delta Degrees of Freedom.  The divisor used in calculations
        /// is N - ddof, where N represents the number of elements.
        /// By default ddof is zero.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the std method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <returns>
        /// If out is None, return a new array containing the standard deviation,
        /// otherwise return a reference to the output array.
        /// </returns>
        public NDarray<double> std(int[] axis, Dtype dtype = null, NDarray @out = null, int? ddof = 0, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.std(@this, axis:axis, dtype:dtype, @out:@out, ddof:ddof, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the standard deviation along the specified axis.
        /// 
        /// Returns the standard deviation, a measure of the spread of a distribution,
        /// of the array elements. The standard deviation is computed for the
        /// flattened array by default, otherwise over the specified axis.
        /// 
        /// Notes
        /// 
        /// The standard deviation is the square root of the average of the squared
        /// deviations from the mean, i.e., std = sqrt(mean(abs(x - x.mean())**2)).
        /// 
        /// The average squared deviation is normally calculated as
        /// x.sum() / N, where N = len(x).  If, however, ddof is specified,
        /// the divisor N - ddof is used instead. In standard statistical
        /// practice, ddof=1 provides an unbiased estimator of the variance
        /// of the infinite population. ddof=0 provides a maximum likelihood
        /// estimate of the variance for normally distributed variables. The
        /// standard deviation computed in this function is the square root of
        /// the estimated variance, so even with ddof=1, it will not be an
        /// unbiased estimate of the standard deviation per se.
        /// 
        /// Note that, for complex numbers, std takes the absolute
        /// value before squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the std is computed using the same
        /// precision the input has. Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example below).
        /// Specifying a higher-accuracy accumulator using the dtype keyword can
        /// alleviate this issue.
        /// </summary>
        /// <param name="dtype">
        /// Type to use in computing the standard deviation. For arrays of
        /// integer type the default is float64, for arrays of float types it is
        /// the same as the array type.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output but the type (of the calculated
        /// values) will be cast if necessary.
        /// </param>
        /// <param name="ddof">
        /// Means Delta Degrees of Freedom.  The divisor used in calculations
        /// is N - ddof, where N represents the number of elements.
        /// By default ddof is zero.
        /// </param>
        /// <returns>
        /// If out is None, return a new array containing the standard deviation,
        /// otherwise return a reference to the output array.
        /// </returns>
        public double std(Dtype dtype = null, NDarray @out = null, int? ddof = 0)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.std(@this, dtype:dtype, @out:@out, ddof:ddof);
        }
        
        /// <summary>
        /// Compute the variance along the specified axis.
        /// 
        /// Returns the variance of the array elements, a measure of the spread of a
        /// distribution.  The variance is computed for the flattened array by
        /// default, otherwise over the specified axis.
        /// 
        /// Notes
        /// 
        /// The variance is the average of the squared deviations from the mean,
        /// i.e.,  var = mean(abs(x - x.mean())**2).
        /// 
        /// The mean is normally calculated as x.sum() / N, where N = len(x).
        /// If, however, ddof is specified, the divisor N - ddof is used
        /// instead.  In standard statistical practice, ddof=1 provides an
        /// unbiased estimator of the variance of a hypothetical infinite population.
        /// ddof=0 provides a maximum likelihood estimate of the variance for
        /// normally distributed variables.
        /// 
        /// Note that for complex numbers, the absolute value is taken before
        /// squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the variance is computed using the same
        /// precision the input has.  Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example
        /// below).  Specifying a higher-accuracy accumulator using the dtype
        /// keyword can alleviate this issue.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the variance is computed.  The default is to
        /// compute the variance of the flattened array.
        /// 
        /// If this is a tuple of ints, a variance is performed over multiple axes,
        /// instead of a single axis or all the axes as before.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the variance.  For arrays of integer type
        /// the default is float32; for arrays of float types it is the same as
        /// the array type.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  It must have
        /// the same shape as the expected output, but the type is cast if
        /// necessary.
        /// </param>
        /// <param name="ddof">
        /// “Delta Degrees of Freedom”: the divisor used in the calculation is
        /// N - ddof, where N represents the number of elements. By
        /// default ddof is zero.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the input array.
        /// 
        /// If the default value is passed, then keepdims will not be
        /// passed through to the var method of sub-classes of
        /// ndarray, however any non-default value will be.  If the
        /// sub-class’ method does not implement keepdims any
        /// exceptions will be raised.
        /// </param>
        /// <returns>
        /// If out=None, returns a new array containing the variance;
        /// otherwise, a reference to the output array is returned.
        /// </returns>
        public NDarray<double> @var(int[] axis, Dtype dtype = null, NDarray @out = null, int? ddof = 0, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.@var(@this, axis:axis, dtype:dtype, @out:@out, ddof:ddof, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the variance along the specified axis.
        /// 
        /// Returns the variance of the array elements, a measure of the spread of a
        /// distribution.  The variance is computed for the flattened array by
        /// default, otherwise over the specified axis.
        /// 
        /// Notes
        /// 
        /// The variance is the average of the squared deviations from the mean,
        /// i.e.,  var = mean(abs(x - x.mean())**2).
        /// 
        /// The mean is normally calculated as x.sum() / N, where N = len(x).
        /// If, however, ddof is specified, the divisor N - ddof is used
        /// instead.  In standard statistical practice, ddof=1 provides an
        /// unbiased estimator of the variance of a hypothetical infinite population.
        /// ddof=0 provides a maximum likelihood estimate of the variance for
        /// normally distributed variables.
        /// 
        /// Note that for complex numbers, the absolute value is taken before
        /// squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the variance is computed using the same
        /// precision the input has.  Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example
        /// below).  Specifying a higher-accuracy accumulator using the dtype
        /// keyword can alleviate this issue.
        /// </summary>
        /// <param name="dtype">
        /// Type to use in computing the variance.  For arrays of integer type
        /// the default is float32; for arrays of float types it is the same as
        /// the array type.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  It must have
        /// the same shape as the expected output, but the type is cast if
        /// necessary.
        /// </param>
        /// <param name="ddof">
        /// “Delta Degrees of Freedom”: the divisor used in the calculation is
        /// N - ddof, where N represents the number of elements. By
        /// default ddof is zero.
        /// </param>
        /// <returns>
        /// If out=None, returns a new array containing the variance;
        /// otherwise, a reference to the output array is returned.
        /// </returns>
        public double @var(Dtype dtype = null, NDarray @out = null, int? ddof = 0)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.@var(@this, dtype:dtype, @out:@out, ddof:ddof);
        }
        
        /// <summary>
        /// Compute the median along the specified axis, while ignoring NaNs.
        /// 
        /// Returns the median of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the median of V is the
        /// middle value of a sorted copy of V, V_sorted - i.e.,
        /// V_sorted[(N-1)/2], when N is odd and the average of the two
        /// middle values of V_sorted when N is even.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the medians are computed. The default
        /// is to compute the median along a flattened version of the array.
        /// A sequence of axes is supported since version 1.9.0.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow use of memory of input array a for
        /// calculations. The input array will be modified by the call to
        /// median. This will save memory when you do not need to preserve
        /// the contents of the input array. Treat the input as undefined,
        /// but it will probably be fully or partially sorted. Default is
        /// False. If overwrite_input is True and a is not already an
        /// ndarray, an error will be raised.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// 
        /// If this is anything but the default value it will be passed
        /// through (in the special case of an empty array) to the
        /// mean function of the underlying array.  If the array is
        /// a sub-class and mean does not have the kwarg keepdims this
        /// will raise a RuntimeError.
        /// </param>
        /// <returns>
        /// A new array holding the result. If the input contains integers
        /// or floats smaller than float64, then the output data-type is
        /// np.float64.  Otherwise, the data-type of the output is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public NDarray<double> nanmedian(int[] axis, NDarray @out = null, bool? overwrite_input = false, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanmedian(@this, axis:axis, @out:@out, overwrite_input:overwrite_input, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the median along the specified axis, while ignoring NaNs.
        /// 
        /// Returns the median of the array elements.
        /// 
        /// Notes
        /// 
        /// Given a vector V of length N, the median of V is the
        /// middle value of a sorted copy of V, V_sorted - i.e.,
        /// V_sorted[(N-1)/2], when N is odd and the average of the two
        /// middle values of V_sorted when N is even.
        /// </summary>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must
        /// have the same shape and buffer length as the expected output,
        /// but the type (of the output) will be cast if necessary.
        /// </param>
        /// <param name="overwrite_input">
        /// If True, then allow use of memory of input array a for
        /// calculations. The input array will be modified by the call to
        /// median. This will save memory when you do not need to preserve
        /// the contents of the input array. Treat the input as undefined,
        /// but it will probably be fully or partially sorted. Default is
        /// False. If overwrite_input is True and a is not already an
        /// ndarray, an error will be raised.
        /// </param>
        /// <returns>
        /// A new array holding the result. If the input contains integers
        /// or floats smaller than float64, then the output data-type is
        /// np.float64.  Otherwise, the data-type of the output is the
        /// same as that of the input. If out is specified, that array is
        /// returned instead.
        /// </returns>
        public double nanmedian(NDarray @out = null, bool? overwrite_input = false)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanmedian(@this, @out:@out, overwrite_input:overwrite_input);
        }
        
        /// <summary>
        /// Compute the arithmetic mean along the specified axis, ignoring NaNs.
        /// 
        /// Returns the average of the array elements.  The average is taken over
        /// the flattened array by default, otherwise over the specified axis.
        /// float64 intermediate and return values are used for integer inputs.
        /// 
        /// For all-NaN slices, NaN is returned and a RuntimeWarning is raised.
        /// 
        /// Notes
        /// 
        /// The arithmetic mean is the sum of the non-NaN elements along the axis
        /// divided by the number of non-NaN elements.
        /// 
        /// Note that for floating-point input, the mean is computed using the same
        /// precision the input has.  Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32.  Specifying a
        /// higher-precision accumulator using the dtype keyword can alleviate
        /// this issue.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the means are computed. The default is to compute
        /// the mean of the flattened array.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the mean.  For integer inputs, the default
        /// is float64; for inexact inputs, it is the same as the input
        /// dtype.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None; if provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.  See
        /// doc.ufuncs for details.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// 
        /// If the value is anything but the default, then
        /// keepdims will be passed through to the mean or sum methods
        /// of sub-classes of ndarray.  If the sub-classes methods
        /// does not implement keepdims any exceptions will be raised.
        /// </param>
        /// <returns>
        /// If out=None, returns a new array containing the mean values,
        /// otherwise a reference to the output array is returned. Nan is
        /// returned for slices that contain only NaNs.
        /// </returns>
        public NDarray<double> nanmean(int[] axis, Dtype dtype = null, NDarray @out = null, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanmean(@this, axis:axis, dtype:dtype, @out:@out, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the arithmetic mean along the specified axis, ignoring NaNs.
        /// 
        /// Returns the average of the array elements.  The average is taken over
        /// the flattened array by default, otherwise over the specified axis.
        /// float64 intermediate and return values are used for integer inputs.
        /// 
        /// For all-NaN slices, NaN is returned and a RuntimeWarning is raised.
        /// 
        /// Notes
        /// 
        /// The arithmetic mean is the sum of the non-NaN elements along the axis
        /// divided by the number of non-NaN elements.
        /// 
        /// Note that for floating-point input, the mean is computed using the same
        /// precision the input has.  Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32.  Specifying a
        /// higher-precision accumulator using the dtype keyword can alleviate
        /// this issue.
        /// </summary>
        /// <param name="dtype">
        /// Type to use in computing the mean.  For integer inputs, the default
        /// is float64; for inexact inputs, it is the same as the input
        /// dtype.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  The default
        /// is None; if provided, it must have the same shape as the
        /// expected output, but the type will be cast if necessary.  See
        /// doc.ufuncs for details.
        /// </param>
        /// <returns>
        /// If out=None, returns a new array containing the mean values,
        /// otherwise a reference to the output array is returned. Nan is
        /// returned for slices that contain only NaNs.
        /// </returns>
        public double nanmean(Dtype dtype = null, NDarray @out = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanmean(@this, dtype:dtype, @out:@out);
        }
        
        /// <summary>
        /// Compute the standard deviation along the specified axis, while
        /// ignoring NaNs.
        /// 
        /// Returns the standard deviation, a measure of the spread of a
        /// distribution, of the non-NaN array elements. The standard deviation is
        /// computed for the flattened array by default, otherwise over the
        /// specified axis.
        /// 
        /// For all-NaN slices or slices with zero degrees of freedom, NaN is
        /// returned and a RuntimeWarning is raised.
        /// 
        /// Notes
        /// 
        /// The standard deviation is the square root of the average of the squared
        /// deviations from the mean: std = sqrt(mean(abs(x - x.mean())**2)).
        /// 
        /// The average squared deviation is normally calculated as
        /// x.sum() / N, where N = len(x).  If, however, ddof is
        /// specified, the divisor N - ddof is used instead. In standard
        /// statistical practice, ddof=1 provides an unbiased estimator of the
        /// variance of the infinite population. ddof=0 provides a maximum
        /// likelihood estimate of the variance for normally distributed variables.
        /// The standard deviation computed in this function is the square root of
        /// the estimated variance, so even with ddof=1, it will not be an
        /// unbiased estimate of the standard deviation per se.
        /// 
        /// Note that, for complex numbers, std takes the absolute value before
        /// squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the std is computed using the same
        /// precision the input has. Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example
        /// below).  Specifying a higher-accuracy accumulator using the dtype
        /// keyword can alleviate this issue.
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the standard deviation is computed. The default is
        /// to compute the standard deviation of the flattened array.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the standard deviation. For arrays of
        /// integer type the default is float64, for arrays of float types it
        /// is the same as the array type.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output but the type (of the
        /// calculated values) will be cast if necessary.
        /// </param>
        /// <param name="ddof">
        /// Means Delta Degrees of Freedom.  The divisor used in calculations
        /// is N - ddof, where N represents the number of non-NaN
        /// elements.  By default ddof is zero.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// 
        /// If this value is anything but the default it is passed through
        /// as-is to the relevant functions of the sub-classes.  If these
        /// functions do not have a keepdims kwarg, a RuntimeError will
        /// be raised.
        /// </param>
        /// <returns>
        /// If out is None, return a new array containing the standard
        /// deviation, otherwise return a reference to the output array. If
        /// ddof is &gt;= the number of non-NaN elements in a slice or the slice
        /// contains only NaNs, then the result for that slice is NaN.
        /// </returns>
        public NDarray<double> nanstd(int[] axis, Dtype dtype = null, NDarray @out = null, int? ddof = 0, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanstd(@this, axis:axis, dtype:dtype, @out:@out, ddof:ddof, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the standard deviation along the specified axis, while
        /// ignoring NaNs.
        /// 
        /// Returns the standard deviation, a measure of the spread of a
        /// distribution, of the non-NaN array elements. The standard deviation is
        /// computed for the flattened array by default, otherwise over the
        /// specified axis.
        /// 
        /// For all-NaN slices or slices with zero degrees of freedom, NaN is
        /// returned and a RuntimeWarning is raised.
        /// 
        /// Notes
        /// 
        /// The standard deviation is the square root of the average of the squared
        /// deviations from the mean: std = sqrt(mean(abs(x - x.mean())**2)).
        /// 
        /// The average squared deviation is normally calculated as
        /// x.sum() / N, where N = len(x).  If, however, ddof is
        /// specified, the divisor N - ddof is used instead. In standard
        /// statistical practice, ddof=1 provides an unbiased estimator of the
        /// variance of the infinite population. ddof=0 provides a maximum
        /// likelihood estimate of the variance for normally distributed variables.
        /// The standard deviation computed in this function is the square root of
        /// the estimated variance, so even with ddof=1, it will not be an
        /// unbiased estimate of the standard deviation per se.
        /// 
        /// Note that, for complex numbers, std takes the absolute value before
        /// squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the std is computed using the same
        /// precision the input has. Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example
        /// below).  Specifying a higher-accuracy accumulator using the dtype
        /// keyword can alleviate this issue.
        /// </summary>
        /// <param name="dtype">
        /// Type to use in computing the standard deviation. For arrays of
        /// integer type the default is float64, for arrays of float types it
        /// is the same as the array type.
        /// </param>
        /// <param name="@out">
        /// Alternative output array in which to place the result. It must have
        /// the same shape as the expected output but the type (of the
        /// calculated values) will be cast if necessary.
        /// </param>
        /// <param name="ddof">
        /// Means Delta Degrees of Freedom.  The divisor used in calculations
        /// is N - ddof, where N represents the number of non-NaN
        /// elements.  By default ddof is zero.
        /// </param>
        /// <returns>
        /// If out is None, return a new array containing the standard
        /// deviation, otherwise return a reference to the output array. If
        /// ddof is &gt;= the number of non-NaN elements in a slice or the slice
        /// contains only NaNs, then the result for that slice is NaN.
        /// </returns>
        public double nanstd(Dtype dtype = null, NDarray @out = null, int? ddof = 0)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanstd(@this, dtype:dtype, @out:@out, ddof:ddof);
        }
        
        /// <summary>
        /// Compute the variance along the specified axis, while ignoring NaNs.
        /// 
        /// Returns the variance of the array elements, a measure of the spread of
        /// a distribution.  The variance is computed for the flattened array by
        /// default, otherwise over the specified axis.
        /// 
        /// For all-NaN slices or slices with zero degrees of freedom, NaN is
        /// returned and a RuntimeWarning is raised.
        /// 
        /// Notes
        /// 
        /// The variance is the average of the squared deviations from the mean,
        /// i.e.,  var = mean(abs(x - x.mean())**2).
        /// 
        /// The mean is normally calculated as x.sum() / N, where N = len(x).
        /// If, however, ddof is specified, the divisor N - ddof is used
        /// instead.  In standard statistical practice, ddof=1 provides an
        /// unbiased estimator of the variance of a hypothetical infinite
        /// population.  ddof=0 provides a maximum likelihood estimate of the
        /// variance for normally distributed variables.
        /// 
        /// Note that for complex numbers, the absolute value is taken before
        /// squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the variance is computed using the same
        /// precision the input has.  Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example
        /// below).  Specifying a higher-accuracy accumulator using the dtype
        /// keyword can alleviate this issue.
        /// 
        /// For this function to work on sub-classes of ndarray, they must define
        /// sum with the kwarg keepdims
        /// </summary>
        /// <param name="axis">
        /// Axis or axes along which the variance is computed.  The default is to compute
        /// the variance of the flattened array.
        /// </param>
        /// <param name="dtype">
        /// Type to use in computing the variance.  For arrays of integer type
        /// the default is float32; for arrays of float types it is the same as
        /// the array type.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  It must have
        /// the same shape as the expected output, but the type is cast if
        /// necessary.
        /// </param>
        /// <param name="ddof">
        /// “Delta Degrees of Freedom”: the divisor used in the calculation is
        /// N - ddof, where N represents the number of non-NaN
        /// elements. By default ddof is zero.
        /// </param>
        /// <param name="keepdims">
        /// If this is set to True, the axes which are reduced are left
        /// in the result as dimensions with size one. With this option,
        /// the result will broadcast correctly against the original a.
        /// </param>
        /// <returns>
        /// If out is None, return a new array containing the variance,
        /// otherwise return a reference to the output array. If ddof is &gt;= the
        /// number of non-NaN elements in a slice or the slice contains only
        /// NaNs, then the result for that slice is NaN.
        /// </returns>
        public NDarray<double> nanvar(int[] axis, Dtype dtype = null, NDarray @out = null, int? ddof = 0, bool? keepdims = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanvar(@this, axis:axis, dtype:dtype, @out:@out, ddof:ddof, keepdims:keepdims);
        }
        
        /// <summary>
        /// Compute the variance along the specified axis, while ignoring NaNs.
        /// 
        /// Returns the variance of the array elements, a measure of the spread of
        /// a distribution.  The variance is computed for the flattened array by
        /// default, otherwise over the specified axis.
        /// 
        /// For all-NaN slices or slices with zero degrees of freedom, NaN is
        /// returned and a RuntimeWarning is raised.
        /// 
        /// Notes
        /// 
        /// The variance is the average of the squared deviations from the mean,
        /// i.e.,  var = mean(abs(x - x.mean())**2).
        /// 
        /// The mean is normally calculated as x.sum() / N, where N = len(x).
        /// If, however, ddof is specified, the divisor N - ddof is used
        /// instead.  In standard statistical practice, ddof=1 provides an
        /// unbiased estimator of the variance of a hypothetical infinite
        /// population.  ddof=0 provides a maximum likelihood estimate of the
        /// variance for normally distributed variables.
        /// 
        /// Note that for complex numbers, the absolute value is taken before
        /// squaring, so that the result is always real and nonnegative.
        /// 
        /// For floating-point input, the variance is computed using the same
        /// precision the input has.  Depending on the input data, this can cause
        /// the results to be inaccurate, especially for float32 (see example
        /// below).  Specifying a higher-accuracy accumulator using the dtype
        /// keyword can alleviate this issue.
        /// 
        /// For this function to work on sub-classes of ndarray, they must define
        /// sum with the kwarg keepdims
        /// </summary>
        /// <param name="dtype">
        /// Type to use in computing the variance.  For arrays of integer type
        /// the default is float32; for arrays of float types it is the same as
        /// the array type.
        /// </param>
        /// <param name="@out">
        /// Alternate output array in which to place the result.  It must have
        /// the same shape as the expected output, but the type is cast if
        /// necessary.
        /// </param>
        /// <param name="ddof">
        /// “Delta Degrees of Freedom”: the divisor used in the calculation is
        /// N - ddof, where N represents the number of non-NaN
        /// elements. By default ddof is zero.
        /// </param>
        /// <returns>
        /// If out is None, return a new array containing the variance,
        /// otherwise return a reference to the output array. If ddof is &gt;= the
        /// number of non-NaN elements in a slice or the slice contains only
        /// NaNs, then the result for that slice is NaN.
        /// </returns>
        public double nanvar(Dtype dtype = null, NDarray @out = null, int? ddof = 0)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.nanvar(@this, dtype:dtype, @out:@out, ddof:ddof);
        }
        
        /// <summary>
        /// Return Pearson product-moment correlation coefficients.
        /// 
        /// Please refer to the documentation for cov for more detail.  The
        /// relationship between the correlation coefficient matrix, R, and the
        /// covariance matrix, C, is
        /// 
        /// The values of R are between -1 and 1, inclusive.
        /// 
        /// Notes
        /// 
        /// Due to floating point rounding the resulting array may not be Hermitian,
        /// the diagonal elements may not be 1, and the elements may not satisfy the
        /// inequality abs(a) &lt;= 1. The real and imaginary parts are clipped to the
        /// interval [-1,  1] in an attempt to improve on that situation but is not
        /// much help in the complex case.
        /// 
        /// This function accepts but discards arguments bias and ddof.  This is
        /// for backwards compatibility with previous versions of this function.  These
        /// arguments had no effect on the return values of the function and can be
        /// safely ignored in this and previous versions of numpy.
        /// </summary>
        /// <param name="y">
        /// An additional set of variables and observations. y has the same
        /// shape as x.
        /// </param>
        /// <param name="rowvar">
        /// If rowvar is True (default), then each row represents a
        /// variable, with observations in the columns. Otherwise, the relationship
        /// is transposed: each column represents a variable, while the rows
        /// contain observations.
        /// </param>
        /// <returns>
        /// The correlation coefficient matrix of the variables.
        /// </returns>
        public NDarray corrcoef(NDarray y = null, bool? rowvar = true)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.corrcoef(@this, y:y, rowvar:rowvar);
        }
        
        /// <summary>
        /// Cross-correlation of two 1-dimensional sequences.
        /// 
        /// This function computes the correlation as generally defined in signal
        /// processing texts:
        /// 
        /// with a and v sequences being zero-padded where necessary and conj being
        /// the conjugate.
        /// 
        /// Notes
        /// 
        /// The definition of correlation above is not unique and sometimes correlation
        /// may be defined differently. Another common definition is:
        /// 
        /// which is related to c_{av}[k] by c'_{av}[k] = c_{av}[-k].
        /// </summary>
        /// <param name="a">
        /// Input sequences.
        /// </param>
        /// <param name="mode">
        /// Refer to the convolve docstring.  Note that the default
        /// is ‘valid’, unlike convolve, which uses ‘full’.
        /// </param>
        /// <returns>
        /// Discrete cross-correlation of a and v.
        /// </returns>
        public NDarray correlate(NDarray a, string mode = "valid")
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.correlate(@this, a, mode:mode);
        }
        
        /// <summary>
        /// Estimate a covariance matrix, given data and weights.
        /// 
        /// Covariance indicates the level to which two variables vary together.
        /// If we examine N-dimensional samples, ,
        /// then the covariance matrix element  is the covariance of
        ///  and . The element  is the variance
        /// of .
        /// 
        /// See the notes for an outline of the algorithm.
        /// 
        /// Notes
        /// 
        /// Assume that the observations are in the columns of the observation
        /// array m and let f = fweights and a = aweights for brevity. The
        /// steps to compute the weighted covariance are as follows:
        /// 
        /// Note that when a == 1, the normalization factor
        /// v1 / (v1**2 - ddof * v2) goes over to 1 / (np.sum(f) - ddof)
        /// as it should.
        /// </summary>
        /// <param name="y">
        /// An additional set of variables and observations. y has the same form
        /// as that of m.
        /// </param>
        /// <param name="rowvar">
        /// If rowvar is True (default), then each row represents a
        /// variable, with observations in the columns. Otherwise, the relationship
        /// is transposed: each column represents a variable, while the rows
        /// contain observations.
        /// </param>
        /// <param name="bias">
        /// Default normalization (False) is by (N - 1), where N is the
        /// number of observations given (unbiased estimate). If bias is True,
        /// then normalization is by N. These values can be overridden by using
        /// the keyword ddof in numpy versions &gt;= 1.5.
        /// </param>
        /// <param name="ddof">
        /// If not None the default value implied by bias is overridden.
        /// Note that ddof=1 will return the unbiased estimate, even if both
        /// fweights and aweights are specified, and ddof=0 will return
        /// the simple average. See the notes for the details. The default value
        /// is None.
        /// </param>
        /// <param name="fweights">
        /// 1-D array of integer frequency weights; the number of times each
        /// observation vector should be repeated.
        /// </param>
        /// <param name="aweights">
        /// 1-D array of observation vector weights. These relative weights are
        /// typically large for observations considered “important” and smaller for
        /// observations considered less “important”. If ddof=0 the array of
        /// weights can be used to assign probabilities to observation vectors.
        /// </param>
        /// <returns>
        /// The covariance matrix of the variables.
        /// </returns>
        public NDarray cov(NDarray y = null, bool? rowvar = true, bool? bias = false, int? ddof = null, NDarray fweights = null, NDarray aweights = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.cov(@this, y:y, rowvar:rowvar, bias:bias, ddof:ddof, fweights:fweights, aweights:aweights);
        }
        
        /// <summary>
        /// Compute the histogram of a set of data.
        /// 
        /// Notes
        /// 
        /// All but the last (righthand-most) bin is half-open.  In other words,
        /// if bins is:
        /// 
        /// then the first bin is [1, 2) (including 1, but excluding 2) and
        /// the second [2, 3).  The last bin, however, is [3, 4], which
        /// includes 4.
        /// </summary>
        /// <param name="bins">
        /// If bins is an int, it defines the number of equal-width
        /// bins in the given range (10, by default). If bins is a
        /// sequence, it defines a monotonically increasing array of bin edges,
        /// including the rightmost edge, allowing for non-uniform bin widths.
        /// 
        /// If bins is a string, it defines the method used to calculate the
        /// optimal bin width, as defined by histogram_bin_edges.
        /// </param>
        /// <param name="range">
        /// The lower and upper range of the bins.  If not provided, range
        /// is simply (a.min(), a.max()).  Values outside the range are
        /// ignored. The first element of the range must be less than or
        /// equal to the second. range affects the automatic bin
        /// computation as well. While bin width is computed to be optimal
        /// based on the actual data within range, the bin count will fill
        /// the entire range including portions containing no data.
        /// </param>
        /// <param name="normed">
        /// This is equivalent to the density argument, but produces incorrect
        /// results for unequal bin widths. It should not be used.
        /// </param>
        /// <param name="weights">
        /// An array of weights, of the same shape as a.  Each value in
        /// a only contributes its associated weight towards the bin count
        /// (instead of 1). If density is True, the weights are
        /// normalized, so that the integral of the density over the range
        /// remains 1.
        /// </param>
        /// <param name="density">
        /// If False, the result will contain the number of samples in
        /// each bin. If True, the result is the value of the
        /// probability density function at the bin, normalized such that
        /// the integral over the range is 1. Note that the sum of the
        /// histogram values will not be equal to 1 unless bins of unity
        /// width are chosen; it is not a probability mass function.
        /// 
        /// Overrides the normed keyword if given.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// hist
        /// The values of the histogram. See density and weights for a
        /// description of the possible semantics.
        /// bin_edges
        /// Return the bin edges (length(hist)+1).
        /// </returns>
        public (NDarray, NDarray) histogram(int? bins = null, (float, float)? range = null, bool? normed = null, NDarray weights = null, bool? density = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogram(@this, bins:bins, range:range, normed:normed, weights:weights, density:density);
        }
        
        /// <summary>
        /// Compute the histogram of a set of data.
        /// 
        /// Notes
        /// 
        /// All but the last (righthand-most) bin is half-open.  In other words,
        /// if bins is:
        /// 
        /// then the first bin is [1, 2) (including 1, but excluding 2) and
        /// the second [2, 3).  The last bin, however, is [3, 4], which
        /// includes 4.
        /// </summary>
        /// <param name="bins">
        /// If bins is an int, it defines the number of equal-width
        /// bins in the given range (10, by default). If bins is a
        /// sequence, it defines a monotonically increasing array of bin edges,
        /// including the rightmost edge, allowing for non-uniform bin widths.
        /// 
        /// If bins is a string, it defines the method used to calculate the
        /// optimal bin width, as defined by histogram_bin_edges.
        /// </param>
        /// <param name="range">
        /// The lower and upper range of the bins.  If not provided, range
        /// is simply (a.min(), a.max()).  Values outside the range are
        /// ignored. The first element of the range must be less than or
        /// equal to the second. range affects the automatic bin
        /// computation as well. While bin width is computed to be optimal
        /// based on the actual data within range, the bin count will fill
        /// the entire range including portions containing no data.
        /// </param>
        /// <param name="normed">
        /// This is equivalent to the density argument, but produces incorrect
        /// results for unequal bin widths. It should not be used.
        /// </param>
        /// <param name="weights">
        /// An array of weights, of the same shape as a.  Each value in
        /// a only contributes its associated weight towards the bin count
        /// (instead of 1). If density is True, the weights are
        /// normalized, so that the integral of the density over the range
        /// remains 1.
        /// </param>
        /// <param name="density">
        /// If False, the result will contain the number of samples in
        /// each bin. If True, the result is the value of the
        /// probability density function at the bin, normalized such that
        /// the integral over the range is 1. Note that the sum of the
        /// histogram values will not be equal to 1 unless bins of unity
        /// width are chosen; it is not a probability mass function.
        /// 
        /// Overrides the normed keyword if given.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// hist
        /// The values of the histogram. See density and weights for a
        /// description of the possible semantics.
        /// bin_edges
        /// Return the bin edges (length(hist)+1).
        /// </returns>
        public (NDarray, NDarray) histogram(NDarray bins = null, (float, float)? range = null, bool? normed = null, NDarray weights = null, bool? density = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogram(@this, bins:bins, range:range, normed:normed, weights:weights, density:density);
        }
        
        /// <summary>
        /// Compute the histogram of a set of data.
        /// 
        /// Notes
        /// 
        /// All but the last (righthand-most) bin is half-open.  In other words,
        /// if bins is:
        /// 
        /// then the first bin is [1, 2) (including 1, but excluding 2) and
        /// the second [2, 3).  The last bin, however, is [3, 4], which
        /// includes 4.
        /// </summary>
        /// <param name="bins">
        /// If bins is an int, it defines the number of equal-width
        /// bins in the given range (10, by default). If bins is a
        /// sequence, it defines a monotonically increasing array of bin edges,
        /// including the rightmost edge, allowing for non-uniform bin widths.
        /// 
        /// If bins is a string, it defines the method used to calculate the
        /// optimal bin width, as defined by histogram_bin_edges.
        /// </param>
        /// <param name="range">
        /// The lower and upper range of the bins.  If not provided, range
        /// is simply (a.min(), a.max()).  Values outside the range are
        /// ignored. The first element of the range must be less than or
        /// equal to the second. range affects the automatic bin
        /// computation as well. While bin width is computed to be optimal
        /// based on the actual data within range, the bin count will fill
        /// the entire range including portions containing no data.
        /// </param>
        /// <param name="normed">
        /// This is equivalent to the density argument, but produces incorrect
        /// results for unequal bin widths. It should not be used.
        /// </param>
        /// <param name="weights">
        /// An array of weights, of the same shape as a.  Each value in
        /// a only contributes its associated weight towards the bin count
        /// (instead of 1). If density is True, the weights are
        /// normalized, so that the integral of the density over the range
        /// remains 1.
        /// </param>
        /// <param name="density">
        /// If False, the result will contain the number of samples in
        /// each bin. If True, the result is the value of the
        /// probability density function at the bin, normalized such that
        /// the integral over the range is 1. Note that the sum of the
        /// histogram values will not be equal to 1 unless bins of unity
        /// width are chosen; it is not a probability mass function.
        /// 
        /// Overrides the normed keyword if given.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// hist
        /// The values of the histogram. See density and weights for a
        /// description of the possible semantics.
        /// bin_edges
        /// Return the bin edges (length(hist)+1).
        /// </returns>
        public (NDarray, NDarray) histogram(List<string> bins = null, (float, float)? range = null, bool? normed = null, NDarray weights = null, bool? density = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogram(@this, bins:bins, range:range, normed:normed, weights:weights, density:density);
        }
        
        /// <summary>
        /// Compute the bi-dimensional histogram of two data samples.
        /// 
        /// Notes
        /// 
        /// When normed is True, then the returned histogram is the sample
        /// density, defined such that the sum over bins of the product
        /// bin_value * bin_area is 1.
        /// 
        /// Please note that the histogram does not follow the Cartesian convention
        /// where x values are on the abscissa and y values on the ordinate
        /// axis.  Rather, x is histogrammed along the first dimension of the
        /// array (vertical), and y along the second dimension of the array
        /// (horizontal).  This ensures compatibility with histogramdd.
        /// </summary>
        /// <param name="y">
        /// An array containing the y coordinates of the points to be
        /// histogrammed.
        /// </param>
        /// <param name="bins">
        /// The bin specification:
        /// </param>
        /// <param name="range">
        /// The leftmost and rightmost edges of the bins along each dimension
        /// (if not specified explicitly in the bins parameters):
        /// [[xmin, xmax], [ymin, ymax]]. All values outside of this range
        /// will be considered outliers and not tallied in the histogram.
        /// </param>
        /// <param name="density">
        /// If False, the default, returns the number of samples in each bin.
        /// If True, returns the probability density function at the bin,
        /// bin_count / sample_count / bin_area.
        /// </param>
        /// <param name="normed">
        /// An alias for the density argument that behaves identically. To avoid
        /// confusion with the broken normed argument to histogram, density
        /// should be preferred.
        /// </param>
        /// <param name="weights">
        /// An array of values w_i weighing each sample (x_i, y_i).
        /// Weights are normalized to 1 if normed is True. If normed is
        /// False, the values of the returned histogram are equal to the sum of
        /// the weights belonging to the samples falling into each bin.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// H
        /// The bi-dimensional histogram of samples x and y. Values in x
        /// are histogrammed along the first dimension and values in y are
        /// histogrammed along the second dimension.
        /// xedges
        /// The bin edges along the first dimension.
        /// yedges
        /// The bin edges along the second dimension.
        /// </returns>
        public (NDarray, NDarray, NDarray) histogram2d(NDarray y, int? bins = null, (float, float)? range = null, bool? density = null, bool? normed = null, NDarray weights = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogram2d(@this, y, bins:bins, range:range, density:density, normed:normed, weights:weights);
        }
        
        /// <summary>
        /// Compute the bi-dimensional histogram of two data samples.
        /// 
        /// Notes
        /// 
        /// When normed is True, then the returned histogram is the sample
        /// density, defined such that the sum over bins of the product
        /// bin_value * bin_area is 1.
        /// 
        /// Please note that the histogram does not follow the Cartesian convention
        /// where x values are on the abscissa and y values on the ordinate
        /// axis.  Rather, x is histogrammed along the first dimension of the
        /// array (vertical), and y along the second dimension of the array
        /// (horizontal).  This ensures compatibility with histogramdd.
        /// </summary>
        /// <param name="y">
        /// An array containing the y coordinates of the points to be
        /// histogrammed.
        /// </param>
        /// <param name="bins">
        /// The bin specification:
        /// </param>
        /// <param name="range">
        /// The leftmost and rightmost edges of the bins along each dimension
        /// (if not specified explicitly in the bins parameters):
        /// [[xmin, xmax], [ymin, ymax]]. All values outside of this range
        /// will be considered outliers and not tallied in the histogram.
        /// </param>
        /// <param name="density">
        /// If False, the default, returns the number of samples in each bin.
        /// If True, returns the probability density function at the bin,
        /// bin_count / sample_count / bin_area.
        /// </param>
        /// <param name="normed">
        /// An alias for the density argument that behaves identically. To avoid
        /// confusion with the broken normed argument to histogram, density
        /// should be preferred.
        /// </param>
        /// <param name="weights">
        /// An array of values w_i weighing each sample (x_i, y_i).
        /// Weights are normalized to 1 if normed is True. If normed is
        /// False, the values of the returned histogram are equal to the sum of
        /// the weights belonging to the samples falling into each bin.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// H
        /// The bi-dimensional histogram of samples x and y. Values in x
        /// are histogrammed along the first dimension and values in y are
        /// histogrammed along the second dimension.
        /// xedges
        /// The bin edges along the first dimension.
        /// yedges
        /// The bin edges along the second dimension.
        /// </returns>
        public (NDarray, NDarray, NDarray) histogram2d(NDarray y, NDarray bins = null, (float, float)? range = null, bool? density = null, bool? normed = null, NDarray weights = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogram2d(@this, y, bins:bins, range:range, density:density, normed:normed, weights:weights);
        }
        
        /// <summary>
        /// Compute the bi-dimensional histogram of two data samples.
        /// 
        /// Notes
        /// 
        /// When normed is True, then the returned histogram is the sample
        /// density, defined such that the sum over bins of the product
        /// bin_value * bin_area is 1.
        /// 
        /// Please note that the histogram does not follow the Cartesian convention
        /// where x values are on the abscissa and y values on the ordinate
        /// axis.  Rather, x is histogrammed along the first dimension of the
        /// array (vertical), and y along the second dimension of the array
        /// (horizontal).  This ensures compatibility with histogramdd.
        /// </summary>
        /// <param name="y">
        /// An array containing the y coordinates of the points to be
        /// histogrammed.
        /// </param>
        /// <param name="bins">
        /// The bin specification:
        /// </param>
        /// <param name="range">
        /// The leftmost and rightmost edges of the bins along each dimension
        /// (if not specified explicitly in the bins parameters):
        /// [[xmin, xmax], [ymin, ymax]]. All values outside of this range
        /// will be considered outliers and not tallied in the histogram.
        /// </param>
        /// <param name="density">
        /// If False, the default, returns the number of samples in each bin.
        /// If True, returns the probability density function at the bin,
        /// bin_count / sample_count / bin_area.
        /// </param>
        /// <param name="normed">
        /// An alias for the density argument that behaves identically. To avoid
        /// confusion with the broken normed argument to histogram, density
        /// should be preferred.
        /// </param>
        /// <param name="weights">
        /// An array of values w_i weighing each sample (x_i, y_i).
        /// Weights are normalized to 1 if normed is True. If normed is
        /// False, the values of the returned histogram are equal to the sum of
        /// the weights belonging to the samples falling into each bin.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// H
        /// The bi-dimensional histogram of samples x and y. Values in x
        /// are histogrammed along the first dimension and values in y are
        /// histogrammed along the second dimension.
        /// xedges
        /// The bin edges along the first dimension.
        /// yedges
        /// The bin edges along the second dimension.
        /// </returns>
        public (NDarray, NDarray, NDarray) histogram2d(NDarray y, List<string> bins = null, (float, float)? range = null, bool? density = null, bool? normed = null, NDarray weights = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogram2d(@this, y, bins:bins, range:range, density:density, normed:normed, weights:weights);
        }
        
        /// <summary>
        /// Compute the multidimensional histogram of some data.
        /// </summary>
        /// <param name="bins">
        /// The bin specification:
        /// </param>
        /// <param name="range">
        /// A sequence of length D, each an optional (lower, upper) tuple giving
        /// the outer bin edges to be used if the edges are not given explicitly in
        /// bins.
        /// An entry of None in the sequence results in the minimum and maximum
        /// values being used for the corresponding dimension.
        /// The default, None, is equivalent to passing a tuple of D None values.
        /// </param>
        /// <param name="density">
        /// If False, the default, returns the number of samples in each bin.
        /// If True, returns the probability density function at the bin,
        /// bin_count / sample_count / bin_volume.
        /// </param>
        /// <param name="normed">
        /// An alias for the density argument that behaves identically. To avoid
        /// confusion with the broken normed argument to histogram, density
        /// should be preferred.
        /// </param>
        /// <param name="weights">
        /// An array of values w_i weighing each sample (x_i, y_i, z_i, …).
        /// Weights are normalized to 1 if normed is True. If normed is False,
        /// the values of the returned histogram are equal to the sum of the
        /// weights belonging to the samples falling into each bin.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// H
        /// The multidimensional histogram of sample x. See normed and weights
        /// for the different possible semantics.
        /// edges
        /// A list of D arrays describing the bin edges for each dimension.
        /// </returns>
        public (NDarray, NDarray) histogramdd(int? bins = null, (float, float)? range = null, bool? density = null, bool? normed = null, NDarray weights = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogramdd(@this, bins:bins, range:range, density:density, normed:normed, weights:weights);
        }
        
        /// <summary>
        /// Compute the multidimensional histogram of some data.
        /// </summary>
        /// <param name="bins">
        /// The bin specification:
        /// </param>
        /// <param name="range">
        /// A sequence of length D, each an optional (lower, upper) tuple giving
        /// the outer bin edges to be used if the edges are not given explicitly in
        /// bins.
        /// An entry of None in the sequence results in the minimum and maximum
        /// values being used for the corresponding dimension.
        /// The default, None, is equivalent to passing a tuple of D None values.
        /// </param>
        /// <param name="density">
        /// If False, the default, returns the number of samples in each bin.
        /// If True, returns the probability density function at the bin,
        /// bin_count / sample_count / bin_volume.
        /// </param>
        /// <param name="normed">
        /// An alias for the density argument that behaves identically. To avoid
        /// confusion with the broken normed argument to histogram, density
        /// should be preferred.
        /// </param>
        /// <param name="weights">
        /// An array of values w_i weighing each sample (x_i, y_i, z_i, …).
        /// Weights are normalized to 1 if normed is True. If normed is False,
        /// the values of the returned histogram are equal to the sum of the
        /// weights belonging to the samples falling into each bin.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// H
        /// The multidimensional histogram of sample x. See normed and weights
        /// for the different possible semantics.
        /// edges
        /// A list of D arrays describing the bin edges for each dimension.
        /// </returns>
        public (NDarray, NDarray) histogramdd(NDarray bins = null, (float, float)? range = null, bool? density = null, bool? normed = null, NDarray weights = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogramdd(@this, bins:bins, range:range, density:density, normed:normed, weights:weights);
        }
        
        /// <summary>
        /// Compute the multidimensional histogram of some data.
        /// </summary>
        /// <param name="bins">
        /// The bin specification:
        /// </param>
        /// <param name="range">
        /// A sequence of length D, each an optional (lower, upper) tuple giving
        /// the outer bin edges to be used if the edges are not given explicitly in
        /// bins.
        /// An entry of None in the sequence results in the minimum and maximum
        /// values being used for the corresponding dimension.
        /// The default, None, is equivalent to passing a tuple of D None values.
        /// </param>
        /// <param name="density">
        /// If False, the default, returns the number of samples in each bin.
        /// If True, returns the probability density function at the bin,
        /// bin_count / sample_count / bin_volume.
        /// </param>
        /// <param name="normed">
        /// An alias for the density argument that behaves identically. To avoid
        /// confusion with the broken normed argument to histogram, density
        /// should be preferred.
        /// </param>
        /// <param name="weights">
        /// An array of values w_i weighing each sample (x_i, y_i, z_i, …).
        /// Weights are normalized to 1 if normed is True. If normed is False,
        /// the values of the returned histogram are equal to the sum of the
        /// weights belonging to the samples falling into each bin.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// H
        /// The multidimensional histogram of sample x. See normed and weights
        /// for the different possible semantics.
        /// edges
        /// A list of D arrays describing the bin edges for each dimension.
        /// </returns>
        public (NDarray, NDarray) histogramdd(List<string> bins = null, (float, float)? range = null, bool? density = null, bool? normed = null, NDarray weights = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogramdd(@this, bins:bins, range:range, density:density, normed:normed, weights:weights);
        }
        
        /// <summary>
        /// Count number of occurrences of each value in array of non-negative ints.
        /// 
        /// The number of bins (of size 1) is one larger than the largest value in
        /// x. If minlength is specified, there will be at least this number
        /// of bins in the output array (though it will be longer if necessary,
        /// depending on the contents of x).
        /// Each bin gives the number of occurrences of its index value in x.
        /// If weights is specified the input array is weighted by it, i.e. if a
        /// value n is found at position i, out[n] += weight[i] instead
        /// of out[n] += 1.
        /// </summary>
        /// <param name="weights">
        /// Weights, array of the same shape as x.
        /// </param>
        /// <param name="minlength">
        /// A minimum number of bins for the output array.
        /// </param>
        /// <returns>
        /// The result of binning the input array.
        /// The length of out is equal to np.amax(x)+1.
        /// </returns>
        public NDarray bincount(NDarray weights = null, int? minlength = 0)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.bincount(@this, weights:weights, minlength:minlength);
        }
        
        /// <summary>
        /// Function to calculate only the edges of the bins used by the histogram function.
        /// 
        /// Notes
        /// 
        /// The methods to estimate the optimal number of bins are well founded
        /// in literature, and are inspired by the choices R provides for
        /// histogram visualisation. Note that having the number of bins
        /// proportional to  is asymptotically optimal, which is
        /// why it appears in most estimators. These are simply plug-in methods
        /// that give good starting points for number of bins. In the equations
        /// below,  is the binwidth and  is the number of
        /// bins. All estimators that compute bin counts are recast to bin width
        /// using the ptp of the data. The final bin count is obtained from
        /// np.round(np.ceil(range / h)).
        /// </summary>
        /// <param name="bins">
        /// If bins is an int, it defines the number of equal-width
        /// bins in the given range (10, by default). If bins is a
        /// sequence, it defines the bin edges, including the rightmost
        /// edge, allowing for non-uniform bin widths.
        /// 
        /// If bins is a string from the list below, histogram_bin_edges will use
        /// the method chosen to calculate the optimal bin width and
        /// consequently the number of bins (see Notes for more detail on
        /// the estimators) from the data that falls within the requested
        /// range. While the bin width will be optimal for the actual data
        /// in the range, the number of bins will be computed to fill the
        /// entire range, including the empty portions. For visualisation,
        /// using the ‘auto’ option is suggested. Weighted data is not
        /// supported for automated bin size selection.
        /// </param>
        /// <param name="range">
        /// The lower and upper range of the bins.  If not provided, range
        /// is simply (a.min(), a.max()).  Values outside the range are
        /// ignored. The first element of the range must be less than or
        /// equal to the second. range affects the automatic bin
        /// computation as well. While bin width is computed to be optimal
        /// based on the actual data within range, the bin count will fill
        /// the entire range including portions containing no data.
        /// </param>
        /// <param name="weights">
        /// An array of weights, of the same shape as a.  Each value in
        /// a only contributes its associated weight towards the bin count
        /// (instead of 1). This is currently not used by any of the bin estimators,
        /// but may be in the future.
        /// </param>
        /// <returns>
        /// The edges to pass into histogram
        /// </returns>
        public NDarray<float> histogram_bin_edges(int? bins = null, (float, float)? range = null, NDarray weights = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogram_bin_edges(@this, bins:bins, range:range, weights:weights);
        }
        
        /// <summary>
        /// Function to calculate only the edges of the bins used by the histogram function.
        /// 
        /// Notes
        /// 
        /// The methods to estimate the optimal number of bins are well founded
        /// in literature, and are inspired by the choices R provides for
        /// histogram visualisation. Note that having the number of bins
        /// proportional to  is asymptotically optimal, which is
        /// why it appears in most estimators. These are simply plug-in methods
        /// that give good starting points for number of bins. In the equations
        /// below,  is the binwidth and  is the number of
        /// bins. All estimators that compute bin counts are recast to bin width
        /// using the ptp of the data. The final bin count is obtained from
        /// np.round(np.ceil(range / h)).
        /// </summary>
        /// <param name="bins">
        /// If bins is an int, it defines the number of equal-width
        /// bins in the given range (10, by default). If bins is a
        /// sequence, it defines the bin edges, including the rightmost
        /// edge, allowing for non-uniform bin widths.
        /// 
        /// If bins is a string from the list below, histogram_bin_edges will use
        /// the method chosen to calculate the optimal bin width and
        /// consequently the number of bins (see Notes for more detail on
        /// the estimators) from the data that falls within the requested
        /// range. While the bin width will be optimal for the actual data
        /// in the range, the number of bins will be computed to fill the
        /// entire range, including the empty portions. For visualisation,
        /// using the ‘auto’ option is suggested. Weighted data is not
        /// supported for automated bin size selection.
        /// </param>
        /// <param name="range">
        /// The lower and upper range of the bins.  If not provided, range
        /// is simply (a.min(), a.max()).  Values outside the range are
        /// ignored. The first element of the range must be less than or
        /// equal to the second. range affects the automatic bin
        /// computation as well. While bin width is computed to be optimal
        /// based on the actual data within range, the bin count will fill
        /// the entire range including portions containing no data.
        /// </param>
        /// <param name="weights">
        /// An array of weights, of the same shape as a.  Each value in
        /// a only contributes its associated weight towards the bin count
        /// (instead of 1). This is currently not used by any of the bin estimators,
        /// but may be in the future.
        /// </param>
        /// <returns>
        /// The edges to pass into histogram
        /// </returns>
        public NDarray<float> histogram_bin_edges(NDarray bins = null, (float, float)? range = null, NDarray weights = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogram_bin_edges(@this, bins:bins, range:range, weights:weights);
        }
        
        /// <summary>
        /// Function to calculate only the edges of the bins used by the histogram function.
        /// 
        /// Notes
        /// 
        /// The methods to estimate the optimal number of bins are well founded
        /// in literature, and are inspired by the choices R provides for
        /// histogram visualisation. Note that having the number of bins
        /// proportional to  is asymptotically optimal, which is
        /// why it appears in most estimators. These are simply plug-in methods
        /// that give good starting points for number of bins. In the equations
        /// below,  is the binwidth and  is the number of
        /// bins. All estimators that compute bin counts are recast to bin width
        /// using the ptp of the data. The final bin count is obtained from
        /// np.round(np.ceil(range / h)).
        /// </summary>
        /// <param name="bins">
        /// If bins is an int, it defines the number of equal-width
        /// bins in the given range (10, by default). If bins is a
        /// sequence, it defines the bin edges, including the rightmost
        /// edge, allowing for non-uniform bin widths.
        /// 
        /// If bins is a string from the list below, histogram_bin_edges will use
        /// the method chosen to calculate the optimal bin width and
        /// consequently the number of bins (see Notes for more detail on
        /// the estimators) from the data that falls within the requested
        /// range. While the bin width will be optimal for the actual data
        /// in the range, the number of bins will be computed to fill the
        /// entire range, including the empty portions. For visualisation,
        /// using the ‘auto’ option is suggested. Weighted data is not
        /// supported for automated bin size selection.
        /// </param>
        /// <param name="range">
        /// The lower and upper range of the bins.  If not provided, range
        /// is simply (a.min(), a.max()).  Values outside the range are
        /// ignored. The first element of the range must be less than or
        /// equal to the second. range affects the automatic bin
        /// computation as well. While bin width is computed to be optimal
        /// based on the actual data within range, the bin count will fill
        /// the entire range including portions containing no data.
        /// </param>
        /// <param name="weights">
        /// An array of weights, of the same shape as a.  Each value in
        /// a only contributes its associated weight towards the bin count
        /// (instead of 1). This is currently not used by any of the bin estimators,
        /// but may be in the future.
        /// </param>
        /// <returns>
        /// The edges to pass into histogram
        /// </returns>
        public NDarray<float> histogram_bin_edges(List<string> bins = null, (float, float)? range = null, NDarray weights = null)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.histogram_bin_edges(@this, bins:bins, range:range, weights:weights);
        }
        
        /// <summary>
        /// Return the indices of the bins to which each value in input array belongs.
        /// 
        /// If values in x are beyond the bounds of bins, 0 or len(bins) is
        /// returned as appropriate.
        /// 
        /// Notes
        /// 
        /// If values in x are such that they fall outside the bin range,
        /// attempting to index bins with the indices that digitize returns
        /// will result in an IndexError.
        /// 
        /// np.digitize is  implemented in terms of np.searchsorted. This means
        /// that a binary search is used to bin the values, which scales much better
        /// for larger number of bins than the previous linear search. It also removes
        /// the requirement for the input array to be 1-dimensional.
        /// 
        /// For monotonically _increasing_ bins, the following are equivalent:
        /// 
        /// Note that as the order of the arguments are reversed, the side must be too.
        /// The searchsorted call is marginally faster, as it does not do any
        /// monotonicity checks. Perhaps more importantly, it supports all dtypes.
        /// </summary>
        /// <param name="bins">
        /// Array of bins. It has to be 1-dimensional and monotonic.
        /// </param>
        /// <param name="right">
        /// Indicating whether the intervals include the right or the left bin
        /// edge. Default behavior is (right==False) indicating that the interval
        /// does not include the right edge. The left bin end is open in this
        /// case, i.e., bins[i-1] &lt;= x &lt; bins[i] is the default behavior for
        /// monotonically increasing bins.
        /// </param>
        /// <returns>
        /// Output array of indices, of same shape as x.
        /// </returns>
        public NDarray digitize(NDarray bins, bool? right = false)
        {
            //auto-generated code, do not change
            var @this=this;
            return NumPy.Instance.digitize(@this, bins, right:right);
        }
        
    }
}
