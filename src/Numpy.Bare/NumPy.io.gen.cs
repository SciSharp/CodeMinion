// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Python.Runtime;
using Numpy.Models;

namespace Numpy
{
    public partial class NumPy
    {
        
        /// <summary>
        /// Load arrays or pickled objects from .npy, .npz or pickled files.
        /// 
        /// Notes
        /// </summary>
        /// <param name="file">
        /// The file to read. File-like objects must support the
        /// seek() and read() methods. Pickled files require that the
        /// file-like object support the readline() method as well.
        /// </param>
        /// <param name="mmap_mode">
        /// If not None, then memory-map the file, using the given mode (see
        /// numpy.memmap for a detailed description of the modes).  A
        /// memory-mapped array is kept on disk. However, it can be accessed
        /// and sliced like any ndarray.  Memory mapping is especially useful
        /// for accessing small fragments of large files without reading the
        /// entire file into memory.
        /// </param>
        /// <param name="allow_pickle">
        /// Allow loading pickled object arrays stored in npy files. Reasons for
        /// disallowing pickles include security, as loading pickled data can
        /// execute arbitrary code. If pickles are disallowed, loading object
        /// arrays will fail.
        /// Default: True
        /// </param>
        /// <param name="fix_imports">
        /// Only useful when loading Python 2 generated pickled files on Python 3,
        /// which includes npy/npz files containing object arrays. If fix_imports
        /// is True, pickle will try to map the old Python 2 names to the new names
        /// used in Python 3.
        /// </param>
        /// <param name="encoding">
        /// What encoding to use when reading Python 2 strings. Only useful when
        /// loading Python 2 generated pickled files in Python 3, which includes
        /// npy/npz files containing object arrays. Values other than ‘latin1’,
        /// ‘ASCII’, and ‘bytes’ are not allowed, as they can corrupt numerical
        /// data. Default: ‘ASCII’
        /// </param>
        /// <returns>
        /// Data stored in the file. For .npz files, the returned instance
        /// of NpzFile class must be closed to avoid leaking file descriptors.
        /// </returns>
        public NDarray load(string file, MemMapMode mmap_mode = null, bool? allow_pickle = true, bool? fix_imports = true, string encoding = "ASCII")
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                file,
            });
            var kwargs=new PyDict();
            if (mmap_mode!=null) kwargs["mmap_mode"]=ToPython(mmap_mode);
            if (allow_pickle!=true) kwargs["allow_pickle"]=ToPython(allow_pickle);
            if (fix_imports!=true) kwargs["fix_imports"]=ToPython(fix_imports);
            if (encoding!="ASCII") kwargs["encoding"]=ToPython(encoding);
            dynamic py = __self__.InvokeMethod("load", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Save an array to a binary file in NumPy .npy format.
        /// 
        /// Notes
        /// 
        /// For a description of the .npy format, see numpy.lib.format.
        /// </summary>
        /// <param name="file">
        /// File or filename to which the data is saved.  If file is a file-object,
        /// then the filename is unchanged.  If file is a string or Path, a .npy
        /// extension will be appended to the file name if it does not already
        /// have one.
        /// </param>
        /// <param name="arr">
        /// Array data to be saved.
        /// </param>
        /// <param name="allow_pickle">
        /// Allow saving object arrays using Python pickles. Reasons for disallowing
        /// pickles include security (loading pickled data can execute arbitrary
        /// code) and portability (pickled objects may not be loadable on different
        /// Python installations, for example if the stored objects require libraries
        /// that are not available, and not all pickled data is compatible between
        /// Python 2 and Python 3).
        /// Default: True
        /// </param>
        /// <param name="fix_imports">
        /// Only useful in forcing objects in object arrays on Python 3 to be
        /// pickled in a Python 2 compatible way. If fix_imports is True, pickle
        /// will try to map the new Python 3 names to the old module names used in
        /// Python 2, so that the pickle data stream is readable with Python 2.
        /// </param>
        public void save(string file, NDarray arr, bool? allow_pickle = true, bool? fix_imports = true)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                file,
                arr,
            });
            var kwargs=new PyDict();
            if (allow_pickle!=true) kwargs["allow_pickle"]=ToPython(allow_pickle);
            if (fix_imports!=true) kwargs["fix_imports"]=ToPython(fix_imports);
            dynamic py = __self__.InvokeMethod("save", pyargs, kwargs);
        }
        
        /// <summary>
        /// Save several arrays into a single file in uncompressed .npz format.
        /// 
        /// If arguments are passed in with no keywords, the corresponding variable
        /// names, in the .npz file, are ‘arr_0’, ‘arr_1’, etc. If keyword
        /// arguments are given, the corresponding variable names, in the .npz
        /// file will match the keyword names.
        /// 
        /// Notes
        /// 
        /// The .npz file format is a zipped archive of files named after the
        /// variables they contain.  The archive is not compressed and each file
        /// in the archive contains one variable in .npy format. For a
        /// description of the .npy format, see numpy.lib.format.
        /// 
        /// When opening the saved .npz file with load a NpzFile object is
        /// returned. This is a dictionary-like object which can be queried for
        /// its list of arrays (with the .files attribute), and for the arrays
        /// themselves.
        /// </summary>
        /// <param name="file">
        /// Either the file name (string) or an open file (file-like object)
        /// where the data will be saved. If file is a string or a Path, the
        /// .npz extension will be appended to the file name if it is not
        /// already there.
        /// </param>
        /// <param name="args">
        /// Arrays to save to the file. Since it is not possible for Python to
        /// know the names of the arrays outside savez, the arrays will be saved
        /// with names “arr_0”, “arr_1”, and so on. These arguments can be any
        /// expression.
        /// </param>
        /// <param name="kwds">
        /// Arrays to save to the file. Arrays will be saved in the file with the
        /// keyword names.
        /// </param>
        public void savez(string file, NDarray[] args = null, Dictionary<string, NDarray> kwds = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                file,
            });
            var kwargs=new PyDict();
            if (args!=null) kwargs["args"]=ToPython(args);
            if (kwds!=null) kwargs["kwds"]=ToPython(kwds);
            dynamic py = __self__.InvokeMethod("savez", pyargs, kwargs);
        }
        
        /// <summary>
        /// Save several arrays into a single file in compressed .npz format.
        /// 
        /// If keyword arguments are given, then filenames are taken from the keywords.
        /// If arguments are passed in with no keywords, then stored file names are
        /// arr_0, arr_1, etc.
        /// 
        /// Notes
        /// 
        /// The .npz file format is a zipped archive of files named after the
        /// variables they contain.  The archive is compressed with
        /// zipfile.ZIP_DEFLATED and each file in the archive contains one variable
        /// in .npy format. For a description of the .npy format, see 
        /// numpy.lib.format.
        /// 
        /// When opening the saved .npz file with load a NpzFile object is
        /// returned. This is a dictionary-like object which can be queried for
        /// its list of arrays (with the .files attribute), and for the arrays
        /// themselves.
        /// </summary>
        /// <param name="file">
        /// Either the file name (string) or an open file (file-like object)
        /// where the data will be saved. If file is a string or a Path, the
        /// .npz extension will be appended to the file name if it is not
        /// already there.
        /// </param>
        /// <param name="args">
        /// Arrays to save to the file. Since it is not possible for Python to
        /// know the names of the arrays outside savez, the arrays will be saved
        /// with names “arr_0”, “arr_1”, and so on. These arguments can be any
        /// expression.
        /// </param>
        /// <param name="kwds">
        /// Arrays to save to the file. Arrays will be saved in the file with the
        /// keyword names.
        /// </param>
        public void savez_compressed(string file, NDarray[] args = null, Dictionary<string, NDarray> kwds = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                file,
            });
            var kwargs=new PyDict();
            if (args!=null) kwargs["args"]=ToPython(args);
            if (kwds!=null) kwargs["kwds"]=ToPython(kwds);
            dynamic py = __self__.InvokeMethod("savez_compressed", pyargs, kwargs);
        }
        
        /// <summary>
        /// Save an array to a text file.
        /// 
        /// Notes
        /// 
        /// Further explanation of the fmt parameter
        /// (%[flag]width[.precision]specifier):
        /// 
        /// This explanation of fmt is not complete, for an exhaustive
        /// specification see [1].
        /// 
        /// References
        /// </summary>
        /// <param name="fname">
        /// If the filename ends in .gz, the file is automatically saved in
        /// compressed gzip format.  loadtxt understands gzipped files
        /// transparently.
        /// </param>
        /// <param name="X">
        /// Data to be saved to a text file.
        /// </param>
        /// <param name="fmt">
        /// A single format (%10.5f), a sequence of formats, or a
        /// multi-format string, e.g. ‘Iteration %d – %10.5f’, in which
        /// case delimiter is ignored. For complex X, the legal options
        /// for fmt are:
        /// </param>
        /// <param name="delimiter">
        /// String or character separating columns.
        /// </param>
        /// <param name="newline">
        /// String or character separating lines.
        /// </param>
        /// <param name="header">
        /// String that will be written at the beginning of the file.
        /// </param>
        /// <param name="footer">
        /// String that will be written at the end of the file.
        /// </param>
        /// <param name="comments">
        /// String that will be prepended to the header and footer strings,
        /// to mark them as comments. Default: ‘# ‘,  as expected by e.g.
        /// numpy.loadtxt.
        /// </param>
        /// <param name="encoding">
        /// Encoding used to encode the outputfile. Does not apply to output
        /// streams. If the encoding is something other than ‘bytes’ or ‘latin1’
        /// you will not be able to load the file in NumPy versions &lt; 1.14. Default
        /// is ‘latin1’.
        /// </param>
        public void savetxt(string fname, NDarray X, string[] fmt = null, string delimiter = " ", string newline = "\n", string header = "", string footer = "", string comments = null, string encoding = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                fname,
                X,
            });
            var kwargs=new PyDict();
            if (fmt!=null) kwargs["fmt"]=ToPython(fmt);
            if (delimiter!=" ") kwargs["delimiter"]=ToPython(delimiter);
            if (newline!="\n") kwargs["newline"]=ToPython(newline);
            if (header!="") kwargs["header"]=ToPython(header);
            if (footer!="") kwargs["footer"]=ToPython(footer);
            if (comments!=null) kwargs["comments"]=ToPython(comments);
            if (encoding!=null) kwargs["encoding"]=ToPython(encoding);
            dynamic py = __self__.InvokeMethod("savetxt", pyargs, kwargs);
        }
        
        /*
        /// <summary>
        /// Load data from a text file, with missing values handled as specified.
        /// 
        /// Each line past the first skip_header lines is split at the delimiter
        /// character, and characters following the comments character are discarded.
        /// 
        /// Notes
        /// 
        /// References
        /// </summary>
        /// <param name="fname">
        /// File, filename, list, or generator to read.  If the filename
        /// extension is gz or bz2, the file is first decompressed. Note
        /// that generators must return byte strings in Python 3k.  The strings
        /// in a list or produced by a generator are treated as lines.
        /// </param>
        /// <param name="dtype">
        /// Data type of the resulting array.
        /// If None, the dtypes will be determined by the contents of each
        /// column, individually.
        /// </param>
        /// <param name="comments">
        /// The character used to indicate the start of a comment.
        /// All the characters occurring on a line after a comment are discarded
        /// </param>
        /// <param name="delimiter">
        /// The string used to separate values.  By default, any consecutive
        /// whitespaces act as delimiter.  An integer or sequence of integers
        /// can also be provided as width(s) of each field.
        /// </param>
        /// <param name="skiprows">
        /// skiprows was removed in numpy 1.10. Please use skip_header instead.
        /// </param>
        /// <param name="skip_header">
        /// The number of lines to skip at the beginning of the file.
        /// </param>
        /// <param name="skip_footer">
        /// The number of lines to skip at the end of the file.
        /// </param>
        /// <param name="converters">
        /// The set of functions that convert the data of a column to a value.
        /// The converters can also be used to provide a default value
        /// for missing data: converters = {3: lambda s: float(s or 0)}.
        /// </param>
        /// <param name="missing">
        /// missing was removed in numpy 1.10. Please use missing_values
        /// instead.
        /// </param>
        /// <param name="missing_values">
        /// The set of strings corresponding to missing data.
        /// </param>
        /// <param name="filling_values">
        /// The set of values to be used as default when the data are missing.
        /// </param>
        /// <param name="usecols">
        /// Which columns to read, with 0 being the first.  For example,
        /// usecols = (1, 4, 5) will extract the 2nd, 5th and 6th columns.
        /// </param>
        /// <param name="names">
        /// If names is True, the field names are read from the first line after
        /// the first skip_header lines.  This line can optionally be proceeded
        /// by a comment delimiter. If names is a sequence or a single-string of
        /// comma-separated names, the names will be used to define the field names
        /// in a structured dtype. If names is None, the names of the dtype
        /// fields will be used, if any.
        /// </param>
        /// <param name="excludelist">
        /// A list of names to exclude. This list is appended to the default list
        /// [‘return’,’file’,’print’]. Excluded names are appended an underscore:
        /// for example, file would become file_.
        /// </param>
        /// <param name="deletechars">
        /// A string combining invalid characters that must be deleted from the
        /// names.
        /// </param>
        /// <param name="defaultfmt">
        /// A format used to define default field names, such as “f%i” or “f_%02i”.
        /// </param>
        /// <param name="autostrip">
        /// Whether to automatically strip white spaces from the variables.
        /// </param>
        /// <param name="replace_space">
        /// Character(s) used in replacement of white spaces in the variables
        /// names. By default, use a ‘_’.
        /// </param>
        /// <param name="case_sensitive">
        /// If True, field names are case sensitive.
        /// If False or ‘upper’, field names are converted to upper case.
        /// If ‘lower’, field names are converted to lower case.
        /// </param>
        /// <param name="unpack">
        /// If True, the returned array is transposed, so that arguments may be
        /// unpacked using x, y, z = loadtxt(...)
        /// </param>
        /// <param name="usemask">
        /// If True, return a masked array.
        /// If False, return a regular array.
        /// </param>
        /// <param name="loose">
        /// If True, do not raise errors for invalid values.
        /// </param>
        /// <param name="invalid_raise">
        /// If True, an exception is raised if an inconsistency is detected in the
        /// number of columns.
        /// If False, a warning is emitted and the offending lines are skipped.
        /// </param>
        /// <param name="max_rows">
        /// The maximum number of rows to read. Must not be used with skip_footer
        /// at the same time.  If given, the value must be at least 1. Default is
        /// to read the entire file.
        /// </param>
        /// <param name="encoding">
        /// Encoding used to decode the inputfile. Does not apply when fname is
        /// a file object.  The special value ‘bytes’ enables backward compatibility
        /// workarounds that ensure that you receive byte arrays when possible
        /// and passes latin1 encoded strings to converters. Override this value to
        /// receive unicode arrays and pass strings as input to converters.  If set
        /// to None the system default is used. The default value is ‘bytes’.
        /// </param>
        /// <returns>
        /// Data read from the text file. If usemask is True, this is a
        /// masked array.
        /// </returns>
        public NDarray genfromtxt(string fname, Dtype dtype = null, string comments = null, string delimiter = null, int? skiprows = null, int? skip_header = 0, int? skip_footer = 0, variable converters = null, variable missing = null, variable missing_values = null, variable filling_values = null, sequence usecols = null, {None names = null, sequence excludelist = null, string deletechars = null, string defaultfmt = "f%i", bool? autostrip = false, char replace_space = "_", {True case_sensitive = true, bool? unpack = null, bool? usemask = false, bool? loose = true, bool? invalid_raise = true, int? max_rows = null, string encoding = "bytes")
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                fname,
            });
            var kwargs=new PyDict();
            if (dtype!=null) kwargs["dtype"]=ToPython(dtype);
            if (comments!=null) kwargs["comments"]=ToPython(comments);
            if (delimiter!=null) kwargs["delimiter"]=ToPython(delimiter);
            if (skiprows!=null) kwargs["skiprows"]=ToPython(skiprows);
            if (skip_header!=0) kwargs["skip_header"]=ToPython(skip_header);
            if (skip_footer!=0) kwargs["skip_footer"]=ToPython(skip_footer);
            if (converters!=null) kwargs["converters"]=ToPython(converters);
            if (missing!=null) kwargs["missing"]=ToPython(missing);
            if (missing_values!=null) kwargs["missing_values"]=ToPython(missing_values);
            if (filling_values!=null) kwargs["filling_values"]=ToPython(filling_values);
            if (usecols!=null) kwargs["usecols"]=ToPython(usecols);
            if (names!=null) kwargs["names"]=ToPython(names);
            if (excludelist!=null) kwargs["excludelist"]=ToPython(excludelist);
            if (deletechars!=null) kwargs["deletechars"]=ToPython(deletechars);
            if (defaultfmt!="f%i") kwargs["defaultfmt"]=ToPython(defaultfmt);
            if (autostrip!=false) kwargs["autostrip"]=ToPython(autostrip);
            if (replace_space!="_") kwargs["replace_space"]=ToPython(replace_space);
            if (case_sensitive!=true) kwargs["case_sensitive"]=ToPython(case_sensitive);
            if (unpack!=null) kwargs["unpack"]=ToPython(unpack);
            if (usemask!=false) kwargs["usemask"]=ToPython(usemask);
            if (loose!=true) kwargs["loose"]=ToPython(loose);
            if (invalid_raise!=true) kwargs["invalid_raise"]=ToPython(invalid_raise);
            if (max_rows!=null) kwargs["max_rows"]=ToPython(max_rows);
            if (encoding!="bytes") kwargs["encoding"]=ToPython(encoding);
            dynamic py = __self__.InvokeMethod("genfromtxt", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        */
        
        /// <summary>
        /// Construct an array from a text file, using regular expression parsing.
        /// 
        /// The returned array is always a structured array, and is constructed from
        /// all matches of the regular expression in the file. Groups in the regular
        /// expression are converted to fields of the structured array.
        /// 
        /// Notes
        /// 
        /// Dtypes for structured arrays can be specified in several forms, but all
        /// forms specify at least the data type and field name. For details see
        /// doc.structured_arrays.
        /// </summary>
        /// <param name="file">
        /// File name or file object to read.
        /// </param>
        /// <param name="regexp">
        /// Regular expression used to parse the file.
        /// Groups in the regular expression correspond to fields in the dtype.
        /// </param>
        /// <param name="dtype">
        /// Dtype for the structured array.
        /// </param>
        /// <param name="encoding">
        /// Encoding used to decode the inputfile. Does not apply to input streams.
        /// </param>
        /// <returns>
        /// The output array, containing the part of the content of file that
        /// was matched by regexp. output is always a structured array.
        /// </returns>
        public NDarray fromregex(string file, string regexp, Dtype dtype, string encoding = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                file,
                regexp,
                dtype,
            });
            var kwargs=new PyDict();
            if (encoding!=null) kwargs["encoding"]=ToPython(encoding);
            dynamic py = __self__.InvokeMethod("fromregex", pyargs, kwargs);
            return ToCsharp<NDarray>(py);
        }
        
        /// <summary>
        /// Write array to a file as text or binary (default).
        /// 
        /// Data is always written in ‘C’ order, independent of the order of a.
        /// The data produced by this method can be recovered using the function
        /// fromfile().
        /// 
        /// Notes
        /// 
        /// This is a convenience function for quick storage of array data.
        /// Information on endianness and precision is lost, so this method is not a
        /// good choice for files intended to archive data or transport data between
        /// machines with different endianness. Some of these problems can be overcome
        /// by outputting the data as text files, at the expense of speed and file
        /// size.
        /// 
        /// When fid is a file object, array contents are directly written to the
        /// file, bypassing the file object’s write method. As a result, tofile
        /// cannot be used with files objects supporting compression (e.g., GzipFile)
        /// or file-like objects that do not support fileno() (e.g., BytesIO).
        /// </summary>
        /// <param name="fid">
        /// An open file object, or a string containing a filename.
        /// </param>
        /// <param name="sep">
        /// Separator between array items for text output.
        /// If “” (empty), a binary file is written, equivalent to
        /// file.write(a.tobytes()).
        /// </param>
        /// <param name="format">
        /// Format string for text file output.
        /// Each entry in the array is formatted to text by first converting
        /// it to the closest Python type, and then using “format” % item.
        /// </param>
        public void tofile(string fid, string sep, string format)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                fid,
                sep,
                format,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("tofile", pyargs, kwargs);
        }
        
        /*
        /// <summary>
        /// Return the array as a (possibly nested) list.
        /// 
        /// Return a copy of the array data as a (nested) Python list.
        /// Data items are converted to the nearest compatible Python type.
        /// 
        /// Notes
        /// 
        /// The array may be recreated, a = np.array(a.tolist()).
        /// </summary>
        /// <returns>
        /// The possibly nested list of array elements.
        /// </returns>
        public List<T> tolist<T>()
        {
            //auto-generated code, do not change
            var __self__=self;
            dynamic py = __self__.InvokeMethod("tolist");
            return ToCsharp<List<T>>(py);
        }
        */
        
        /*
        /// <summary>
        /// Return a string representation of an array.
        /// 
        /// Notes
        /// 
        /// If a formatter is specified for a certain type, the precision keyword is
        /// ignored for that type.
        /// 
        /// This is a very flexible function; array_repr and array_str are using
        /// array2string internally so keywords with the same name should work
        /// identically in all three functions.
        /// </summary>
        /// <param name="a">
        /// Input array.
        /// </param>
        /// <param name="max_line_width">
        /// The maximum number of columns the string should span. Newline
        /// characters splits the string appropriately after array elements.
        /// </param>
        /// <param name="precision">
        /// Floating point precision. Default is the current printing
        /// precision (usually 8), which can be altered using set_printoptions.
        /// </param>
        /// <param name="suppress_small">
        /// Represent very small numbers as zero. A number is “very small” if it
        /// is smaller than the current printing precision.
        /// </param>
        /// <param name="separator">
        /// Inserted between elements.
        /// </param>
        /// <param name="suffix">
        /// The length of the prefix and suffix strings are used to respectively
        /// align and wrap the output. An array is typically printed as:
        /// 
        /// The output is left-padded by the length of the prefix string, and
        /// wrapping is forced at the column max_line_width - len(suffix).
        /// It should be noted that the content of prefix and suffix strings are
        /// not included in the output.
        /// </param>
        /// <param name="formatter">
        /// If not None, the keys should indicate the type(s) that the respective
        /// formatting function applies to.  Callables should return a string.
        /// Types that are not specified (by their corresponding keys) are handled
        /// by the default formatters.  Individual types for which a formatter
        /// can be set are:
        /// 
        /// Other keys that can be used to set a group of types at once are:
        /// </param>
        /// <param name="threshold">
        /// Total number of array elements which trigger summarization
        /// rather than full repr.
        /// </param>
        /// <param name="edgeitems">
        /// Number of array items in summary at beginning and end of
        /// each dimension.
        /// </param>
        /// <param name="sign">
        /// Controls printing of the sign of floating-point types. If ‘+’, always
        /// print the sign of positive values. If ‘ ‘, always prints a space
        /// (whitespace character) in the sign position of positive values.  If
        /// ‘-‘, omit the sign character of positive values.
        /// </param>
        /// <param name="floatmode">
        /// Controls the interpretation of the precision option for
        /// floating-point types. Can take the following values:
        /// </param>
        /// <param name="legacy">
        /// If set to the string ‘1.13’ enables 1.13 legacy printing mode. This
        /// approximates numpy 1.13 print output by including a space in the sign
        /// position of floats and different behavior for 0d arrays. If set to
        /// False, disables legacy mode. Unrecognized strings will be ignored
        /// with a warning for forward compatibility.
        /// </param>
        /// <returns>
        /// String representation of the array.
        /// </returns>
        public string array2string(NDarray a, int? max_line_width = null, int? precision = null, bool? suppress_small = null, string separator = " ", string prefix = "", string suffix = "", dict of callables formatter = null, int? threshold = null, int? edgeitems = null, string sign = null, string floatmode = null, string or False legacy = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                a,
            });
            var kwargs=new PyDict();
            if (max_line_width!=null) kwargs["max_line_width"]=ToPython(max_line_width);
            if (precision!=null) kwargs["precision"]=ToPython(precision);
            if (suppress_small!=null) kwargs["suppress_small"]=ToPython(suppress_small);
            if (separator!=" ") kwargs["separator"]=ToPython(separator);
            if (prefix!="") kwargs["prefix"]=ToPython(prefix);
            if (suffix!="") kwargs["suffix"]=ToPython(suffix);
            if (formatter!=null) kwargs["formatter"]=ToPython(formatter);
            if (threshold!=null) kwargs["threshold"]=ToPython(threshold);
            if (edgeitems!=null) kwargs["edgeitems"]=ToPython(edgeitems);
            if (sign!=null) kwargs["sign"]=ToPython(sign);
            if (floatmode!=null) kwargs["floatmode"]=ToPython(floatmode);
            if (legacy!=null) kwargs["legacy"]=ToPython(legacy);
            dynamic py = __self__.InvokeMethod("array2string", pyargs, kwargs);
            return ToCsharp<string>(py);
        }
        */
        
        /// <summary>
        /// Return the string representation of an array.
        /// </summary>
        /// <param name="arr">
        /// Input array.
        /// </param>
        /// <param name="max_line_width">
        /// The maximum number of columns the string should span. Newline
        /// characters split the string appropriately after array elements.
        /// </param>
        /// <param name="precision">
        /// Floating point precision. Default is the current printing precision
        /// (usually 8), which can be altered using set_printoptions.
        /// </param>
        /// <param name="suppress_small">
        /// Represent very small numbers as zero, default is False. Very small
        /// is defined by precision, if the precision is 8 then
        /// numbers smaller than 5e-9 are represented as zero.
        /// </param>
        /// <returns>
        /// The string representation of an array.
        /// </returns>
        public string array_repr(NDarray arr, int? max_line_width = null, int? precision = null, bool? suppress_small = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                arr,
            });
            var kwargs=new PyDict();
            if (max_line_width!=null) kwargs["max_line_width"]=ToPython(max_line_width);
            if (precision!=null) kwargs["precision"]=ToPython(precision);
            if (suppress_small!=null) kwargs["suppress_small"]=ToPython(suppress_small);
            dynamic py = __self__.InvokeMethod("array_repr", pyargs, kwargs);
            return ToCsharp<string>(py);
        }
        
        /// <summary>
        /// Return a string representation of the data in an array.
        /// 
        /// The data in the array is returned as a single string.  This function is
        /// similar to array_repr, the difference being that array_repr also
        /// returns information on the kind of array and its data type.
        /// </summary>
        /// <param name="a">
        /// Input array.
        /// </param>
        /// <param name="max_line_width">
        /// Inserts newlines if text is longer than max_line_width.  The
        /// default is, indirectly, 75.
        /// </param>
        /// <param name="precision">
        /// Floating point precision.  Default is the current printing precision
        /// (usually 8), which can be altered using set_printoptions.
        /// </param>
        /// <param name="suppress_small">
        /// Represent numbers “very close” to zero as zero; default is False.
        /// Very close is defined by precision: if the precision is 8, e.g.,
        /// numbers smaller (in absolute value) than 5e-9 are represented as
        /// zero.
        /// </param>
        public void array_str(NDarray a, int? max_line_width = null, int? precision = null, bool? suppress_small = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                a,
            });
            var kwargs=new PyDict();
            if (max_line_width!=null) kwargs["max_line_width"]=ToPython(max_line_width);
            if (precision!=null) kwargs["precision"]=ToPython(precision);
            if (suppress_small!=null) kwargs["suppress_small"]=ToPython(suppress_small);
            dynamic py = __self__.InvokeMethod("array_str", pyargs, kwargs);
        }
        
        /*
        /// <summary>
        /// Format a floating-point scalar as a decimal string in positional notation.
        /// 
        /// Provides control over rounding, trimming and padding. Uses and assumes
        /// IEEE unbiased rounding. Uses the “Dragon4” algorithm.
        /// </summary>
        /// <param name="x">
        /// Value to format.
        /// </param>
        /// <param name="precision">
        /// Maximum number of digits to print. May be None if unique is
        /// True, but must be an integer if unique is False.
        /// </param>
        /// <param name="unique">
        /// If True, use a digit-generation strategy which gives the shortest
        /// representation which uniquely identifies the floating-point number from
        /// other values of the same type, by judicious rounding. If precision
        /// was omitted, print out all necessary digits, otherwise digit generation
        /// is cut off after precision digits and the remaining value is rounded.
        /// If False, digits are generated as if printing an infinite-precision
        /// value and stopping after precision digits, rounding the remaining
        /// value.
        /// </param>
        /// <param name="fractional">
        /// If True, the cutoff of precision digits refers to the total number
        /// of digits after the decimal point, including leading zeros.
        /// If False, precision refers to the total number of significant
        /// digits, before or after the decimal point, ignoring leading zeros.
        /// </param>
        /// <param name="trim">
        /// Controls post-processing trimming of trailing digits, as follows:
        /// </param>
        /// <param name="sign">
        /// Whether to show the sign for positive values.
        /// </param>
        /// <param name="pad_left">
        /// Pad the left side of the string with whitespace until at least that
        /// many characters are to the left of the decimal point.
        /// </param>
        /// <param name="pad_right">
        /// Pad the right side of the string with whitespace until at least that
        /// many characters are to the right of the decimal point.
        /// </param>
        /// <returns>
        /// The string representation of the floating point value
        /// </returns>
        public string format_float_positional(python float or numpy floating scalar x, non-negative integer or None precision = null, bool? unique = true, bool? fractional = true, one of ‘k’ trim = "k", bool? sign = false, non-negative integer pad_left = null, non-negative integer pad_right = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                x,
            });
            var kwargs=new PyDict();
            if (precision!=null) kwargs["precision"]=ToPython(precision);
            if (unique!=true) kwargs["unique"]=ToPython(unique);
            if (fractional!=true) kwargs["fractional"]=ToPython(fractional);
            if (trim!="k") kwargs["trim"]=ToPython(trim);
            if (sign!=false) kwargs["sign"]=ToPython(sign);
            if (pad_left!=null) kwargs["pad_left"]=ToPython(pad_left);
            if (pad_right!=null) kwargs["pad_right"]=ToPython(pad_right);
            dynamic py = __self__.InvokeMethod("format_float_positional", pyargs, kwargs);
            return ToCsharp<string>(py);
        }
        */
        
        /*
        /// <summary>
        /// Format a floating-point scalar as a decimal string in scientific notation.
        /// 
        /// Provides control over rounding, trimming and padding. Uses and assumes
        /// IEEE unbiased rounding. Uses the “Dragon4” algorithm.
        /// </summary>
        /// <param name="x">
        /// Value to format.
        /// </param>
        /// <param name="precision">
        /// Maximum number of digits to print. May be None if unique is
        /// True, but must be an integer if unique is False.
        /// </param>
        /// <param name="unique">
        /// If True, use a digit-generation strategy which gives the shortest
        /// representation which uniquely identifies the floating-point number from
        /// other values of the same type, by judicious rounding. If precision
        /// was omitted, print all necessary digits, otherwise digit generation is
        /// cut off after precision digits and the remaining value is rounded.
        /// If False, digits are generated as if printing an infinite-precision
        /// value and stopping after precision digits, rounding the remaining
        /// value.
        /// </param>
        /// <param name="trim">
        /// Controls post-processing trimming of trailing digits, as follows:
        /// </param>
        /// <param name="sign">
        /// Whether to show the sign for positive values.
        /// </param>
        /// <param name="pad_left">
        /// Pad the left side of the string with whitespace until at least that
        /// many characters are to the left of the decimal point.
        /// </param>
        /// <param name="exp_digits">
        /// Pad the exponent with zeros until it contains at least this many digits.
        /// If omitted, the exponent will be at least 2 digits.
        /// </param>
        /// <returns>
        /// The string representation of the floating point value
        /// </returns>
        public string format_float_scientific(python float or numpy floating scalar x, non-negative integer or None precision = null, bool? unique = true, one of ‘k’ trim = "k", bool? sign = false, non-negative integer pad_left = null, non-negative integer exp_digits = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                x,
            });
            var kwargs=new PyDict();
            if (precision!=null) kwargs["precision"]=ToPython(precision);
            if (unique!=true) kwargs["unique"]=ToPython(unique);
            if (trim!="k") kwargs["trim"]=ToPython(trim);
            if (sign!=false) kwargs["sign"]=ToPython(sign);
            if (pad_left!=null) kwargs["pad_left"]=ToPython(pad_left);
            if (exp_digits!=null) kwargs["exp_digits"]=ToPython(exp_digits);
            dynamic py = __self__.InvokeMethod("format_float_scientific", pyargs, kwargs);
            return ToCsharp<string>(py);
        }
        */
        
        /// <summary>
        /// Create a memory-map to an array stored in a binary file on disk.
        /// 
        /// Memory-mapped files are used for accessing small segments of large files
        /// on disk, without reading the entire file into memory.  NumPy’s
        /// memmap’s are array-like objects.  This differs from Python’s mmap
        /// module, which uses file-like objects.
        /// 
        /// This subclass of ndarray has some unpleasant interactions with
        /// some operations, because it doesn’t quite fit properly as a subclass.
        /// An alternative to using this subclass is to create the mmap
        /// object yourself, then create an ndarray with ndarray.__new__ directly,
        /// passing the object created in its ‘buffer=’ parameter.
        /// 
        /// This class may at some point be turned into a factory function
        /// which returns a view into an mmap buffer.
        /// 
        /// Delete the memmap instance to close the memmap file.
        /// 
        /// Notes
        /// 
        /// The memmap object can be used anywhere an ndarray is accepted.
        /// Given a memmap fp, isinstance(fp, numpy.ndarray) returns
        /// True.
        /// 
        /// Memory-mapped files cannot be larger than 2GB on 32-bit systems.
        /// 
        /// When a memmap causes a file to be created or extended beyond its
        /// current size in the filesystem, the contents of the new part are
        /// unspecified. On systems with POSIX filesystem semantics, the extended
        /// part will be filled with zero bytes.
        /// </summary>
        /// <param name="filename">
        /// The file name or file object to be used as the array data buffer.
        /// </param>
        /// <param name="dtype">
        /// The data-type used to interpret the file contents.
        /// Default is uint8.
        /// </param>
        /// <param name="mode">
        /// The file is opened in this mode:
        /// 
        /// Default is ‘r+’.
        /// </param>
        /// <param name="offset">
        /// In the file, array data starts at this offset. Since offset is
        /// measured in bytes, it should normally be a multiple of the byte-size
        /// of dtype. When mode != 'r', even positive offsets beyond end of
        /// file are valid; The file will be extended to accommodate the
        /// additional data. By default, memmap will start at the beginning of
        /// the file, even if filename is a file pointer fp and
        /// fp.tell() != 0.
        /// </param>
        /// <param name="shape">
        /// The desired shape of the array. If mode == 'r' and the number
        /// of remaining bytes after offset is not a multiple of the byte-size
        /// of dtype, you must specify shape. By default, the returned array
        /// will be 1-D with the number of elements determined by file size
        /// and data-type.
        /// </param>
        /// <param name="order">
        /// Specify the order of the ndarray memory layout:
        /// row-major, C-style or column-major,
        /// Fortran-style.  This only has an effect if the shape is
        /// greater than 1-D.  The default order is ‘C’.
        /// </param>
        public void memmap(string filename, Dtype dtype = null, string mode = null, int? offset = null, Shape shape = null, string order = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                filename,
            });
            var kwargs=new PyDict();
            if (dtype!=null) kwargs["dtype"]=ToPython(dtype);
            if (mode!=null) kwargs["mode"]=ToPython(mode);
            if (offset!=null) kwargs["offset"]=ToPython(offset);
            if (shape!=null) kwargs["shape"]=ToPython(shape);
            if (order!=null) kwargs["order"]=ToPython(order);
            dynamic py = __self__.InvokeMethod("memmap", pyargs, kwargs);
        }
        
        /*
        /// <summary>
        /// Set printing options.
        /// 
        /// These options determine the way floating point numbers, arrays and
        /// other NumPy objects are displayed.
        /// 
        /// Notes
        /// 
        /// formatter is always reset with a call to set_printoptions.
        /// </summary>
        /// <param name="precision">
        /// Number of digits of precision for floating point output (default 8).
        /// May be None if floatmode is not fixed, to print as many digits as
        /// necessary to uniquely specify the value.
        /// </param>
        /// <param name="threshold">
        /// Total number of array elements which trigger summarization
        /// rather than full repr (default 1000).
        /// </param>
        /// <param name="edgeitems">
        /// Number of array items in summary at beginning and end of
        /// each dimension (default 3).
        /// </param>
        /// <param name="linewidth">
        /// The number of characters per line for the purpose of inserting
        /// line breaks (default 75).
        /// </param>
        /// <param name="suppress">
        /// If True, always print floating point numbers using fixed point
        /// notation, in which case numbers equal to zero in the current precision
        /// will print as zero.  If False, then scientific notation is used when
        /// absolute value of the smallest number is &lt; 1e-4 or the ratio of the
        /// maximum absolute value to the minimum is &gt; 1e3. The default is False.
        /// </param>
        /// <param name="nanstr">
        /// String representation of floating point not-a-number (default nan).
        /// </param>
        /// <param name="infstr">
        /// String representation of floating point infinity (default inf).
        /// </param>
        /// <param name="sign">
        /// Controls printing of the sign of floating-point types. If ‘+’, always
        /// print the sign of positive values. If ‘ ‘, always prints a space
        /// (whitespace character) in the sign position of positive values.  If
        /// ‘-‘, omit the sign character of positive values. (default ‘-‘)
        /// </param>
        /// <param name="formatter">
        /// If not None, the keys should indicate the type(s) that the respective
        /// formatting function applies to.  Callables should return a string.
        /// Types that are not specified (by their corresponding keys) are handled
        /// by the default formatters.  Individual types for which a formatter
        /// can be set are:
        /// 
        /// Other keys that can be used to set a group of types at once are:
        /// </param>
        /// <param name="floatmode">
        /// Controls the interpretation of the precision option for
        /// floating-point types. Can take the following values:
        /// </param>
        /// <param name="legacy">
        /// If set to the string ‘1.13’ enables 1.13 legacy printing mode. This
        /// approximates numpy 1.13 print output by including a space in the sign
        /// position of floats and different behavior for 0d arrays. If set to
        /// False, disables legacy mode. Unrecognized strings will be ignored
        /// with a warning for forward compatibility.
        /// </param>
        public void set_printoptions(int? precision = null, int? threshold = null, int? edgeitems = null, int? linewidth = null, bool? suppress = null, string nanstr = null, string infstr = null, string sign = null, dict of callables formatter = null, string floatmode = null, string or False legacy = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (precision!=null) kwargs["precision"]=ToPython(precision);
            if (threshold!=null) kwargs["threshold"]=ToPython(threshold);
            if (edgeitems!=null) kwargs["edgeitems"]=ToPython(edgeitems);
            if (linewidth!=null) kwargs["linewidth"]=ToPython(linewidth);
            if (suppress!=null) kwargs["suppress"]=ToPython(suppress);
            if (nanstr!=null) kwargs["nanstr"]=ToPython(nanstr);
            if (infstr!=null) kwargs["infstr"]=ToPython(infstr);
            if (sign!=null) kwargs["sign"]=ToPython(sign);
            if (formatter!=null) kwargs["formatter"]=ToPython(formatter);
            if (floatmode!=null) kwargs["floatmode"]=ToPython(floatmode);
            if (legacy!=null) kwargs["legacy"]=ToPython(legacy);
            dynamic py = __self__.InvokeMethod("set_printoptions", pyargs, kwargs);
        }
        */
        
        /// <summary>
        /// Return the current print options.
        /// </summary>
        /// <param name="print_opts">
        /// Dictionary of current print options with keys
        /// 
        /// For a full description of these options, see set_printoptions.
        /// </param>
        /// <returns>
        /// Dictionary of current print options with keys
        /// 
        /// For a full description of these options, see set_printoptions.
        /// </returns>
        public Hashtable get_printoptions(Hashtable print_opts)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                print_opts,
            });
            var kwargs=new PyDict();
            dynamic py = __self__.InvokeMethod("get_printoptions", pyargs, kwargs);
            return ToCsharp<Hashtable>(py);
        }
        
        /*
        /// <summary>
        /// Set a Python function to be used when pretty printing arrays.
        /// </summary>
        /// <param name="f">
        /// Function to be used to pretty print arrays. The function should expect
        /// a single array argument and return a string of the representation of
        /// the array. If None, the function is reset to the default NumPy function
        /// to print arrays.
        /// </param>
        /// <param name="repr">
        /// If True (default), the function for pretty printing (__repr__)
        /// is set, if False the function that returns the default string
        /// representation (__str__) is set.
        /// </param>
        public void set_string_function(function or None f, bool? repr = true)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                f,
            });
            var kwargs=new PyDict();
            if (repr!=true) kwargs["repr"]=ToPython(repr);
            dynamic py = __self__.InvokeMethod("set_string_function", pyargs, kwargs);
        }
        */
        
        /// <summary>
        /// Return a string representation of a number in the given base system.
        /// </summary>
        /// <param name="number">
        /// The value to convert. Positive and negative values are handled.
        /// </param>
        /// <param name="base">
        /// Convert number to the base number system. The valid range is 2-36,
        /// the default value is 2.
        /// </param>
        /// <param name="padding">
        /// Number of zeros padded on the left. Default is 0 (no padding).
        /// </param>
        /// <returns>
        /// String representation of number in base system.
        /// </returns>
        public string base_repr(int number, int? @base = 2, int? padding = 0)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
                number,
            });
            var kwargs=new PyDict();
            if (@base!=2) kwargs["base"]=ToPython(@base);
            if (padding!=0) kwargs["padding"]=ToPython(padding);
            dynamic py = __self__.InvokeMethod("base_repr", pyargs, kwargs);
            return ToCsharp<string>(py);
        }
        
        /// <summary>
        /// A generic data source file (file, http, ftp, …).
        /// 
        /// DataSources can be local files or remote files/URLs.  The files may
        /// also be compressed or uncompressed. DataSource hides some of the
        /// low-level details of downloading the file, allowing you to simply pass
        /// in a valid file path (or URL) and obtain a file object.
        /// 
        /// Notes
        /// 
        /// URLs require a scheme string (http://) to be used, without it they
        /// will fail:
        /// 
        /// Temporary directories are deleted when the DataSource is deleted.
        /// </summary>
        /// <param name="destpath">
        /// Path to the directory where the source file gets downloaded to for
        /// use.  If destpath is None, a temporary directory will be created.
        /// The default path is the current directory.
        /// </param>
        public void DataSource(string destpath = null)
        {
            //auto-generated code, do not change
            var __self__=self;
            var pyargs=ToTuple(new object[]
            {
            });
            var kwargs=new PyDict();
            if (destpath!=null) kwargs["destpath"]=ToPython(destpath);
            dynamic py = __self__.InvokeMethod("DataSource", pyargs, kwargs);
        }
        
    }
}
