// Copyright (c) 2019 by the SciSharp Team
// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Python.Runtime;
using Numpy.Models;

namespace Numpy
{
    public static partial class np
    {
        
        /// <summary>
        /// Test whether each element of a 1-D array is also present in a second array.
        /// 
        /// Returns a boolean array the same length as ar1 that is True
        /// where an element of ar1 is in ar2 and False otherwise.
        /// 
        /// We recommend using isin instead of in1d for new code.
        /// 
        /// Notes
        /// 
        /// in1d can be considered as an element-wise function version of the
        /// python keyword in, for 1-D sequences. in1d(a, b) is roughly
        /// equivalent to np.array([item in b for item in a]).
        /// However, this idea fails if ar2 is a set, or similar (non-sequence)
        /// container:  As ar2 is converted to an array, in those cases
        /// asarray(ar2) is an object array rather than the expected array of
        /// contained values.
        /// </summary>
        /// <param name="ar1">
        /// Input array.
        /// </param>
        /// <param name="ar2">
        /// The values against which to test each value of ar1.
        /// </param>
        /// <param name="assume_unique">
        /// If True, the input arrays are both assumed to be unique, which
        /// can speed up the calculation.  Default is False.
        /// </param>
        /// <param name="invert">
        /// If True, the values in the returned array are inverted (that is,
        /// False where an element of ar1 is in ar2 and True otherwise).
        /// Default is False. np.in1d(a, b, invert=True) is equivalent
        /// to (but is faster than) np.invert(in1d(a, b)).
        /// </param>
        /// <returns>
        /// The values ar1[in1d] are in ar2.
        /// </returns>
        public static NDarray in1d(NDarray ar1, NDarray ar2, bool? assume_unique = false, bool? invert = false)
            => NumPy.Instance.in1d(ar1, ar2, assume_unique:assume_unique, invert:invert);
        
        /// <summary>
        /// Find the intersection of two arrays.
        /// 
        /// Return the sorted, unique values that are in both of the input arrays.
        /// </summary>
        /// <param name="ar2">
        /// Input arrays. Will be flattened if not already 1D.
        /// </param>
        /// <param name="ar1">
        /// Input arrays. Will be flattened if not already 1D.
        /// </param>
        /// <param name="assume_unique">
        /// If True, the input arrays are both assumed to be unique, which
        /// can speed up the calculation.  Default is False.
        /// </param>
        /// <param name="return_indices">
        /// If True, the indices which correspond to the intersection of the two
        /// arrays are returned. The first instance of a value is used if there are
        /// multiple. Default is False.
        /// </param>
        /// <returns>
        /// A tuple of:
        /// intersect1d
        /// Sorted 1D array of common and unique elements.
        /// comm1
        /// The indices of the first occurrences of the common values in ar1.
        /// Only provided if return_indices is True.
        /// comm2
        /// The indices of the first occurrences of the common values in ar2.
        /// Only provided if return_indices is True.
        /// </returns>
        public static (NDarray, NDarray, NDarray) intersect1d(NDarray ar2, NDarray ar1, bool assume_unique = false, bool return_indices = false)
            => NumPy.Instance.intersect1d(ar2, ar1, assume_unique, return_indices);
        
        /// <summary>
        /// Calculates element in test_elements, broadcasting over element only.
        /// Returns a boolean array of the same shape as element that is True
        /// where an element of element is in test_elements and False otherwise.
        /// 
        /// Notes
        /// 
        /// isin is an element-wise function version of the python keyword in.
        /// isin(a, b) is roughly equivalent to
        /// np.array([item in b for item in a]) if a and b are 1-D sequences.
        /// 
        /// element and test_elements are converted to arrays if they are not
        /// already. If test_elements is a set (or other non-sequence collection)
        /// it will be converted to an object array with one element, rather than an
        /// array of the values contained in test_elements. This is a consequence
        /// of the array constructorâ€™s way of handling non-sequence collections.
        /// Converting the set to a list usually gives the desired behavior.
        /// </summary>
        /// <param name="element">
        /// Input array.
        /// </param>
        /// <param name="test_elements">
        /// The values against which to test each value of element.
        /// This argument is flattened if it is an array or array_like.
        /// See notes for behavior with non-array-like parameters.
        /// </param>
        /// <param name="assume_unique">
        /// If True, the input arrays are both assumed to be unique, which
        /// can speed up the calculation.  Default is False.
        /// </param>
        /// <param name="invert">
        /// If True, the values in the returned array are inverted, as if
        /// calculating element not in test_elements. Default is False.
        /// np.isin(a, b, invert=True) is equivalent to (but faster
        /// than) np.invert(np.isin(a, b)).
        /// </param>
        /// <returns>
        /// Has the same shape as element. The values element[isin]
        /// are in test_elements.
        /// </returns>
        public static NDarray isin(NDarray element, NDarray test_elements, bool? assume_unique = false, bool? invert = false)
            => NumPy.Instance.isin(element, test_elements, assume_unique:assume_unique, invert:invert);
        
        /// <summary>
        /// Find the set difference of two arrays.
        /// 
        /// Return the unique values in ar1 that are not in ar2.
        /// </summary>
        /// <param name="ar1">
        /// Input array.
        /// </param>
        /// <param name="ar2">
        /// Input comparison array.
        /// </param>
        /// <param name="assume_unique">
        /// If True, the input arrays are both assumed to be unique, which
        /// can speed up the calculation.  Default is False.
        /// </param>
        /// <returns>
        /// 1D array of values in ar1 that are not in ar2. The result
        /// is sorted when assume_unique=False, but otherwise only sorted
        /// if the input is sorted.
        /// </returns>
        public static NDarray setdiff1d(NDarray ar1, NDarray ar2, bool assume_unique = false)
            => NumPy.Instance.setdiff1d(ar1, ar2, assume_unique);
        
        /// <summary>
        /// Find the set exclusive-or of two arrays.
        /// 
        /// Return the sorted, unique values that are in only one (not both) of the
        /// input arrays.
        /// </summary>
        /// <param name="ar2">
        /// Input arrays.
        /// </param>
        /// <param name="ar1">
        /// Input arrays.
        /// </param>
        /// <param name="assume_unique">
        /// If True, the input arrays are both assumed to be unique, which
        /// can speed up the calculation.  Default is False.
        /// </param>
        /// <returns>
        /// Sorted 1D array of unique values that are in only one of the input
        /// arrays.
        /// </returns>
        public static NDarray setxor1d(NDarray ar2, NDarray ar1, bool assume_unique = false)
            => NumPy.Instance.setxor1d(ar2, ar1, assume_unique);
        
        /// <summary>
        /// Find the union of two arrays.
        /// 
        /// Return the unique, sorted array of values that are in either of the two
        /// input arrays.
        /// </summary>
        /// <param name="ar2">
        /// Input arrays. They are flattened if they are not already 1D.
        /// </param>
        /// <param name="ar1">
        /// Input arrays. They are flattened if they are not already 1D.
        /// </param>
        /// <returns>
        /// Unique, sorted union of the input arrays.
        /// </returns>
        public static NDarray union1d(NDarray ar2, NDarray ar1)
            => NumPy.Instance.union1d(ar2, ar1);
        
        
    }
}
