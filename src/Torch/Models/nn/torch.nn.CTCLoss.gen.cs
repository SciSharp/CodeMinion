// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Python.Runtime;
using Numpy;
using Numpy.Models;

namespace Torch
{
    public static partial class torch {
        public static partial class nn {
            /// <summary>
            ///	The Connectionist Temporal Classification loss.<br></br>
            ///	
            ///	Calculates loss between a continuous (unsegmented) time series and a target sequence.<br></br>
            ///	 CTCLoss sums over the
            ///	probability of possible alignments of input to target, producing a loss value which is differentiable
            ///	with respect to each input node.<br></br>
            ///	 The alignment of input to target is assumed to be “many-to-one”, which
            ///	limits the length of the target sequence such that it must be \(\leq\) the input length.
            /// </summary>
            public partial class CTCLoss : Module
            {
                // auto-generated class
                
                public CTCLoss(PyObject pyobj) : base(pyobj) { }
                
                public CTCLoss(Module other) : base(other.PyObject as PyObject) { }
                
                public CTCLoss(int blank = 0, string reduction = "mean", bool zero_infinity = false)
                {
                    //auto-generated code, do not change
                    var nn = self.GetAttr("nn");
                    var __self__=nn;
                    var pyargs=ToTuple(new object[]
                    {
                    });
                    var kwargs=new PyDict();
                    if (blank!=0) kwargs["blank"]=ToPython(blank);
                    if (reduction!="mean") kwargs["reduction"]=ToPython(reduction);
                    if (zero_infinity!=false) kwargs["zero_infinity"]=ToPython(zero_infinity);
                    dynamic py = __self__.InvokeMethod("CTCLoss", pyargs, kwargs);
                    self=py as PyObject;
                }
                
            }
        }
    }
    
}
