// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Python.Runtime;
using Numpy;
using Numpy.Models;

namespace Torch
{
    public static partial class torch {
        public static partial class nn {
            /// <summary>
            ///	Creates a criterion that optimizes a multi-class classification hinge
            ///	loss (margin-based loss) between input \(x\) (a 2D mini-batch Tensor) and
            ///	output \(y\) (which is a 1D tensor of target class indices,
            ///	\(0 \leq y \leq \text{x.size}(1)-1\)):
            ///	
            ///	For each mini-batch sample, the loss in terms of the 1D input \(x\) and scalar
            ///	output \(y\) is:
            ///	
            ///	\[\text{loss}(x, y) = \frac{\sum_i \max(0, \text{margin} - x[y] + x[i]))^p}{\text{x.size}(0)}
            ///	
            ///	\]
            ///	
            ///	where \(x \in \left\{0, \; \cdots , \; \text{x.size}(0) - 1\right\}\)
            ///	and \(i \neq y\).<br></br>
            ///	
            ///	Optionally, you can give non-equal weighting on the classes by passing
            ///	a 1D weight tensor into the constructor.<br></br>
            ///	
            ///	The loss function then becomes:
            ///	
            ///	\[\text{loss}(x, y) = \frac{\sum_i \max(0, w[y] * (\text{margin} - x[y] + x[i]))^p)}{\text{x.size}(0)}
            ///	
            ///	\]
            /// </summary>
            public partial class MultiMarginLoss : Module
            {
                // auto-generated class
                
                public MultiMarginLoss(PyObject pyobj) : base(pyobj) { }
                
                public MultiMarginLoss(Module other) : base(other.PyObject as PyObject) { }
                
                public MultiMarginLoss(int? p = 1, float? margin = 1.0f, Tensor weight = null, bool? size_average = null, bool? reduce = null, string reduction = "mean")
                {
                    //auto-generated code, do not change
                    var nn = self.GetAttr("nn");
                    var __self__=nn;
                    var pyargs=ToTuple(new object[]
                    {
                    });
                    var kwargs=new PyDict();
                    if (p!=1) kwargs["p"]=ToPython(p);
                    if (margin!=1.0f) kwargs["margin"]=ToPython(margin);
                    if (weight!=null) kwargs["weight"]=ToPython(weight);
                    if (size_average!=null) kwargs["size_average"]=ToPython(size_average);
                    if (reduce!=null) kwargs["reduce"]=ToPython(reduce);
                    if (reduction!="mean") kwargs["reduction"]=ToPython(reduction);
                    dynamic py = __self__.InvokeMethod("MultiMarginLoss", pyargs, kwargs);
                    self=py as PyObject;
                }
                
            }
        }
    }
    
}
