// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Python.Runtime;
using Numpy;
using Numpy.Models;

namespace Torch
{
    public static partial class torch {
        public static partial class nn {
            /// <summary>
            ///	Extracts sliding local blocks from a batched input tensor.<br></br>
            ///	
            ///	Consider an batched input tensor of shape \((N, C, *)\),
            ///	where \(N\) is the batch dimension, \(C\) is the channel dimension,
            ///	and \(*\) represent arbitrary spatial dimensions.<br></br>
            ///	 This operation flattens
            ///	each sliding kernel_size-sized block within the spatial dimensions
            ///	of input into a column (i.e., last dimension) of a 3-D output
            ///	tensor of shape \((N, C \times \prod(\text{kernel\_size}), L)\), where
            ///	\(C \times \prod(\text{kernel\_size})\) is the total number of values
            ///	within each block (a block has \(\prod(\text{kernel\_size})\) spatial
            ///	locations each containing a \(C\)-channeled vector), and \(L\) is
            ///	the total number of such blocks:
            ///	
            ///	\[L = \prod_d \left\lfloor\frac{\text{spatial\_size}[d] + 2 \times \text{padding}[d] %
            ///	    - \text{dilation}[d] \times (\text{kernel\_size}[d] - 1) - 1}{\text{stride}[d]} + 1\right\rfloor,
            ///	
            ///	\]
            ///	
            ///	where \(\text{spatial\_size}\) is formed by the spatial dimensions
            ///	of input (\(*\) above), and \(d\) is over all spatial
            ///	dimensions.<br></br>
            ///	
            ///	Therefore, indexing output at the last dimension (column dimension)
            ///	gives all values within a certain block.<br></br>
            ///	
            ///	The padding, stride and dilation arguments specify
            ///	how the sliding blocks are retrieved.<br></br>
            ///	
            ///	stride controls the stride for the sliding blocks.<br></br>
            ///	
            ///	padding controls the amount of implicit zero-paddings on both
            ///	sides for padding number of points for each dimension before
            ///	reshaping.<br></br>
            ///	
            ///	dilation controls the spacing between the kernel points; also known as the Ã  trous algorithm.<br></br>
            ///	
            ///	It is harder to describe, but this link has a nice visualization of what dilation does.
            /// </summary>
            public partial class Unfold : Module
            {
                // auto-generated class
                
                public Unfold(PyObject pyobj) : base(pyobj) { }
                
                public Unfold(Module other) : base(other.PyObject as PyObject) { }
                
                public Unfold(int[] kernel_size, int[] stride = null, int[] padding = null, int[] dilation = null)
                {
                    //auto-generated code, do not change
                    var nn = self.GetAttr("nn");
                    var __self__=nn;
                    var pyargs=ToTuple(new object[]
                    {
                        kernel_size,
                    });
                    var kwargs=new PyDict();
                    if (stride!=null) kwargs["stride"]=ToPython(stride);
                    if (padding!=null) kwargs["padding"]=ToPython(padding);
                    if (dilation!=null) kwargs["dilation"]=ToPython(dilation);
                    dynamic py = __self__.InvokeMethod("Unfold", pyargs, kwargs);
                    self=py as PyObject;
                }
                public Unfold(int kernel_size, int? stride = 1, int? padding = 0, int? dilation = 1)
                {
                    //auto-generated code, do not change
                    var nn = self.GetAttr("nn");
                    var __self__=nn;
                    var pyargs=ToTuple(new object[]
                    {
                        kernel_size,
                    });
                    var kwargs=new PyDict();
                    if (stride!=1) kwargs["stride"]=ToPython(stride);
                    if (padding!=0) kwargs["padding"]=ToPython(padding);
                    if (dilation!=1) kwargs["dilation"]=ToPython(dilation);
                    dynamic py = __self__.InvokeMethod("Unfold", pyargs, kwargs);
                    self=py as PyObject;
                }
                
            }
        }
    }
    
}
