// Code generated by CodeMinion: https://github.com/SciSharp/CodeMinion

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using Python.Runtime;
using Numpy;
using Numpy.Models;


namespace Torch
{
    public static partial class torch
    {
        
        public static bool is_tensor(Object obj)
            => PyTorch.Instance.is_tensor(obj);
        
        public static bool is_storage(Object obj)
            => PyTorch.Instance.is_storage(obj);
        
        public static bool is_floating_point(Tensor tensor)
            => PyTorch.Instance.is_floating_point(tensor);
        
        public static void set_default_dtype(Dtype d)
            => PyTorch.Instance.set_default_dtype(d);
        
        public static void get_default_dtype()
            => PyTorch.Instance.get_default_dtype();
        
        public static void set_default_tensor_type(Dtype t)
            => PyTorch.Instance.set_default_tensor_type(t);
        
        public static void numel(Tensor input)
            => PyTorch.Instance.numel(input);
        
        //public static void set_printoptions(int precision =  4, int threshold =  1000, int edgeitems =  3, int linewidth =  80,  profile, bool sci_mode)
        //    => PyTorch.Instance.set_printoptions(precision:precision, threshold:threshold, edgeitems:edgeitems, linewidth:linewidth, profile, sci_mode);
        
        //public static void set_flush_denormal(bool mode)
        //    => PyTorch.Instance.set_flush_denormal(mode);
        
        //public static Tensor sparse_coo_tensor(int indices, (array_like) values,  size, Dtype dtype = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.sparse_coo_tensor(indices, values, size, dtype:dtype, device:device, requires_grad:requires_grad);
        
        //public static Tensor sparse_coo_tensor<T>(int indices, (array_like) values,  size, Dtype dtype = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.sparse_coo_tensor(indices, values, size, dtype:dtype, device:device, requires_grad:requires_grad);
        
        //public static Tensor as_tensor((array_like) data, Dtype dtype = null, Device device = null)
        //    => PyTorch.Instance.as_tensor(data, dtype:dtype, device:device);
        
        //public static Tensor as_tensor<T>((array_like) data, Dtype dtype = null, Device device = null)
        //    => PyTorch.Instance.as_tensor(data, dtype:dtype, device:device);
        
        //public static Tensor from_numpy()
        //    => PyTorch.Instance.from_numpy();
        
        //public static Tensor zeros(Shape sizes, Tensor @out = null, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.zeros(sizes, @out:@out, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static Tensor zeros_like(Tensor input, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.zeros_like(input, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static Tensor ones(Shape sizes, Tensor @out = null, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.ones(sizes, @out:@out, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static Tensor ones_like(Tensor input, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.ones_like(input, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static Tensor arange(double start, double end, double step, Tensor @out = null, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.arange(start, end, step, @out:@out, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static Tensor range(float start, float end, float step, Tensor @out = null, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.range(start, end, step, @out:@out, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static Tensor linspace(float start, float end, int steps, Tensor @out = null, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.linspace(start, end, steps, @out:@out, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static Tensor logspace(float start, float end, int steps, float @base, Tensor @out = null, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.logspace(start, end, steps, @base, @out:@out, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static Tensor eye(int n, int? m = null, Tensor @out = null, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.eye(n, m:m, @out:@out, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        public static Tensor empty(Shape sizes, Tensor @out = null, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null, bool? pin_memory = null)
            => PyTorch.Instance.empty(sizes, @out:@out, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad, pin_memory:pin_memory);
        
        //public static Tensor empty_like(Tensor input, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.empty_like(input, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static Tensor full(Shape size,  fill_value, Tensor @out = null, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.full(size, fill_value, @out:@out, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static Tensor full_like(Tensor input,  fill_value, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.full_like(input, fill_value, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static Tensor cat( tensors, int? dim = null, Tensor @out = null)
        //    => PyTorch.Instance.cat(tensors, dim:dim, @out:@out);
        
        //public static void chunk(Tensor tensor, int chunks, int dim)
        //    => PyTorch.Instance.chunk(tensor, chunks, dim);
        
        //public static Tensor gather(Tensor input, int dim, (LongTensor) index, Tensor @out = null, (bool,optional) sparse_grad)
        //    => PyTorch.Instance.gather(input, dim, index, @out:@out, sparse_grad);
        
        //public static Tensor index_select(Tensor input, int dim, (LongTensor) index, Tensor @out = null)
        //    => PyTorch.Instance.index_select(input, dim, index, @out:@out);
        
        //public static Tensor masked_select(Tensor input, (ByteTensor) mask, Tensor @out = null)
        //    => PyTorch.Instance.masked_select(input, mask, @out:@out);
        
        //public static Tensor narrow(Tensor input, int dimension, int start, int length)
        //    => PyTorch.Instance.narrow(input, dimension, start, length);
        
        //public static void nonzero(Tensor input, LongTensor @out = null)
        //    => PyTorch.Instance.nonzero(input, @out:@out);
        
        //public static Tensor reshape(Tensor input,  shape)
        //    => PyTorch.Instance.reshape(input, shape);
        
        //public static void split(Tensor tensor, int split_size_or_sections, int dim)
        //    => PyTorch.Instance.split(tensor, split_size_or_sections, dim);
        
        //public static Tensor squeeze(Tensor input, int? dim = null, Tensor @out = null)
        //    => PyTorch.Instance.squeeze(input, dim:dim, @out:@out);
        
        //public static Tensor stack( seq, int dim, Tensor @out = null)
        //    => PyTorch.Instance.stack(seq, dim, @out:@out);
        
        //public static Tensor t(Tensor input)
        //    => PyTorch.Instance.t(input);
        
        //public static Tensor take(Tensor input, (LongTensor) indices)
        //    => PyTorch.Instance.take(input, indices);
        
        //public static Tensor transpose(Tensor input, int dim0, int dim1)
        //    => PyTorch.Instance.transpose(input, dim0, dim1);
        
        //public static void unbind(Tensor tensor, int dim)
        //    => PyTorch.Instance.unbind(tensor, dim);
        
        //public static Tensor unsqueeze(Tensor input, int dim, Tensor @out = null)
        //    => PyTorch.Instance.unsqueeze(input, dim, @out:@out);
        
        //public static Tensor @where((ByteTensor) condition, Tensor x, Tensor y)
        //    => PyTorch.Instance.@where(condition, x, y);
        
        //public static void manual_seed(int seed)
        //    => PyTorch.Instance.manual_seed(seed);
        
        //public static void initial_seed()
        //    => PyTorch.Instance.initial_seed();
        
        //public static void get_rng_state()
        //    => PyTorch.Instance.get_rng_state();
        
        //public static void set_rng_state(torch.ByteTensor new_state)
        //    => PyTorch.Instance.set_rng_state(new_state);
        
        //public static Tensor bernoulli(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.bernoulli(input, @out:@out);
        
        //public static void multinomial(Tensor input, int num_samples, bool? replacement = null, Tensor @out = null)
        //    => PyTorch.Instance.multinomial(input, num_samples, replacement:replacement, @out:@out);
        
        //public static void normal()
        //    => PyTorch.Instance.normal();
        
        //public static Tensor normal()
        //    => PyTorch.Instance.normal();
        
        //public static Tensor normal()
        //    => PyTorch.Instance.normal();
        
        //public static Tensor normal()
        //    => PyTorch.Instance.normal();
        
        //public static Tensor rand(Shape sizes, Tensor @out = null, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.rand(sizes, @out:@out, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static Tensor rand_like(Tensor input, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.rand_like(input, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static Tensor randint(int? low = null, int high, (tuple) size, Tensor @out = null, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.randint(low:low, high, size, @out:@out, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static Tensor randint_like(Tensor input, int? low = null, int high, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.randint_like(input, low:low, high, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static Tensor randn(Shape sizes, Tensor @out = null, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.randn(sizes, @out:@out, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static Tensor randn_like(Tensor input, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.randn_like(input, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static void randperm(int n, Tensor @out = null, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.randperm(n, @out:@out, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static void save( obj,  f,  pickle_module,  pickle_protocol)
        //    => PyTorch.Instance.save(obj, f, pickle_module, pickle_protocol);
        
        //public static void load( f,  map_location,  pickle_module,  pickle_load_args)
        //    => PyTorch.Instance.load(f, map_location, pickle_module, pickle_load_args);
        
        //public static void get_num_threads()
        //    => PyTorch.Instance.get_num_threads();
        
        //public static void set_num_threads()
        //    => PyTorch.Instance.set_num_threads();
        
        //public static Tensor abs(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.abs(input, @out:@out);
        
        //public static Tensor acos(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.acos(input, @out:@out);
        
        //public static void @add()
        //    => PyTorch.Instance.@add();
        
        //public static void @add()
        //    => PyTorch.Instance.@add();
        
        //public static void @add()
        //    => PyTorch.Instance.@add();
        
        //public static Tensor addcdiv(Tensor tensor, double? @value = null, Tensor tensor1, Tensor tensor2, Tensor @out = null)
        //    => PyTorch.Instance.addcdiv(tensor, @value:@value, tensor1, tensor2, @out:@out);
        
        //public static Tensor addcmul(Tensor tensor, double? @value = null, Tensor tensor1, Tensor tensor2, Tensor @out = null)
        //    => PyTorch.Instance.addcmul(tensor, @value:@value, tensor1, tensor2, @out:@out);
        
        //public static Tensor asin(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.asin(input, @out:@out);
        
        //public static Tensor atan(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.atan(input, @out:@out);
        
        //public static Tensor atan2(Tensor input1, Tensor input2, Tensor @out = null)
        //    => PyTorch.Instance.atan2(input1, input2, @out:@out);
        
        //public static Tensor ceil(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.ceil(input, @out:@out);
        
        //public static Tensor clamp(Tensor input, double min, double max, Tensor @out = null)
        //    => PyTorch.Instance.clamp(input, min, max, @out:@out);
        
        //public static Tensor clamp()
        //    => PyTorch.Instance.clamp();
        
        //public static Tensor clamp()
        //    => PyTorch.Instance.clamp();
        
        //public static Tensor cos(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.cos(input, @out:@out);
        
        //public static Tensor cosh(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.cosh(input, @out:@out);
        
        //public static void div()
        //    => PyTorch.Instance.div();
        
        //public static Tensor div()
        //    => PyTorch.Instance.div();
        
        //public static Tensor div()
        //    => PyTorch.Instance.div();
        
        //public static Tensor digamma(Tensor input)
        //    => PyTorch.Instance.digamma(input);
        
        //public static Tensor erf(Tensor tensor, Tensor @out = null)
        //    => PyTorch.Instance.erf(tensor, @out:@out);
        
        //public static Tensor erfc(Tensor tensor, Tensor @out = null)
        //    => PyTorch.Instance.erfc(tensor, @out:@out);
        
        //public static Tensor erfinv(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.erfinv(input, @out:@out);
        
        //public static Tensor exp(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.exp(input, @out:@out);
        
        //public static Tensor expm1(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.expm1(input, @out:@out);
        
        //public static Tensor floor(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.floor(input, @out:@out);
        
        //public static Tensor fmod(Tensor input,  divisor, Tensor @out = null)
        //    => PyTorch.Instance.fmod(input, divisor, @out:@out);
        
        //public static Tensor frac()
        //    => PyTorch.Instance.frac();
        
        //public static void lerp(Tensor start, Tensor end,  weight, Tensor @out = null)
        //    => PyTorch.Instance.lerp(start, end, weight, @out:@out);
        
        //public static Tensor log(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.log(input, @out:@out);
        
        //public static Tensor log10(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.log10(input, @out:@out);
        
        //public static Tensor log1p(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.log1p(input, @out:@out);
        
        //public static Tensor log2(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.log2(input, @out:@out);
        
        //public static void mul()
        //    => PyTorch.Instance.mul();
        
        //public static void mul()
        //    => PyTorch.Instance.mul();
        
        //public static void mul()
        //    => PyTorch.Instance.mul();
        
        //public static Tensor mvlgamma(Tensor input, int p)
        //    => PyTorch.Instance.mvlgamma(input, p);
        
        //public static Tensor neg(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.neg(input, @out:@out);
        
        //public static void pow()
        //    => PyTorch.Instance.pow();
        
        //public static Tensor pow()
        //    => PyTorch.Instance.pow();
        
        //public static Tensor pow()
        //    => PyTorch.Instance.pow();
        
        //public static Tensor reciprocal(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.reciprocal(input, @out:@out);
        
        //public static Tensor remainder(Tensor input,  divisor, Tensor @out = null)
        //    => PyTorch.Instance.remainder(input, divisor, @out:@out);
        
        //public static Tensor round(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.round(input, @out:@out);
        
        //public static Tensor rsqrt(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.rsqrt(input, @out:@out);
        
        //public static Tensor sigmoid(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.sigmoid(input, @out:@out);
        
        //public static Tensor sign(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.sign(input, @out:@out);
        
        //public static Tensor sin(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.sin(input, @out:@out);
        
        //public static Tensor sinh(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.sinh(input, @out:@out);
        
        //public static Tensor sqrt(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.sqrt(input, @out:@out);
        
        //public static Tensor tan(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.tan(input, @out:@out);
        
        //public static Tensor tanh(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.tanh(input, @out:@out);
        
        //public static Tensor trunc(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.trunc(input, @out:@out);
        
        //public static void argmax()
        //    => PyTorch.Instance.argmax();
        
        //public static void argmax()
        //    => PyTorch.Instance.argmax();
        
        //public static void argmax()
        //    => PyTorch.Instance.argmax();
        
        //public static void argmin()
        //    => PyTorch.Instance.argmin();
        
        //public static void argmin()
        //    => PyTorch.Instance.argmin();
        
        //public static void argmin()
        //    => PyTorch.Instance.argmin();
        
        //public static Tensor cumprod(Tensor input, int dim, Dtype dtype = null, Tensor @out = null)
        //    => PyTorch.Instance.cumprod(input, dim, dtype:dtype, @out:@out);
        
        //public static Tensor cumsum(Tensor input, int dim, Dtype dtype = null, Tensor @out = null)
        //    => PyTorch.Instance.cumsum(input, dim, dtype:dtype, @out:@out);
        
        //public static Tensor dist(Tensor input, Tensor other, float? p = null)
        //    => PyTorch.Instance.dist(input, other, p:p);
        
        //public static void logsumexp(Tensor input,  dim, bool keepdim, Tensor @out = null)
        //    => PyTorch.Instance.logsumexp(input, dim, keepdim, @out:@out);
        
        //public static void mean()
        //    => PyTorch.Instance.mean();
        
        //public static Tensor mean()
        //    => PyTorch.Instance.mean();
        
        //public static Tensor mean()
        //    => PyTorch.Instance.mean();
        
        //public static void median()
        //    => PyTorch.Instance.median();
        
        //public static Tensor median()
        //    => PyTorch.Instance.median();
        
        //public static void median()
        //    => PyTorch.Instance.median();
        
        //public static void mode(Tensor input, int dim, bool keepdim, Tensor values = null, Tensor indices = null)
        //    => PyTorch.Instance.mode(input, dim, keepdim, values:values, indices:indices);
        
        //public static void norm(Tensor input, (abs(x)**ord)**(1./ord) p,  dim, bool? keepdim = null, Tensor @out = null, Dtype dtype = null)
        //    => PyTorch.Instance.norm(input, p, dim, keepdim:keepdim, @out:@out, dtype:dtype);
        
        //public static void prod()
        //    => PyTorch.Instance.prod();
        
        //public static Tensor prod()
        //    => PyTorch.Instance.prod();
        
        //public static Tensor prod()
        //    => PyTorch.Instance.prod();
        
        //public static void std()
        //    => PyTorch.Instance.std();
        
        //public static Tensor std()
        //    => PyTorch.Instance.std();
        
        //public static Tensor std()
        //    => PyTorch.Instance.std();
        
        //public static void sum()
        //    => PyTorch.Instance.sum();
        
        //public static Tensor sum()
        //    => PyTorch.Instance.sum();
        
        //public static Tensor sum()
        //    => PyTorch.Instance.sum();
        
        //public static void unique(Tensor input, bool sorted, bool return_inverse, bool return_counts, int dim)
        //    => PyTorch.Instance.unique(input, sorted, return_inverse, return_counts, dim);
        
        //public static void unique_consecutive(Tensor input, bool return_inverse, bool return_counts, int dim)
        //    => PyTorch.Instance.unique_consecutive(input, return_inverse, return_counts, dim);
        
        //public static void @var()
        //    => PyTorch.Instance.@var();
        
        //public static Tensor @var()
        //    => PyTorch.Instance.@var();
        
        //public static Tensor @var()
        //    => PyTorch.Instance.@var();
        
        //public static void allclose(Tensor self, Tensor other, float? atol = null, float? rtol = null, float? equal_nan = null)
        //    => PyTorch.Instance.allclose(self, other, atol:atol, rtol:rtol, equal_nan:equal_nan);
        
        //public static void argsort(Tensor input, int? dim = null, bool? @descending = null)
        //    => PyTorch.Instance.argsort(input, dim:dim, @descending:@descending);
        
        //public static Tensor eq(Tensor input,  other, Tensor @out = null)
        //    => PyTorch.Instance.eq(input, other, @out:@out);
        
        //public static void equal()
        //    => PyTorch.Instance.equal();
        
        //public static Tensor ge(Tensor input,  other, Tensor @out = null)
        //    => PyTorch.Instance.ge(input, other, @out:@out);
        
        //public static Tensor gt(Tensor input,  other, Tensor @out = null)
        //    => PyTorch.Instance.gt(input, other, @out:@out);
        
        //public static void isfinite(Tensor tensor)
        //    => PyTorch.Instance.isfinite(tensor);
        
        //public static void isinf(Tensor tensor)
        //    => PyTorch.Instance.isinf(tensor);
        
        //public static void isnan(Tensor tensor)
        //    => PyTorch.Instance.isnan(tensor);
        
        //public static void kthvalue(Tensor input, int k, int? dim = null, bool keepdim, tuple @out = null)
        //    => PyTorch.Instance.kthvalue(input, k, dim:dim, keepdim, @out:@out);
        
        //public static Tensor le(Tensor input,  other, Tensor @out = null)
        //    => PyTorch.Instance.le(input, other, @out:@out);
        
        //public static Tensor lt(Tensor input,  other, Tensor @out = null)
        //    => PyTorch.Instance.lt(input, other, @out:@out);
        
        //public static void max()
        //    => PyTorch.Instance.max();
        
        //public static Tensor max()
        //    => PyTorch.Instance.max();
        
        //public static void max()
        //    => PyTorch.Instance.max();
        
        //public static Tensor max()
        //    => PyTorch.Instance.max();
        
        //public static void min()
        //    => PyTorch.Instance.min();
        
        //public static Tensor min()
        //    => PyTorch.Instance.min();
        
        //public static void min()
        //    => PyTorch.Instance.min();
        
        //public static Tensor min()
        //    => PyTorch.Instance.min();
        
        //public static Tensor ne(Tensor input,  other, Tensor @out = null)
        //    => PyTorch.Instance.ne(input, other, @out:@out);
        
        //public static void sort(Tensor input, int? dim = null, bool? @descending = null, tuple @out = null)
        //    => PyTorch.Instance.sort(input, dim:dim, @descending:@descending, @out:@out);
        
        //public static void topk(Tensor input, int k, int? dim = null, bool? largest = null, bool? sorted = null, tuple @out = null)
        //    => PyTorch.Instance.topk(input, k, dim:dim, largest:largest, sorted:sorted, @out:@out);
        
        //public static Tensor fft(Tensor input, int signal_ndim, bool? normalized = null)
        //    => PyTorch.Instance.fft(input, signal_ndim, normalized:normalized);
        
        //public static Tensor ifft(Tensor input, int signal_ndim, bool? normalized = null)
        //    => PyTorch.Instance.ifft(input, signal_ndim, normalized:normalized);
        
        //public static Tensor rfft(Tensor input, int signal_ndim, bool? normalized = null, bool? onesided = null)
        //    => PyTorch.Instance.rfft(input, signal_ndim, normalized:normalized, onesided:onesided);
        
        //public static Tensor irfft(Tensor input, int signal_ndim, bool? normalized = null, bool? onesided = null,  signal_sizes)
        //    => PyTorch.Instance.irfft(input, signal_ndim, normalized:normalized, onesided:onesided, signal_sizes);
        
        //public static void stft(Tensor input, int n_fft, int? hop_length = null, int? win_length = null, Tensor window = null, bool? center = null, string pad_mode = null, bool? normalized = null, bool? onesided = null)
        //    => PyTorch.Instance.stft(input, n_fft, hop_length:hop_length, win_length:win_length, window:window, center:center, pad_mode:pad_mode, normalized:normalized, onesided:onesided);
        
        //public static Tensor bartlett_window(int window_length, bool? periodic = null, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.bartlett_window(window_length, periodic:periodic, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static Tensor blackman_window(int window_length, bool? periodic = null, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.blackman_window(window_length, periodic:periodic, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static Tensor hamming_window(int window_length, bool? periodic = null, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.hamming_window(window_length, periodic:periodic, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static Tensor hann_window(int window_length, bool? periodic = null, Dtype dtype = null, Layout layout = null, Device device = null, bool? requires_grad = null)
        //    => PyTorch.Instance.hann_window(window_length, periodic:periodic, dtype:dtype, layout:layout, device:device, requires_grad:requires_grad);
        
        //public static Tensor bincount(Tensor input, Tensor weights, int minlength)
        //    => PyTorch.Instance.bincount(input, weights, minlength);
        
        //public static void broadcast_tensors(int *tensors)
        //    => PyTorch.Instance.broadcast_tensors(*tensors);
        
        //public static void cartesian_prod(int *tensors)
        //    => PyTorch.Instance.cartesian_prod(*tensors);
        
        //public static void combinations(Tensor tensor, int? r = null, bool? with_replacement = null)
        //    => PyTorch.Instance.combinations(tensor, r:r, with_replacement:with_replacement);
        
        //public static Tensor cross(Tensor input, Tensor other, int? dim = null, Tensor @out = null)
        //    => PyTorch.Instance.cross(input, other, dim:dim, @out:@out);
        
        //public static Tensor diag(Tensor input, int? diagonal = null, Tensor @out = null)
        //    => PyTorch.Instance.diag(input, diagonal:diagonal, @out:@out);
        
        //public static Tensor diag_embed(Tensor input, int? offset = null, int? dim1 = null, int? dim2 = null)
        //    => PyTorch.Instance.diag_embed(input, offset:offset, dim1:dim1, dim2:dim2);
        
        //public static Tensor diagflat(Tensor input, int? offset = null)
        //    => PyTorch.Instance.diagflat(input, offset:offset);
        
        //public static Tensor diagonal(Tensor input, int? offset = null, int? dim1 = null, int? dim2 = null)
        //    => PyTorch.Instance.diagonal(input, offset:offset, dim1:dim1, dim2:dim2);
        
        //public static Tensor einsum(int equation,  operands)
        //    => PyTorch.Instance.einsum(equation, operands);
        
        //public static Tensor flatten(Tensor input, int start_dim, int end_dim)
        //    => PyTorch.Instance.flatten(input, start_dim, end_dim);
        
        //public static Tensor flip(Tensor input,  dims)
        //    => PyTorch.Instance.flip(input, dims);
        
        //public static Tensor rot90(Tensor input, int k,  dims)
        //    => PyTorch.Instance.rot90(input, k, dims);
        
        //public static Tensor histc(Tensor input, int bins, int min, int max, Tensor @out = null)
        //    => PyTorch.Instance.histc(input, bins, min, max, @out:@out);
        
        //public static void meshgrid(Tensor[] tensors)
        //    => PyTorch.Instance.meshgrid(tensors);
        
        //public static Tensor renorm(Tensor input, float p, int dim, float maxnorm, Tensor @out = null)
        //    => PyTorch.Instance.renorm(input, p, dim, maxnorm, @out:@out);
        
        //public static void repeat_interleave()
        //    => PyTorch.Instance.repeat_interleave();
        
        //public static Tensor repeat_interleave()
        //    => PyTorch.Instance.repeat_interleave();
        
        //public static Tensor repeat_interleave()
        //    => PyTorch.Instance.repeat_interleave();
        
        //public static Tensor roll(Tensor input, int shifts,  dims)
        //    => PyTorch.Instance.roll(input, shifts, dims);
        
        //public static void tensordot(Tensor a, Tensor b, int dims)
        //    => PyTorch.Instance.tensordot(a, b, dims);
        
        //public static Tensor trace()
        //    => PyTorch.Instance.trace();
        
        //public static Tensor tril(Tensor input, int? diagonal = null, Tensor @out = null)
        //    => PyTorch.Instance.tril(input, diagonal:diagonal, @out:@out);
        
        //public static Tensor tril_indices(int row, int column, int offset, Dtype dtype = null, Device device = null, Layout layout = null)
        //    => PyTorch.Instance.tril_indices(row, column, offset, dtype:dtype, device:device, layout:layout);
        
        //public static Tensor triu(Tensor input, int? diagonal = null, Tensor @out = null)
        //    => PyTorch.Instance.triu(input, diagonal:diagonal, @out:@out);
        
        //public static Tensor triu_indices(int row, int column, int offset, Dtype dtype = null, Device device = null, Layout layout = null)
        //    => PyTorch.Instance.triu_indices(row, column, offset, dtype:dtype, device:device, layout:layout);
        
        //public static Tensor addbmm(double? beta = null, Tensor mat, double? alpha = null, Tensor batch1, Tensor batch2, Tensor @out = null)
        //    => PyTorch.Instance.addbmm(beta:beta, mat, alpha:alpha, batch1, batch2, @out:@out);
        
        //public static Tensor addmm(double? beta = null, Tensor mat, double? alpha = null, Tensor mat1, Tensor mat2, Tensor @out = null)
        //    => PyTorch.Instance.addmm(beta:beta, mat, alpha:alpha, mat1, mat2, @out:@out);
        
        //public static Tensor addmv(double? beta = null, Tensor tensor, double? alpha = null, Tensor mat, Tensor vec, Tensor @out = null)
        //    => PyTorch.Instance.addmv(beta:beta, tensor, alpha:alpha, mat, vec, @out:@out);
        
        //public static Tensor addr(double? beta = null, Tensor mat, double? alpha = null, Tensor vec1, Tensor vec2, Tensor @out = null)
        //    => PyTorch.Instance.addr(beta:beta, mat, alpha:alpha, vec1, vec2, @out:@out);
        
        //public static Tensor baddbmm(double? beta = null, Tensor mat, double? alpha = null, Tensor batch1, Tensor batch2, Tensor @out = null)
        //    => PyTorch.Instance.baddbmm(beta:beta, mat, alpha:alpha, batch1, batch2, @out:@out);
        
        //public static Tensor bmm(Tensor batch1, Tensor batch2, Tensor @out = null)
        //    => PyTorch.Instance.bmm(batch1, batch2, @out:@out);
        
        //public static void btrifact()
        //    => PyTorch.Instance.btrifact();
        
        //public static void btrifact_with_info()
        //    => PyTorch.Instance.btrifact_with_info();
        
        //public static void btrisolve()
        //    => PyTorch.Instance.btrisolve();
        
        //public static void btriunpack()
        //    => PyTorch.Instance.btriunpack();
        
        //public static void chain_matmul(Tensor[] matrices)
        //    => PyTorch.Instance.chain_matmul(matrices);
        
        //public static Tensor cholesky(Tensor a, bool? upper = null, Tensor @out = null)
        //    => PyTorch.Instance.cholesky(a, upper:upper, @out:@out);
        
        //public static Tensor cholesky_inverse(Tensor u, bool? upper = null, Tensor @out = null)
        //    => PyTorch.Instance.cholesky_inverse(u, upper:upper, @out:@out);
        
        //public static Tensor cholesky_solve(Tensor b, Tensor u, bool? upper = null, Tensor @out = null)
        //    => PyTorch.Instance.cholesky_solve(b, u, upper:upper, @out:@out);
        
        //public static Tensor dot()
        //    => PyTorch.Instance.dot();
        
        //public static void eig(Tensor a, bool eigenvectors, tuple @out = null)
        //    => PyTorch.Instance.eig(a, eigenvectors, @out:@out);
        
        //public static Tensor gels(Tensor B, Tensor A, tuple @out = null)
        //    => PyTorch.Instance.gels(B, A, @out:@out);
        
        //public static void geqrf(Tensor input, tuple @out = null)
        //    => PyTorch.Instance.geqrf(input, @out:@out);
        
        //public static Tensor ger(Tensor vec1, Tensor vec2, Tensor @out = null)
        //    => PyTorch.Instance.ger(vec1, vec2, @out:@out);
        
        //public static void gesv()
        //    => PyTorch.Instance.gesv();
        
        //public static Tensor inverse(Tensor input, Tensor @out = null)
        //    => PyTorch.Instance.inverse(input, @out:@out);
        
        //public static Tensor det(Tensor A)
        //    => PyTorch.Instance.det(A);
        
        //public static Tensor logdet(Tensor A)
        //    => PyTorch.Instance.logdet(A);
        
        //public static void slogdet(Tensor A)
        //    => PyTorch.Instance.slogdet(A);
        
        //public static void lu(Tensor A, bool? pivot = null, bool? get_infos = null, tuple @out = null)
        //    => PyTorch.Instance.lu(A, pivot:pivot, get_infos:get_infos, @out:@out);
        
        //public static Tensor lu_solve(Tensor b, Tensor LU_data, (IntTensor) LU_pivots, Tensor @out = null)
        //    => PyTorch.Instance.lu_solve(b, LU_data, LU_pivots, @out:@out);
        
        //public static void lu_unpack(Tensor LU_data, Tensor LU_pivots, bool unpack_data, bool unpack_pivots)
        //    => PyTorch.Instance.lu_unpack(LU_data, LU_pivots, unpack_data, unpack_pivots);
        
        //public static Tensor matmul(Tensor tensor1, Tensor tensor2, Tensor @out = null)
        //    => PyTorch.Instance.matmul(tensor1, tensor2, @out:@out);
        
        //public static Tensor matrix_power(Tensor input, int n)
        //    => PyTorch.Instance.matrix_power(input, n);
        
        //public static Tensor matrix_rank(Tensor input, float? tol = null, bool? symmetric = null)
        //    => PyTorch.Instance.matrix_rank(input, tol:tol, symmetric:symmetric);
        
        //public static Tensor mm(Tensor mat1, Tensor mat2, Tensor @out = null)
        //    => PyTorch.Instance.mm(mat1, mat2, @out:@out);
        
        //public static Tensor mv(Tensor mat, Tensor vec, Tensor @out = null)
        //    => PyTorch.Instance.mv(mat, vec, @out:@out);
        
        //public static Tensor orgqr(Tensor a, Tensor tau)
        //    => PyTorch.Instance.orgqr(a, tau);
        
        //public static Tensor ormqr(Tensor a, Tensor tau, Tensor mat)
        //    => PyTorch.Instance.ormqr(a, tau, mat);
        
        //public static Tensor pinverse(Tensor input, float rcond)
        //    => PyTorch.Instance.pinverse(input, rcond);
        
        //public static void potrf()
        //    => PyTorch.Instance.potrf();
        
        //public static void potri()
        //    => PyTorch.Instance.potri();
        
        //public static void potrs()
        //    => PyTorch.Instance.potrs();
        
        //public static void pstrf(Tensor a, bool? upper = null, tuple @out = null)
        //    => PyTorch.Instance.pstrf(a, upper:upper, @out:@out);
        
        //public static void qr(Tensor input, tuple @out = null)
        //    => PyTorch.Instance.qr(input, @out:@out);
        
        //public static void solve(Tensor B, Tensor A,  @out)
        //    => PyTorch.Instance.solve(B, A, @out);
        
        //public static void svd(Tensor input, bool? some = null, tuple @out = null)
        //    => PyTorch.Instance.svd(input, some:some, @out:@out);
        
        //public static void symeig(Tensor input, bool? eigenvectors = null, bool? upper = null, tuple @out = null)
        //    => PyTorch.Instance.symeig(input, eigenvectors:eigenvectors, upper:upper, @out:@out);
        
        //public static void triangular_solve(Tensor A, Tensor b, bool? upper = null, bool? transpose = null, bool? unitriangular = null)
        //    => PyTorch.Instance.triangular_solve(A, b, upper:upper, transpose:transpose, unitriangular:unitriangular);
        
        //public static void trtrs()
        //    => PyTorch.Instance.trtrs();
        
        //public static void compiled_with_cxx11_abi()
        //    => PyTorch.Instance.compiled_with_cxx11_abi();
        
        
    }
}
